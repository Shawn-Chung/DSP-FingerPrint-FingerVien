//! 
//# c64xx.cdb 4.90.270

object ISRAM :: MEM {
    param iComment :: "This object defines space for the DSP's on-chip memory"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 1024
    param len :: 1047552
    param iAllocHeap :: 0
    param iHeapSize :: 0
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object CACHE_L2 :: MEM {
    param iComment :: "Generated by Cache Settings in GBL"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "MEM"
    param iDelMsg :: "L2 Cache cannot be deleted by user"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 0
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "Cache"
    param iIsModifiable :: 0
}

class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (if self.gNumOf > 0 {1} else {0})
    prop NoGen :: 0
    prop IsDirty :: ($a = self.gDirty, self.gDirty = 0, $a)
    prop dataSize :: 0
    prop error :: # ("Error: ", self.name, $1)
    prop warning :: ("Warning ...", self.name, $1)
    prop minBit :: ($a = 0, while (($1 & (1 << $a)) && $a < 32) {++$a}, $a)
    prop name :: ("<unnamed module>")
    prop numBit :: ($a = $b = 0, while ($a < 32) {if ($1 & (1 << $a)) {++$b} }, $b)
}

class ObjectMgr {
    isa Module
    prop CanCreate :: (if (self.gNumOf < self.maxObjs()) {self.localCanCreate()} else {self.warning("Maximum number of objects already created")})
    prop CanDelete :: (if (self.iDelMsg == "ok" || (self.iDelUser == self.gUser)) {if (self.iId >= 0 && self.iIsUsed) {self.localCanDelete()} else {self.warning("Object already deleted")}} else {self.warning(self.iDelMsg)})
    prop Create :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanCreate()) == "ok") {if (($a = self.localCreate()) == "ok") {if (self.iIsUsed == 0) {self.mkId(if $0 > 1 {$2} else {-1}), self.iIsUsed = 1, GlobalStatus.gDirty = 1, self.gDirty = 1} } } , (self.gUser = "USER"), $a)
    prop Delete :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanDelete()) == "ok") {if (($a = self.localDelete()) == "ok") {self.rmId(self.iId), self.iIsUsed = 0, GlobalStatus.gDirty = 1, self.gDirty = 1} } , (self.gUser = "USER"), $a)
    prop GetSetOf :: (self.gSetOf)
    prop GetNumOf :: (self.gNumOf)
    prop GetObjId :: (self.iId)
    prop GetPriority :: (self.iId)
    prop SetPriority :: (self.iId = $1)
    prop IsConfObj :: (self.iIsUsed)
    prop localCanCreate :: ("ok")
    prop localCanDelete :: ("ok")
    prop localCreate :: ("ok")
    prop localDelete :: ("ok")
    prop localInit :: (0)
    prop isFinite :: (if self.maxObjs() <= GBL.DSPWORDSIZE {1} else {0})
    prop mkId :: (if (self.isFinite()) {if ($1 < 0) {self.iId = self.minBit(self.gSetOf)} else {self.iId = $1}, (self.gSetOf |= (1 << self.iId))} else {self.iId = 0}, ++self.gNumOf, self.iId)
    prop rmId :: (if (self.isFinite()) {self.gSetOf &= ~(1 << self.iId)} , --self.gNumOf)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop isDriver :: (0)
    prop SortChildHierView :: (1)
}

type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (100)
    prop GlobalPropertyPage :: ("{9D3AD931-847B-11d0-A621-0000C070F3E9}")
    prop Status :: (# self.SeedVersion, # self.MinStackSize, # self.SysDataSize)
    global GENLIB :: "bioscfg.dll" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generation Library"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global DATE :: "Mon Jun 04 10:54:16 2012" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GCONFVERS :: "@(#)*** xdc-c37" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SysDataSize :: = ($a = 0, scan ($i; nil) {if ($i.dataSize() != nil) {$a = $a + $i.dataSize()} }, $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Estimated Data Size: %d"
        prop StatusField :: 1
        prop NoGen :: 1
    }
    global MinStackSize :: = ($a = ((2 * (2)) * 4), $a = $a + ((2 * (5)) * 4), $a = $a + ((0) * 4), $b = 0, scan ($i; CLK) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (2)) * 4) * $b), $b = 0, scan ($i; HWI) {if ($i.IsConfObj()) {if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {$b++} } }, $a = $a + (((12 + 14 + 2) * 4) * $b), $b = 0, scan ($i; SWI) {if ($i.IsConfObj()) {if ($i.priority > $b) {$b = $i.priority} } }, $a = $a + ((((2 * 2) + 18 + (2 * 4)) * 4) * $b), $b = 0, scan ($i; PRD) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (3)) * 4) * $b), $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Est. Min. Stack Size (MAUs): %d"
        prop StatusField :: 1
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ConfigWarnings :: = (if (self.MinStackSize > MEM.STACKSIZE) {"Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."} else {"None"}) { 
        prop Label :: "Warnings"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SeedVersion :: = "@(#)*** cuda-4.90.00.27" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

class EModule {
    isa Module
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class ModuleFolder {
    isa Module
    prop NoGen :: 1
}

type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (500)
    prop GlobalPropertyPage :: ("{B936FB91-52A5-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (501)
    prop GlobalPropertyPage :: ("{053C8F90-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (502)
    prop GlobalPropertyPage :: ("{053C8F91-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (503)
    prop GlobalPropertyPage :: ("{053C8F92-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (504)
    prop GlobalPropertyPage :: ("{053C8F93-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type PROJ {
    isa ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (201)
    prop GlobalHelpTopic :: (101)
    prop InstancePropertyPage :: ("{AC3C77D1-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D2-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ALIASALL :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate C Names for All Objects"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global IGNOREWARNING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Ignore Warnings"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Include File Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global OBJDIR :: "." { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object file directory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTEXE :: "out" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Executable File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTLIB :: "lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTASM :: "asm" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Assembly Language Source File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTOBJ :: "obj" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst projType :: "Executable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Executable,Library"
        prop Label :: "Target Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst projName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst useRpt :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RPT Instruction"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst minimizeSpace :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Optimize for Space over Time"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst tmx :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Avoid TMX Silicon Bugs"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    prop Label :: "Project File Manager"
    prop InstanceHelpTopic :: (BIOSHELP_PROJ_FILE_INSTANCE)
    prop GlobalHelpTopic :: (BIOSHELP_PROJ_FILE_GLOBAL)
    prop InstancePropertyPage :: ("{AC3C77D3-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D4-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst elemType :: "C Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C Source,ASM Source,Library,Linker Command File"
        prop Label :: "Input File Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Input File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "register,register+local,register+local+global,register+local+global+file"
        prop Label :: "Optimization Level"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst inline :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Inline Expansion"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst definitions :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Additional Definitions"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst iParent :: 0 { 
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 1
    prop GenLinkPrologue :: (if ((GBL.ROM == 1) && (GBL.DSPTYPE == 54)) {"%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-lbios5402.o54%24t/* BIOS ROM library */%0t\n-l%2S%3S\n%15S%4S%16S%5S%6S%12S%7S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, _chipStr, _sioLibStr"} else {"%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-l%2S%3S\n%15S%4S%16S%5S%6S%12S%7S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, _chipStr, _sioLibStr"})
    prop GenLinkEpilogue :: ("%0t_GBL_CACHE = GBL_CACHE;\n\0")
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
    prop GlobalHelpTopic :: (103)
    prop InstanceHelpTopic :: (103)
    prop InstancePropertyPage :: ("{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}")
    prop localInit :: (RTA_toHost.Create("HST"), RTA_fromHost.Create("HST"), RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"))
    prop chipcall :: ("ok")
    prop IsConfMod :: 1
    prop L2Check :: (if (self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711) {self.PCC = "mapped", if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} } else {if (self.DSPSUBTYPE == 6400) {self.PCC = "mapped", if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} } else {if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} else {if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} }}}, self.L2CacheSizeCheck())
    prop C621xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C621XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "SRAM") {CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "1-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6713" || self.CHIPTYPE == "DA610" {0x3c000} else {0xc000}, CACHE_L2.len = 0x4000} else {if (self.L2MODEOPTS == "2-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6713" || self.CHIPTYPE == "DA610" {0x38000} else {0x8000}, CACHE_L2.len = 0x8000} else {if (self.L2MODEOPTS == "3-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6713" || self.CHIPTYPE == "DA610" {0x34000} else {0x4000}, CACHE_L2.len = 0xc000} else {if (self.L2MODEOPTS == "4-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6713" || self.CHIPTYPE == "DA610" {0x30000} else {0x0000}, CACHE_L2.len = 0x10000} }}}}}, $e)
    prop C641xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C641XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (0k)") {CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6412" || self.CHIPTYPE == "DM642" {0x38000} else {0xf8000}, CACHE_L2.len = 0x8000} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6412" || self.CHIPTYPE == "DM642" {0x30000} else {0xf0000}, CACHE_L2.len = 0x10000} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6412" || self.CHIPTYPE == "DM642" {0x20000} else {0xe0000}, CACHE_L2.len = 0x20000} else {if (self.C641XL2MODEOPTS == "4-way cache (256k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = if self.CHIPTYPE == "6412" || self.CHIPTYPE == "DM642" {0x0} else {0xc0000}, CACHE_L2.len = 0x40000} }}}}}, $e)
    prop L2CacheSizeCheck :: ($e = "ok", scan ($i; MEM) {if ($i == CACHE_L2) {if (self.C621XL2CONFIGURE) {$e = self.C621xL2CacheSizeCheck()} else {if (self.C641XL2CONFIGURE) {$e = self.C641xL2CacheSizeCheck()} else {if ((self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711)) {$e = self.C621xL2CacheSizeCheck()} else {if (self.DSPSUBTYPE == 6400) {$e = self.C641xL2CacheSizeCheck()} else {CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")}}}}} }, $e)
    prop setCPUClock :: ($e = "ok", if ($1 != self.CPUCLOCK) {$a = self.CPUCLOCK, self.CPUCLOCK = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.CPUCLOCK = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    prop setCSLNAME :: (if (self.ENDIAN == "big") {if self.CHIPTYPE == "6201" {"csl6201e.lib"} else {if self.CHIPTYPE == "6202" {"csl6202e.lib"} else {if self.CHIPTYPE == "6203" {"csl6203e.lib"} else {if self.CHIPTYPE == "6204" {"csl6204e.lib"} else {if self.CHIPTYPE == "6205" {"csl6205e.lib"} else {if self.CHIPTYPE == "6211" {"csl6211e.lib"} else {if self.CHIPTYPE == "6701" {"csl6701e.lib"} else {if self.CHIPTYPE == "6711" {"csl6711e.lib"} else {if self.CHIPTYPE == "6712" {"csl6712e.lib"} else {if self.CHIPTYPE == "6713" {"csl6713e.lib"} else {if self.CHIPTYPE == "DA610" {"cslDA610e.lib"} else {if self.CHIPTYPE == "DM642" {"cslDM642e.lib"} else {if self.CHIPTYPE == "6412" {"csl6412e.lib"} else {if self.CHIPTYPE == "6414" {"csl6414e.lib"} else {if self.CHIPTYPE == "6415" {"csl6415e.lib"} else {if self.CHIPTYPE == "6416" {"csl6416e.lib"} else {""}}}}}}}}}}}}}}}}} else {if self.CHIPTYPE == "6201" {"csl6201.lib"} else {if self.CHIPTYPE == "6202" {"csl6202.lib"} else {if self.CHIPTYPE == "6203" {"csl6203.lib"} else {if self.CHIPTYPE == "6204" {"csl6204.lib"} else {if self.CHIPTYPE == "6205" {"csl6205.lib"} else {if self.CHIPTYPE == "6211" {"csl6211.lib"} else {if self.CHIPTYPE == "6701" {"csl6701.lib"} else {if self.CHIPTYPE == "6711" {"csl6711.lib"} else {if self.CHIPTYPE == "6712" {"csl6712.lib"} else {if self.CHIPTYPE == "6713" {"csl6713.lib"} else {if self.CHIPTYPE == "DA610" {"cslDA610.lib"} else {if self.CHIPTYPE == "DM642" {"cslDM642.lib"} else {if self.CHIPTYPE == "6412" {"csl6412.lib"} else {if self.CHIPTYPE == "6414" {"csl6414.lib"} else {if self.CHIPTYPE == "6415" {"csl6415.lib"} else {if self.CHIPTYPE == "6416" {"csl6416.lib"} else {""}}}}}}}}}}}}}}}}})
    prop cGenCPrologue :: ("\n#ifdef __cplusplus\n#pragma CODE_SECTION(\".text:CSL_cfgInit\")\n#else\n#pragma CODE_SECTION(CSL_cfgInit,\".text:CSL_cfgInit\")\n#endif\n
\n#ifdef __cplusplus\n#pragma FUNC_EXT_CALLED()\n#else\n#pragma FUNC_EXT_CALLED(CSL_cfgInit)\n#endif\n")
    prop setL2MODE :: (if (self.L2MODEOPTS == "SRAM") {0x0} else {if (self.L2MODEOPTS == "1-way cache") {0x1} else {if (self.L2MODEOPTS == "2-way cache") {0x2} else {if (self.L2MODEOPTS == "3-way cache") {0x3} else {0x7}}}})
    prop setC641XL2MODE :: (if (self.C641XL2MODEOPTS == "4-way cache (0k)") {0x0} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {0x1} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {0x2} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {0x3} else {0x7}}}})
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (if (HST.RTDX == 1) {"lnkrtdx"} else {if (HST.DSM == 1) {"lnkdsm"} else {if (HST.EVM54 == 1) {"lnkevm54"} else {"lnknone"}}})
    prop _dsptype :: GBL.DSPTYPE
    prop _compilerModel :: if self.ENDIAN == "big" {"e"} else {""}
    prop _librarySuffix :: (if (self.DSPSUBTYPE == 6400) {if (self.ENDIAN == "big") {".a64e"} else {".a64"}} else {if (self.ENDIAN == "big") {".a62e"} else {".a62"}})
    prop _devLibSuffix :: (if (self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711) {if (self.ENDIAN == "big") {".a67e"} else {".a67"}} else {if (self.DSPSUBTYPE == 6400) {if (self.ENDIAN == "big") {".a64e"} else {".a64"}} else {if (self.ENDIAN == "big") {".a62e"} else {".a62"}}})
    prop _rtdxLibStr :: if RTDX.RTDXTYPE == "JTAG" {"-lrtdx64xx%9S.lib %24t/* RTDX support */%0t\n"} else {if RTDX.RTDXTYPE == "Simulator" {"-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n"} else {"-lrtdxhs%9S.lib %24t/* RTDX support */%0t\n"}}
    prop _rtsLibStr :: (if (self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711) {"-lrts6700%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if (self.DSPSUBTYPE == 6400) {"-lrts6400%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {"-lrts6200%9S.lib%24t/* C and C++ run-time library support */%0t\n"}})
    prop _chipStr :: ""
    prop _biosLibStr :: if self.ENABLEINST {"-lbiosi%8S %24t/* DSP/BIOS support */%0t\n"} else {"-lbios%8S %24t/* DSP/BIOS support */%0t\n"}
    prop _sioLibStr :: if SIO.USEISSUERECLAIM == 1 {"-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n"} else {"-lsioboth%8S %24t/* supports both SIO models */%0t\n"}
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (if (MEM.LNKCMDFILE == "") {""} else {"-l%11S %24t/* User Specified Linker cmd file */%0t\n"})
    prop _cslLibStr :: if self.CSLNAME == "" {""} else {"-l%13S\n"}
    prop _chipType :: self.CSLNAME
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRODUCT :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop EnvField :: 1
    }
    global CALLBACKOBJ :: CLK { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: hTimer { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c64xx" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CPUCLOCK :: 720.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MIPS :: 720.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = self.MIPS, $b = if (GBL.DSPTYPE == 62) {$1} else {$1 * 2}, $e = "ok", self.MIPS = $1, if (($e = self.setCPUClock($b)) != "ok") {self.MIPS = $a} , $e)
    }
    global OSTYPE :: "BIOS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPTYPE :: 62 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPSUBTYPE :: 6400 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "6400"
        prop Label :: "DSP Type"
        prop Visible :: 1
        prop Writable :: self.CHIPTYPE == "other" || self.CHIPTYPE == "custom"
        prop Set :: (self.DSPSUBTYPE = $1, self.L2Check(), "ok")
        prop NoGen :: 1
    }
    global CHIPTYPE :: "6414" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DM642,6412,6414,6415,6416,other"
        prop Label :: "Chip Support Library (CSL)"
        prop JSName :: "CHIPTYPE"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == "6201" || $1 == "6202" || $1 == "6203" || $1 == "6204" || $1 == "6205") {self.DSPSUBTYPE = 6200} else {if ($1 == "6701") {self.DSPSUBTYPE = 6700} else {if ($1 == "6211") {self.DSPSUBTYPE = 6211} else {if ($1 == "6711" || $1 == "6712" || $1 == "6713" || $1 == "DA610") {self.DSPSUBTYPE = 6711} else {if ($1 == "DM642" || $1 == "6412" || $1 == "6414" || $1 == "6415" || $1 == "6416") {self.DSPSUBTYPE = 6400} }}}}, self.CHIPTYPE = $1, self.CSLNAME = self.setCSLNAME(), if (self.CHIPTYPE == "other" || self.CHIPTYPE == "custom") {self.C621XL2CONFIGURE = 0, self.C641XL2CONFIGURE = 0, self.L2CONFIGURE = 0} , self.L2Check(), $e = "ok", if (GBL.CHIPCHAIN != nil) {$e = GBL.CHIPCHAIN.chipcall()} , $e)
    }
    global CSLNAME :: "csl6414.lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Chip Support Library Name"
        prop Visible :: 1
        prop Writable :: self.CHIPTYPE == "custom"
        prop NoGen :: 1
    }
    global DISPCALLCSLCFGINIT :: = (self.CHIPTYPE != "other" && self.CHIPTYPE != "custom") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: self.SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C62XX" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPARITHMETIC :: = (if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {"FLOAT"} else {"FIXED"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {32} else {16}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (if GBL.DSPTYPE == 62 {8} else {GBL.DSPWORDSIZE}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DATAPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {16} else {if (GBL.DSPTYPE == 55) {if (GBL.MEMORYMODEL == "SMALL") {16} else {23}} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {if (GBL.CALLMODEL == "near") {16} else {24}} else {if (GBL.DSPTYPE == 55) {24} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENDIAN :: "little" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "little,big"
        prop Label :: "DSP Endian Mode"
        prop JSName :: "ENDIANMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.ENDIAN = $1, self.CSLNAME = self.setCSLNAME(), "ok")
    }
    global BIGENDIAN :: = if self.ENDIAN == "little" {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global AUTOINIT :: "ROM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.USERINITFXN = @_FXN_F_nop, self.USERINIT = $1} else {self.USERINIT = $1}, "ok")
    }
    global USERINITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: self.USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENABLEINST :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEINST) {if ($1) {RTA_toHost.Create("HST"), RTA_fromHost.Create("HST"), RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE} else {RTA_toHost.Delete("HST"), RTA_fromHost.Delete("HST"), RTA_dispatcher.Delete("HST"), IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0}, self.ENABLEINST = $1} , "ok")
    }
    global CGENERATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global PCC :: "mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Program Cache Control - CSR(PCC)       "
        prop JSName :: "CSRPCC"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400 || GBL.CHIPTYPE == "other" || GBL.CHIPTYPE == "custom") {0} else {1}
        prop NoGen :: 1
        prop TabName :: "620x/670x"
    }
    global DCC :: "mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Data Cache Control"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "620x/670x"
    }
    global PCACHE :: = (if (self.PCC == "mapped") {0x0000} else {if (self.PCC == "cache enable") {0x0040} else {if (self.PCC == "cache freeze") {0x0060} else {0x0080}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DCACHE :: = (if (self.DCC == "mapped") {0x0000} else {if (self.DCC == "cache enable") {0x0008} else {if (self.DCC == "cache freeze") {0x000c} else {0x0010}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CACHE :: = (self.PCACHE | self.DCACHE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global C621XL2CONFIGURE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "621x/671x - Configure L2 Memory Settings"
        prop JSName :: "C621XCONFIGUREL2"
        prop Visible :: 1
        prop Writable :: if (GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610") {1} else {0}
        prop TabName :: "621x/671x"
        prop Set :: ($e = "ok", self.C621XL2CONFIGURE = $1, self.L2CONFIGURE = $1, self.PCC = "mapped", $e = self.L2CacheSizeCheck(), $e)
        prop NoGen :: 1
    }
    global C641XL2CONFIGURE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x - Configure L2 Memory Settings"
        prop JSName :: "C641XCONFIGUREL2"
        prop Visible :: 1
        prop Writable :: if (GBL.CHIPTYPE == "6414" || GBL.CHIPTYPE == "6415" || GBL.CHIPTYPE == "6416" || GBL.CHIPTYPE == "6412" || GBL.CHIPTYPE == "DM642") {1} else {0}
        prop TabName :: "641x"
        prop Set :: ($e = "ok", self.C641XL2CONFIGURE = $1, self.L2CONFIGURE = $1, self.PCC = "mapped", $e = self.L2CacheSizeCheck(), $e)
        prop NoGen :: 1
    }
    global L2CONFIGURE :: = (self.C621XL2CONFIGURE | self.C641XL2CONFIGURE) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure L2 Cache Control (c6x1x support)"
        prop Visible :: 0
        prop NoGen :: 0
    }
    global C621XPCC :: "Cache Enabled - Direct Mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "Program Cache Control - CSR(PCC)                     "
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "621x/671x"
    }
    global C641XPCC :: "Cache Enabled - Direct Mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "641x - Program Cache Control - CSR(PCC)"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2MODEOPTS :: = "SRAM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE)"
        prop JSName :: "C621XCCFGL2MODE"
        prop Enum :: "SRAM,1-way cache,2-way cache,3-way cache,4-way cache"
        prop Visible :: 1
        prop Writable :: if ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610") && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "621x/671x"
        prop Set :: ($i = self.L2MODEOPTS, self.L2MODEOPTS = $1, $e = self.L2CacheSizeCheck(), if ($e != "ok") {self.L2MODEOPTS = $i} , $e)
    }
    global C641XL2MODEOPTS :: "4-way cache (0k)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Mode - CCFG(L2MODE)"
        prop Enum :: "4-way cache (0k),4-way cache (32k),4-way cache (64k),4-way cache (128k),4-way cache (256k)"
        prop JSName :: "C641XCCFGL2MODE"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
        prop Set :: ($i = self.C641XL2MODEOPTS, self.C641XL2MODEOPTS = $1, $e = self.L2CacheSizeCheck(), if ($e != "ok") {self.C641XL2MODEOPTS = $i} , $e)
    }
    global L2MODE :: = if (GBL.DSPSUBTYPE == 6400) {self.setC641XL2MODE()} else {self.setL2MODE()} { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE) Values"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: if ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610") && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
    }
    global L2PRIORITY :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Requestor Priority - CCFG(P)"
        prop Enum :: "0,1"
        prop Visible :: 0
        prop Writable :: if ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610") && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
    }
    global L2MARMASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "L2 MAR0-15 - bitmask used to initialize MARs"
        prop JSName :: "C621XMAR"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610") && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "621x/671x"
    }
    global SUPPORTCSL :: = self.CHIPTYPE != "other" { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.TRCMASKVALUE = 0xDBEF} else {self.TRCMASKVALUE = 0x4000}, self.ENABLEALLTRC = $1, "ok")
    }
    global TRCMASKVALUE :: 56303 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT :: = self.DISPCALLCSLCFGINIT { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global C641XL2PRIORITY :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK1 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR96-111 - bitmask controls EMIFB CE space"
        prop JSName :: "C641XMAREMIFB"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK2 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR128-143 - bitmask controls EMIFA CE0 space"
        prop JSName :: "C641XMARCE0"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK3 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR144-159 - bitmask controls EMIFA CE1 space"
        prop JSName :: "C641XMARCE1"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK4 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR160-175 - bitmask controls EMIFA CE2 space"
        prop JSName :: "C641XMARCE2"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK5 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR176-191 - bitmask controls EMIFA CE3 space"
        prop JSName :: "C641XMARCE3"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2REQPRIORITY :: "urgent" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Requestor Priority Queue - CCFG(P)"
        prop JSName :: "C641XCCFGP"
        prop Enum :: "urgent,high,medium,low"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop Set :: (self.L2REQPRIORITY = $1, if (self.L2REQPRIORITY == "urgent") {self.C641XL2PRIORITY = 0} else {if (self.L2REQPRIORITY == "high") {self.C641XL2PRIORITY = 1} else {if (self.L2REQPRIORITY == "medium") {self.C641XL2PRIORITY = 2} else {self.C641XL2PRIORITY = 3}}}, "ok")
        prop TabName :: "641x"
    }
    global L2CONFIGALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure Priority Queues"
        prop JSName :: "C641XSETL2ALLOC"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1)
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2ALLOC0 :: 6 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on URGENT Queue (L2ALLOC0)"
        prop JSName :: "C641XL2ALLOC0"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC1 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on HIGH Queue (L2ALLOC1)"
        prop JSName :: "C641XL2ALLOC1"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC2 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on MEDIUM Queue (L2ALLOC2)"
        prop JSName :: "C641XL2ALLOC2"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC3 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on LOW Queue (L2ALLOC3)"
        prop JSName :: "C641XL2ALLOC3"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC :: = ((self.L2ALLOC0) | (self.L2ALLOC1 << 4) | (self.L2ALLOC2 << 8) | (self.L2ALLOC3 << 12)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 0
    }
}

type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (108)
    prop InstanceHelpTopic :: (208)
    prop InstancePropertyPage :: ("{3D658E70-05E7-11d0-BD44-0020AFEE33C8}")
    prop GlobalPropertyPage :: ("{3D658E71-05E7-11d0-BD44-0020AFEE33C8}")
    prop GenLinkPrologue :: (if (GBL.DSPTYPE == 55) {"-stack 0x%1x\n-sysstack 0x%2x\n\nSECTIONS { .sysstack : block(0x20000) fill = 0xfeeb {%12t\nGBL_sysstackbeg = .;\n*(.sysstack)\nGBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n _HWI_SYSSTKBOTTOM =
(GBL_sysstackend+1);\n%8t} > %3s}%0t\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz, _sysstackSeg"} else {"-stack 0x%1x\nMEMORY {%4t\0, _stackSize"})
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (if (self.REUSE == 0 && self.USERCMD == 0) {"19\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 0 && self.USERCMD == 1) {"9\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 1 && self.USERCMD == 0) {"18\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"} else {"8\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"}}})
    prop _firstPlace :: 0
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace :: (0x7fffffff / 2)
    prop _sysinitPlace :: (0x7fffffff / 2)
    prop _argsString :: ("%8t .args: fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString :: ("%8t .bss:     {}")
    prop _farString :: ("%8t .far:     {}")
    prop _cinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CINITSEG == MEM.LOADCINITSEG) {"%8t .cinit:    {}"} else {"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"}} else {"%8t .cinit:    {}"})
    prop _pinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.PINITSEG == MEM.LOADPINITSEG) {"%8t .pinit:   {}"} else {"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"}} else {"%8t .pinit:   {}"})
    prop _trcinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {"%8t .trcdata:   {}"} else {"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"}} else {"%8t .trcdata:    {}"})
    prop _gblinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {"%8t .gblinit:   {}"} else {"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"}} else {"%8t .gblinit:    {}"})
    prop _dataString :: ("%8t .data:    {}")
    prop _constString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {"%8t .const:   {}"} else {if ((62 == 54) || (62 == 28)) {"%8t .const:   {} load > %1s PAGE %2s, run\0, _loadconstSeg, _pg"} else {"%8t .const: {} load > %1s, run\0, _loadconstSeg"}}} else {"%8t .const:    {}"})
    prop _switchString :: (if (self.ENABLELOADSEG == 1) {if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {"%8t .switch:   {}"} else {"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"}} else {"%8t .switch:    {}"})
    prop _sysmemString :: ("%8t .sysmem:  {}")
    prop _cioString :: ("%8t .cio:     {}")
    prop _memObjString :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (if ((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {"%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"} else {"%8t .sysdata: {}"})
    prop _sysinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.INITSEG == MEM.LOADINITSEG) {"%8t .sysinit:   {}"} else {"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"}} else {"%8t .sysinit:    {}"})
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {"%8t .text:    {}"} else {"%8t .text:    {} load > %1s, run\0, _loadtextSeg"}} else {"%8t .text:    {}"})
    prop _frtString :: ("%8t frt:    {}")
    prop _biosString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {"%8t .bios:    {}"} else {"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"}} else {"%8t .bios:    {}"})
    prop _stackString :: (if (GBL.DSPTYPE == 62) {"%8t .stack: fill=0xc0ffee {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 4 & ~7;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"} else {if (GBL.DSPTYPE == 54) {"%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"} else {if (GBL.DSPTYPE == 55) {"%8t .stack: block(0x20000) fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n _HWI_STKTOP = (GBL_stackbeg);%8t\n }\0, _cmd55stksz"} else {"%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"}}})
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: ("%0t}")
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (if (self.iAllocHeap == 1) {"1\0, _instAllocDesc, _objMemSeg, _placement"} )
    prop _instAllocDesc :: (if self.INITSEG.iAllocHeap && self.REUSE && self.INITSEG == self {"%8t .%0r$heap: {%12t\n %0r$B = .;\n%12t\n _%0r_base = .;\n . += 0x%2x;\n *(.sysinit)\n %0r$L = . + 0x%3x - %0r$B;\n _%0r_length = . + 0x%3x - %0r$B;\n . += 0x%1x;%8t\n }\0, _heapsize, _sysinitgap, _heaplen"} else {"%8t .%0r$heap: {%12t\n %0r$B = .;\n _%0r_base = .;\n %0r$L = 0x%2x;\n _%0r_length = 0x%2x;\n . += 0x%1x;%8t\n }\0, _heapsize, _heaplen"})
    prop _objMemSeg :: self
    prop _placement :: 0x7fffffff - 1
    prop _heapsize :: (self.iHeapSize)
    prop _heaplen :: (self.iHeapSize)
    prop _sysinitgap :: 2 * 4
    prop GenInstLink :: (if GBL.DSPTYPE == 62 {"%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"} else {if GBL.DSPTYPE == 55 {"%0r: %16torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len"} else {"PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"}})
    prop localInit :: ($d = "ok", scan ($i; MEM) {if ($i.space == "code" && $i.iAllocHeap == 1) {$d = self.error("Code memory cannot have a heap")} }, if (self.SEGZERO.iAllocHeap == 1) {self.SEGZERO.iReqHeapCount++} else {$d = self.error("Segment for DSP/BIOS objects must be a memory segment with a heap")}, if (self.MALLOCSEG.iAllocHeap == 1) {self.MALLOCSEG.iReqHeapCount++} else {$d = self.error("Segment for malloc()/free() must be a memory segment with a heap")}, $d)
    prop _page :: (self.page)
    prop _origin :: (self.base)
    prop _len :: (self.len)
    prop maxObjs :: (32767)
    prop codeMember :: (if GBL.DSPTYPE == 62 {(($1.space == "code") || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 54 {($1.space == "code")} else {if GBL.DSPTYPE == 28 {($1.space == "code")} else {($1.space == "code/data")}}})
    prop dataMember :: (if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 28 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {(($1.space == "code/data") && ($1 != MEM_NULL))}}})
    prop dataNullMember :: (if GBL.DSPTYPE == 62 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 54 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 28 {$1.space != "code" && $1.space != "io"} else {$1.space == "code/data"}}})
    prop dataCodeMember :: (if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 28 {$1.space == "code" && $1 != MEM_NULL} else {$1.space == "code/data" && $1 != MEM_NULL}}})
    prop memWritable :: (self.iIsModifiable && self.iDelUser != "MEM")
    prop validate :: ($e = self.checkMemOverlap($1), if ($e == "ok") {$e = self.checkHeapSize($1)} , $e)
    prop checkHeapSize :: ($e = "ok", if (MEM.NOHEAPS == 0) {if ($1.iAllocHeap && $1 != MEM_NULL) {if ($1.iHeapSize > $1.len) {$e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")} } } , $e)
    prop checkMemOverlap :: ($e = "ok", if ($1 != MEM_NULL && $1.iIsUsed == 1) {if ($1.len == 0) {$a = $1.base} else {$a = ($1.base + $1.len - 1)}, scan ($j; MEM) {if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 && (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 55 || $1.space == $j.space)) {if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {$b = $j.base, if ($j.len == 0) {$c = $j.base} else {$c = ($j.base + $j.len - 1)}, if ($a >= $b && $1.base <= $c) {$e = ("MEM segment %s: overlaps with another segment or cache configuration."), break} } } }} , $e)
    prop checkHeapId :: ($e = "ok", scan ($i; MEM) {if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {$e = self.error("This identifier label is already in use"), break} }, $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 4 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap :: = ($a = 0, scan ($i; MEM) {if ($i != MEM_NULL) {$a += $i.iAllocHeap} }, $a) { 
        prop NoGen :: 0
    }
    global REUSE :: = (if self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1 {self.SAVEREUSE} else {0}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reuse Startup Code Space"
        prop JSName :: "REUSECODESPACE"
        prop Visible :: 1
        prop Writable :: self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1
        prop NoGen :: 1
        prop Set :: (self.SAVEREUSE = $1, "ok")
    }
    global SAVEREUSE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    global doCheckOverlap :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MAPSELECT :: "Map 1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Map Mode"
        prop JSName :: "MAPMODE"
        prop Enum :: "Map 0,Map 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ARGSSIZE :: 4 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Argument Buffer Size"
        prop JSName :: "ARGSSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("The 'arguments' section must have at least 4 words.")} else {self.ARGSSIZE = $1, "ok"})
    }
    global ARGSSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Argument Buffer Section (.args)"
        prop JSName :: "ARGSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global BIOSSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "BIOS Code Section (.bios)"
        prop JSName :: "BIOSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: 8192 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Stack Size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.STACKSIZE = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.STACKSIZE < GlobalStatus.MinStackSize) {"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!"} else {"ok"}
    }
    global USERCMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User .cmd File For Non-DSP/BIOS Sections"
        prop JSName :: "USERCOMMANDFILE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Stack Section (.stack)"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global ENABLELOADSEG :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
        prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - BIOS Code Section (.bios)"
        prop JSName :: "LOADBIOSSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global INITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Startup Code Section (.sysinit)"
        prop JSName :: "SYSINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - Startup Code Section (.sysinit)"
        prop JSName :: "LOADSYSINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "GBLINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "TRC Initial Value (.trcdata)"
        prop JSName :: "TRCDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "LOADGBLINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG :: = self.TRCINITSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - TRC Initial Value (.trcdata)"
        prop JSName :: "LOADTRCDATASEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SYSDATASEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Kernel State (.sysdata)"
        prop JSName :: "SYSDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
        prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No Dynamic Memory Heaps"
        prop JSName :: "NOMEMORYHEAPS"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.SEGZERO.iReqHeapCount--, self.SEGZERO = MEM_NULL, self.MALLOCSEG.iReqHeapCount--, self.MALLOCSEG = MEM_NULL, TSK.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, scan ($i; MEM) {if ($i.iAllocHeap && $i != MEM_NULL) {$i.iAllocHeap = 0, $i.iHeapSize = 0} }} , self.NOHEAPS = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.NOHEAPS == 1) {"Currently specified heaps no longer valid"} else {"Please reconfigure heaps under individual mem segments"}
    }
    global SEGZERO :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For DSP/BIOS Objects"
        prop JSName :: "BIOSOBJSEG"
        prop Visible :: 1
        prop Writable :: MEM.NOHEAPS == 0
        prop NoGen :: 0
        prop Set :: (if (self.SEGZERO.iReqHeapCount > 0) {self.SEGZERO.iReqHeapCount--} , self.SEGZERO = $1, self.SEGZERO.iReqHeapCount++, "ok")
    }
    global MALLOCSEG :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
        prop JSName :: "MALLOCSEG"
        prop Visible :: 1
        prop Writable :: (MEM.NOHEAPS == 0)
        prop NoGen :: 0
        prop Set :: (if (self.MALLOCSEG.iReqHeapCount > 0) {self.MALLOCSEG.iReqHeapCount--} , self.MALLOCSEG = $1, self.MALLOCSEG.iReqHeapCount++, "ok")
    }
    global LNKCMDFILE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TEXTSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Text Section (.text)"
        prop JSName :: "TEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Load Address - Text Section (.text)"
        prop JSName :: "LOADTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SWITCHSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Switch Jump Tables (.switch)"
        prop JSName :: "SWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Switch Jump Tables (.switch)"
        prop JSName :: "LOADSWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BSSSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.bss)"
        prop JSName :: "BSSSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global FARSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.far)"
        prop JSName :: "FARSEG"
        prop Visible :: if GBL.DSPTYPE == 62 {1} else {0}
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Data Initialization Section (.cinit)"
        prop JSName :: "CINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Data Initialization Section (.cinit)"
        prop JSName :: "LOADCINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global PINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "C Function Initialization Table (.pinit)"
        prop JSName :: "PINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADPINITSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - C Function Initialization Table (.pinit)"
        prop JSName :: "LOADPINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Constant Section (.const)"
        prop JSName :: "CONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Load Address - Constant Section (.const)"
        prop JSName :: "LOADCONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global DATASEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.data)"
        prop JSName :: "DATASEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.cio)"
        prop JSName :: "CIOSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global SYSMEMSEG :: = self.CIOSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.sysmem)"
        prop JSName :: "SYSMEMSEG"
        prop Visible :: 0
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG :: = HWI.STUBMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory (.hwi)"
        prop JSName :: "HWISEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.STUBMEMSEG = $1, HWI.STUBMEMSEG = $1, "ok")
    }
    global LOADSTUBMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - Function Stub Memory (.hwi)"
        prop JSName :: "LOADHWISEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global VECMEMSEG :: = HWI.VECMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "HWIVECSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.VECMEMSEG = $1, HWI.VECMEMSEG = $1, GlobalStatus.gDirty = 1, if ($1.base == 0) {HWI.GENERATE_RESET_VEC = 0} , "ok")
    }
    global LOADVECMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "LOADHWIVECSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG :: = RTDX.TEXTMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop JSName :: "RTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: RTDX.USERTDX
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.RTDXTEXTMEMSEG = $1, RTDX.TEXTMEMSEG = $1, "ok")
    }
    global LOADRTDXTEXTMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
        prop JSName :: "LOADRTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: (RTDX.USERTDX && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst base :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%06x"}
        prop Style :: 0x02
        prop Label :: "base"
        prop JSName :: "base"
        prop Visible :: 1
        prop Writable :: (self.iIsModifiable)
        prop NoGen :: 1
        prop Set :: (self.base = $1, "ok")
    }
    inst len :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x08
        prop Label :: "len"
        prop JSName :: "len"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 0
        prop Set :: (self.len = $1, "ok")
    }
    inst page :: = (if GBL.DSPTYPE == 62 {-1} else {if GBL.DSPTYPE == 55 {-1} else {if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {3}}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iAllocHeap :: if MEM.NOHEAPS == 1 {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
        prop JSName :: "createHeap"
        prop Visible :: 1
        prop Writable :: (self.space == "data" || self.space == "code/data") && (MEM.NOHEAPS == 0) && self.iIsModifiable
        prop NoGen :: 0
        prop Set :: ($a = "ok", if ($1 == 0 && self.iReqHeapCount > 0) {self.error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")} else {if ($1 == 0) {self.iUserHeapId = 0, self.iHeapId = @segment_name} , self.iAllocHeap = $1, MEM.gDirty = 1, $a})
    }
    inst iHeapSize :: 0x8000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x02
        prop Label :: "heap size"
        prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (self.iHeapSize = $1, "ok")
        prop NoGen :: 1
    }
    inst iSegZero :: = MEM.SEGZERO
    inst iUserHeapId :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "enter a user defined heap identifier label"
        prop JSName :: "enableHeapLabel"
        prop Set :: (if ($1 == 0) {self.iHeapId = @segment_name} , self.iUserHeapId = $1, "ok")
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0)
        prop NoGen :: 1
    }
    inst iHeapId :: @segment_name { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "heap identifier label"
        prop JSName :: "heapLabel"
        prop Set :: ($e = self.checkHeapId($1), if ($e == "ok") {self.iHeapId = $1} , $e)
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0) && (self.iUserHeapId)
        prop Visible :: 1
        prop NoGen :: 0
    }
    inst iReqHeapCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst space :: (if GBL.DSPTYPE == 55 {"code/data"} else {"data"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: if GBL.DSPTYPE == 62 {"code,data,code/data"} else {if GBL.DSPTYPE == 54 {"code,data,io,other"} else {if GBL.DSPTYPE == 28 {"code,data,io,other"} else {"code/data,io"}}}
        prop JSName :: "space"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 != "data" && $1 != "code/data" && self.iAllocHeap == 1) {$e = self.error("Cannot select this space if a heap will be created")} else {self.space = $1}, $e)
    }
    inst iIsModifiable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 1
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "data"
    param iIsModifiable :: 1
}

type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _objMemDesc, _memSeg, _placement"} )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type BUF {
    isa ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer pool Manager"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (421)
    prop GlobalHelpTopic :: (321)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,      _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t.buf:{}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength")
    prop _objAlign :: self.align
    prop _instMemSeg :: self.bufseg
    prop _buflength :: (self.postalignsize * self.bufcount)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"buf.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far BUF_Obj %0r;\n\0"} else {"extern BUF_Obj %0r;\n\0"})
    prop dataSize :: ($d = 0, scan ($i; BUF) {if ($i.IsConfObj()) {$d += $i.len} , $d += 7 * 4}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: SDRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Memory segment for buffer pool"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst bufcount :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer count"
        prop JSName :: "bufCount"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (self.bufcount = $1, self.postalignsize = (self.size + (self.align - 1)) & ~(self.align - 1), self.len = $1 * self.postalignsize, "ok")
    }
    inst size :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer size (MADUs)"
        prop JSName :: "size"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 8) {self.error("Size should be atleast 8 bytes")} else {self.size = $1, self.postalignsize = ($1 + (self.align - 1)) & ~(self.align - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst align :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer alignment(Power of 2)"
        prop JSName :: "align"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 4) {self.error("Alignment should be atleast 4 ")} else {self.align = $1, self.postalignsize = (self.size + ($1 - 1)) & ~($1 - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst len :: self.size { 
        prop Label :: "Buffer pool length (MADUs)"
        prop JSName :: "len"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst postalignsize :: self.size { 
        prop Label :: "Buffer size after alignment (MADUs)"
        prop JSName :: "postalignsize"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (202)
    prop GlobalHelpTopic :: (102)
    prop InstancePropertyPage :: ("{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}")
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {\n%8t _CLK_start = %6s;\n CLK_F_gethtime = %5s;\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn")
    prop _clkStartFxn :: if (GBL.SUPPORTCSL && self.USETIMER) {@_CLK_start6x} else {@FXN_F_nop}
    prop GenLinkEpilogue :: ("%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TDDR = CLK_TDDR;\n\0")
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no CLK objs */"}
    prop _memSeg :: CLK.OBJMEMSEG
    prop _objSize :: 1
    prop clkFxn :: if (self.USETIMER == 1) {self.CLKFXN} else {@FXN_F_zero}
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (if (GBL.CALLBACKOBJ != CLK) {CLK.gGBLChain = GBL.CALLBACKOBJ, GBL.CALLBACKOBJ = CLK} )
    prop dataSize :: (1 * (CLK.gNumOf + 1))
    prop localCanCreate :: (if self.USETIMER {"ok"} else {self.error("The CLK Manager must be enabled before inserting a CLK")})
    prop localCreate :: (CLK.HOOKFXN = @HWI_F_dispatch, self.seizeHwi(self.WHICHHWI), "ok")
    prop localDelete :: (if (self.gNumOf == 1) {if (GBL.CALLMODEL == "far") {CLK.HOOKFXN = @CLK_F_frete, self.seizeHwi(self.WHICHHWI)} else {CLK.HOOKFXN = @CLK_F_rete, self.seizeHwi(self.WHICHHWI)}} , "ok")
    prop adjustPrd :: (if GBL.DSPTYPE == 62 {0} else {1})
    prop seizeHwi :: (if ($1.client == "USER" && $1.function != @HWI_unused) {self.error("Interrupt mapped to selected timer is already in use.")} else {if ($1.client == "CSL") {self.error("Interrupt mapped to selected timer is already in use by CSL.")} else {$1.function = @CLK_F_isr, $1.client = "CLK", $1.iUseDispatcher = (if CLK.HOOKFXN == @HWI_F_dispatch {1} else {0}), $1.iArg = (if $1.iUseDispatcher == 1 {@CLK_A_TABBEG} else {0}), HWI.gDirty = 1, "ok"}})
    prop releaseHwi :: ($1.function = @HWI_unused, $1.client = "USER", $1.iUseDispatcher = 0, $1.iArg = 0, HWI.gDirty = 1, "ok")
    prop seizeTimer :: (if ($1 == "Timer 0") {self.WHICHTIMER = "Timer 0", self.WHICHHWI = Timer_0.iHwi, self.REGS = 0x01000, self.TIMERNUM = 0, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 4, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 1") {self.WHICHTIMER = "Timer 1", self.WHICHHWI = Timer_1.iHwi, self.REGS = 0x2400, self.TIMERNUM = 1, self.TIMERIMR = 0x45, self.TIMERIFR = 0x46, self.INTBIT = 6, self.TIMERIMRMASK = self.WHICHHWI.Ier1Mask, self.IMR0TINTMASK = 0x0, self.IMR1TINTMASK = self.WHICHHWI.Ier1Mask, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 2") {self.WHICHTIMER = "Timer 2", self.WHICHHWI = Timer_2.iHwi, self.REGS = 0x4000, self.TIMERNUM = 2, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 11, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} }}, "ok")
    prop setMicroseconds :: ($a = if FIXTDDR == 1 {self.TDDR} else {(if GBL.DSPSUBTYPE == 5502 {CLK_MAXTDDR5502} else {0})}, $b = if GBL.DSPSUBTYPE == 5502 {CLK_MAXREG5502} else {0xffffffff}, $c = (float($a) + 1.0) * ((float($b) + self.adjustPrd) / (GBL.CPUCLOCK / 8)), if ($1 < $c && $1 > 0.1) {if (self.FIXTDDR == 0) {self.TDDR = int((1.0 * $1 * GBL.CPUCLOCK / 8) / (float($b) + self.adjustPrd))} , self.PRD = int((1.0 * $1 * GBL.CPUCLOCK) / (8 * (self.TDDR + 1.0))) - self.adjustPrd, self.MICROSECONDS = ((float((self.PRD)) + CLK.adjustPrd) * ((self.TDDR) + 1.0) * 8 / GBL.CPUCLOCK), if (self.CALLBACKOBJ != nil) {self.CALLBACKOBJ.call()} , "ok"} else {self.error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")})
    prop call :: ($a = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 8 / GBL.CPUCLOCK), $b = CLK.MICROSECONDS, $e = "ok", if (($e = self.setMicroseconds(CLK.MICROSECONDS)) == "ok") {if (CLK.gGBLChain != nil) {$e = CLK.gGBLChain.call()} , if ($e != "ok") {self.setMicroseconds($b), self.error($e)} else {"ok"}} else {$e})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gGBLChain :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global WHICHHWI :: HWI_INT14 { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop Label :: "CPU Interrupt"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global INTBIT :: = self.WHICHHWI.iIntrEnableMask
    global WHICHTIMER :: "Timer 0" { 
        prop Label :: "Timer Selection"
        prop JSName :: "TIMERSELECT"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (self.WHICHTIMER != $1) {if (self.USETIMER == 0) {$e = "ok"} else {if ($1 == "Timer 0") {$a = Timer_0.iHwi} else {$a = Timer_1.iHwi}, $e = self.seizeHwi($a)}, if ($e == "ok") {self.releaseHwi(self.WHICHHWI), if ($1 == "Timer 0") {self.REGS = 0x01940000, self.TIMERNUM = 0, self.WHICHHWI = Timer_0.iHwi} else {self.REGS = 0x01980000, self.TIMERNUM = 1, self.WHICHHWI = Timer_1.iHwi}, self.WHICHTIMER = $1, self.HOOKFXN = if self.gNumOf > 0 {@HWI_F_dispatch} else {(if GBL.CALLMODEL == "far" {@CLK_F_frete} else {@CLK_F_rete})}, self.seizeHwi(self.WHICHHWI)} , $e} )
    }
    global REGS :: 26476544 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERNUM :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global USETIMER :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable CLK Manager"
        prop JSName :: "ENABLECLK"
        prop Visible :: 1
        prop Writable :: if self.gNumOf > 0 {0} else {1}
        prop NoGen :: 0
        prop Set :: (if ($1 == 1 && self.USETIMER == 0) {if (($e = self.seizeHwi(self.WHICHHWI)) == "ok") {self.USETIMER = 1, self.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}, self.HOOKFXN = if GBL.CALLMODEL == "far" {@CLK_F_frete} else {@CLK_F_rete}, self.seizeHwi(self.WHICHHWI), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, GlobalStatus.gDirty = 1, self.error("Current stack size inadequate to enable CLK")} else {if (GBL.ENABLEINST == 1) {IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE} , $e}} else {$e}} else {if ($1 == 0 && self.USETIMER == 1) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, if (GBL.ENABLEINST == 1) {IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0} , "ok"} else {"ok"}})
    }
    global HIRES :: = 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use high resolution time for internal timings"
        prop JSName :: "HIRESTIME"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (CLK.USETIMER) {CLK.HIRES = $1, if (CLK.USETIMER) {CLK.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}} , "ok"} else {self.error("CLK Manager must be enabled in order to get high resolution timings.")})
    }
    global INSTRPERCLK :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "Microseconds/Int"
        prop JSName :: "MICROSECONDS"
        prop Set :: (self.setMicroseconds($1))
        prop Visible :: 1
        prop Writable :: if ((CLK.PROGTIMREGS != 0) | (self.USETIMER == 0)) {0} else {1}
        prop NoGen :: 1
    }
    global PROGTIMREGS :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Directly configure on-chip timer registers"
        prop JSName :: "CONFIGURETIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global FIXTDDR :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Fix TDDR"
        prop JSName :: "FIXTDDR"
        prop Visible :: GBL.DSPTYPE != 62
        prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
        prop NoGen :: 1
    }
    global TDDR :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: if GBL.DSPSUBTYPE == 5502 {0x02} else {if GBL.DSPWORDSIZE == 16 {0x01 | 0x02} else {0x02}}
        prop Label :: if GBL.DSPSUBTYPE == 5561 {"TDDR Register (PREMD=0)"} else {"TDDR Register"}
        prop JSName :: "TCRTDDR"
        prop Set :: (if ((GBL.DSPSUBTYPE != 5502) && ($1 > 0)) {self.error("The on-chip timer does not have enough range to support this value, maximum is 15.")} else {CLK.TDDR = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 8 / GBL.CPUCLOCK), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok"})
        prop Visible :: GBL.DSPTYPE != 62
        prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
        prop NoGen :: 0
    }
    global TDDRHIGH :: = ((self.TDDR & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD :: 90000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: if GBL.DSPSUBTYPE == 5502 {0x02} else {if GBL.DSPWORDSIZE == 16 {0x01 | 0x02} else {0x02}}
        prop Label :: "PRD Register"
        prop JSName :: "PRD"
        prop Set :: (CLK.PRD = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 8 / GBL.CPUCLOCK), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok")
        prop Visible :: 1
        prop Writable :: if ((self.PROGTIMREGS) && (self.USETIMER)) {1} else {0}
        prop NoGen :: 0
    }
    global PRDHIGH :: = ((self.PRD & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global COUNTSPMS :: = int(round(GBL.CPUCLOCK * 1000.0 / (CLK.TDDR + 1) / 8)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global COUNTSPMSHIGH :: = ((self.COUNTSPMS & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global INSTRUCTIONS :: = (1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 8) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.0f"
        prop Label :: "Instructions/Int"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TIMEFXN :: = CLK.clkFxn() { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HOOKFXN :: @HWI_F_dispatch { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CLKFXN :: = (if GBL.DSPSUBTYPE == 5502 {@CLK_F_getBIOStime} else {if (CLK.PRD == 0xffffffff) {@CLK_F_getfhtime} else {@CLK_F_getshtime}}) { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: PRD { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (210)
    prop GlobalHelpTopic :: (110)
    prop InstancePropertyPage :: ("{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: ("%g ticks")
    prop STSGetSumFmt :: (PRD.STSGetMaxFmt())
    prop STSGetAvgFmt :: ("%.2f ticks")
    prop GetPeriod :: self.period
    prop IsOneShot :: if self.mode == "one-shot" {1} else {0}
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {\n%8t %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s%5s\0, name, objSize, memSeg, linkString, pageString")
    prop GenLinkEpilogue :: ("%0t}\n\0")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {""} else {if GBL.DSPTYPE == 28 {" PAGE 1 "} else {" PAGE 1"}}}
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {(8 * 4) * 2} else {(8 * 4)}
    prop dataSize :: ((8 * 4) * PRD.gNumOf)
    prop localInit :: (if (CLK.CALLBACKOBJ != nil) {self.error("PRD initialization failure")} , CLK.CALLBACKOBJ = PRD, if (PRD.USECLK && PRD_clock.iIsUsed == 0) {PRD_clock.Create("PRD")} , if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} else {PRD_clock.function = @PRD_F_tick}} )
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error(" System Stack Size too small")} else {self.myCreate("can")})
    prop localCreate :: (STS.gNumEmbed += 1, if (($a = self.myCreate("do")) == "ok") {if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {PRD_clock.function = @PRD_F_tick} } } , $a)
    prop localCanDelete :: (self.myDelete("can"))
    prop localDelete :: (STS.gNumEmbed -= 1, if (($a = self.myDelete("do")) == "ok") {if (self.gNumOf == 1) {if (PRD_clock.iIsUsed == 1) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} } } , $a)
    prop maxObjs :: (32767)
    prop myCreate :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (PRD_swi.iIsUsed) {"ok"} else {if (SWI.CanCreate() == "ok") {if ($1 == "do") {if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {PRD_swi.pri = 1} , PRD_swi.Create("PRD")} else {"ok"}} else {self.error("Can't create an SWI for PRD (try deleting a SWI)")}})
    prop myDelete :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (self.gNumOf == 1) {if ($1 == "do") {PRD_swi.Delete("PRD")} else {"ok"}} else {"ok"})
    prop call :: (if (CLK.USETIMER != 0) {PRD.MICROSECONDS = CLK.MICROSECONDS} , PRD.CALLBACKOBJ.call())
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"prd.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PRD_Obj %0r;\n\0"} else {"extern PRD_Obj %0r;\n\0"})
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop DEFAULT_THOOKFXN :: @_KNL_tick
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USECLK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use CLK Manager to drive PRD"
        prop JSName :: "USECLK"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 1 && self.USECLK == 0) {if (CLK.USETIMER == 0) {self.error("In order to drive periodic functions, the CLK Manager must be enabled")} else {self.USECLK = 1, self.MICROSECONDS = CLK.MICROSECONDS, CLK.CALLBACKOBJ = PRD, PRD_clock.Create("PRD"), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD"), self.error("Current Stack size inadequate to enable this option")} else {"ok"}}} else {if ($1 == 0 && self.USECLK == 1) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD")} , "ok"})
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Label :: "Microseconds/Tick"
        prop JSName :: "MICROSECONDS"
        prop Visible :: 1
        prop Writable :: self.USECLK == 0
        prop NoGen :: 1
    }
    global SCALAR :: = ($d = 2, $f = 0, while ($d <= 0x4000 && $f == 0) {scan ($i; PRD) {if (($i.period / $d) * $d != $i.period) {$f = 1} }, if ($f == 0) {$d = 2 * $d} }, $d / 2) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global THOOKFXN :: @_KNL_tick { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "System Tick Hook Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALLBACKOBJ :: STS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst period :: 0xffff { 
        prop Label :: "period (ticks)"
        prop JSName :: "period"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 > 0) {self.period = $1, self.gDirty = 1, "ok"} else {self.error("Periodic function periods must be greater than 0")})
    }
    inst mode :: "continuous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "continuous,one-shot"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst milliseconds :: = ((self.period * PRD.MICROSECONDS) / 1000.0) { 
        prop Label :: "period (ms)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object PRD_swi :: SWI {
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted when all PRD objects are deleted"
    param function :: @PRD_F_swi
    param pri :: 1
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 1
}

object PRD_clock :: CLK {
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    param function :: @PRD_F_tick
    param Order :: 1
    param iPri :: 0
}

type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: self.USERTDX
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (113)
    prop InstanceHelpTopic :: (213)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop AllocType :: (if self.USERTDX {"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"} else {""})
    prop _rtdxDataAllocDesc :: (" .%1L_data: {} \0, name")
    prop _rtdxTextAllocDesc :: (if (MEM.ENABLELOADSEG == 1) {if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {" .%1L_text: {} \0, name"} else {" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"}} else {" .%1L_text: {} \0, name"})
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (if self.USERTDX {"_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"} else {""})
    prop _interruptMask :: RTDX.MASK
    prop cGen :: 1
    prop noObjectAlias :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"rtdx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {if (self.iChannelMode == "output") {"extern far RTDX_outputChannel %0r;\n\0"} else {"extern far RTDX_inputChannel %0r;\n\0"}} else {if (self.iChannelMode == "output") {"extern RTDX_outputChannel %0r;\n\0"} else {"extern RTDX_inputChannel %0r;\n\0"}})
    prop cGenCInst :: (if (self.iChannelMode == "output") {"RTDX_CreateOutputChannel(%0r);\n\0"} else {"RTDX_CreateInputChannel(%0r);\n\0"})
    prop dataSize :: ($d = 0, if (self.USERTDX) {$d = RTDX.BUFMEMSIZE} else {$d = 0}, scan ($a; RTDX) {if ($a.iChannelMode == "output") {$d += 1} else {$d += 3}}, $d)
    prop localCanCreate :: ($e = "ok", if (RTDX.USERTDX != 1) {$e = self.error("RTDX manager not enabled")} , $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USERTDX :: = 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Data Exchange (RTDX)"
        prop JSName :: "ENABLERTDX"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {if (HST.LNKTYPE == "RTDX") {self.error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX")} else {if (self.gNumOf > 0) {self.error("Cannot disable RTDX until all RTDX objects are deleted.")} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"}}} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"})
    }
    global USERTEXECUTION :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Execution Control"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "JTAG,HSRTDX,Simulator"
        prop Label :: "RTDX Mode"
        prop JSName :: "MODE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.RTDXTYPE = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok")
    }
    global DATAMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "RTDX Data Segment (.rtdx_data)"
        prop JSName :: "RTDXDATASEG"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
    }
    global BUFMEMSIZE :: = (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "RTDX Buffer Size (MAUs)"
        prop JSName :: "BUFSIZE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (if (HST.RTDX == 0) {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, "ok"} else {if ($1 < (HST.MAXFRAMESET + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {self.error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 2) * (MAUs per word)")} else {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, if (HST.LNKTYPE == "RTDX") {HST.MAXFRAMEALLOWED = (self.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, "ok"} else {"ok"}}})
    }
    global TEXTMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop Visible :: 0
        prop Writable :: self.USERTDX
        prop NoGen :: 1
    }
    global MASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Label :: "RTDX Interrupt Mask"
        prop JSName :: "INTERRUPTMASK"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.MASK = $1, "ok")
    }
    global CALLBACKOBJ :: HWI { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iChannelMode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Channel Mode"
        prop JSName :: "channelMode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.iChannelMode = $1, "ok")
    }
}

type HST {
    isa ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (104)
    prop InstanceHelpTopic :: (204)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop dataSize :: ($b = 0, scan ($i; HST) {if ($i.IsConfObj()) {$b += (12 + $i.framesize) * $i.numframes + 100 + (5 * 4)} }, $b)
    prop InstancePropertyPage :: ("{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}")
    prop DependsOn :: "HWI"
    prop localCreate :: (PIP.gNumEmbed += 1, if (self.gNumOf == 0) {(LNK_dataPump.Create("HST"))} , "ok")
    prop localDelete :: (PIP.gNumEmbed -= 1, $b = 0, scan ($i; HST) {if ($i != self) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } } }, self.MAXFRAMESET = $b, if (self.gNumOf == 1) {(LNK_dataPump.Delete("HST"))} , "ok")
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, \
	      _dsmAllocDesc, _dsmMemSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop _dsmAllocDesc :: ("%8t .dsm: {}")
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: ("/* %0s buffer */\n.hst%2d: %3S\0, name, _objId, _alignString, _objAlign")
    prop _alignString :: if self.bufalign > 1 {"align = 0x%4x {}"} else {""}
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: (5 * 4)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"hst.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far HST_Obj %0r;\n\0"} else {"extern HST_Obj %0r;\n\0"})
    prop modifiable :: ((if self.iDelUser == "USER" {1} else {0}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LNKTYPE :: "RTDX" { 
        prop Label :: "Host Link Type"
        prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 == "RTDX") {if (RTDX.USERTDX == 0) {self.error("RTDX module must be enabled before it can be used by HST")} else {if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < self.MAXFRAMESET) {self.error("RTDX buffer size too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, "ok"}}}} else {if ($1 == "Shared Memory") {if ((self.DSMMEMSIZE / 4) < self.MAXFRAMESET) {self.error("Shared memory buffer too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"}}} else {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, "ok"}})
    }
    global RTDX :: = if self.LNKTYPE == "RTDX" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM :: = if self.LNKTYPE == "Shared Memory" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 :: = if self.LNKTYPE == "EVM54" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE :: = if self.LNKTYPE == "NONE" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET :: = ($b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED :: = if self.RTDX == 1 {(RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2} else {self.DSMMEMSIZE / 4} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
    }
    global DSMMEMSIZE :: = 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
        prop Set :: (if ($1 < HST.MAXFRAMESET * 4) {self.error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")} else {self.DSMMEMSIZE = $1, GlobalStatus.gDirty = 1, if (self.LNKTYPE == "Shared Memory") {self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {"ok"}})
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst mode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "mode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst bufalign :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("Alignment must be greater than or equal to 4")} else {if (($1 % 2) != 0) {self.error("Alignment must be a power of 2")} else {$i = $1, while ((($i % 2) == 0) && ($i != 2)) {$i = $i / 2}, if (($i % 2) != 0) {self.error("Alignment must be a power of 2")} else {self.bufalign = $1, "ok"}}})
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {if (($1 > self.MAXFRAMEALLOWED) && ((self.RTDX == 1) || (self.DSM == 1))) {if (self.RTDX == 1) {self.error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 2")} else {self.error("size (in words) is limited to: shared memory frame size (in MAUs)/4")}} else {self.framesize = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, GlobalStatus.gDirty = 1, "ok"}})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Channels must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst stsflg :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "statistics"
        prop JSName :: "statistics"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst lnk :: = if self.RTDX {"RTDX"} else {"NOTRTDX"} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "link type"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Make this channel available for a new DHL device"
        prop JSName :: "availableForDHL"
        prop Set :: (if (($1 == 0) && (self.iDHLAvailable == 1)) {DHL.gChannelsAvailable--} else {if (($1 == 1) && (self.iDHLAvailable == 0)) {DHL.gChannelsAvailable++} }, self.iDHLAvailable = $1, "ok")
        prop Writable :: self.modifiable()
        prop Visible :: 1
        prop NoGen :: 1
    }
    inst bufFrameAlign :: = self.bufalign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object LNK_dataPump :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @LNK_F_dataPump
    param cycles :: 0
    param calibration :: 1
    param Order :: 1
    param iPri :: 0
}

object RTA_dispatcher :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @RTA_F_dispatch
    param cycles :: 0
    param calibration :: 1
    param Order :: 2
    param iPri :: 0
}

object RTA_fromHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "input"
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 4
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

object RTA_toHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "output"
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 64
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

type HWI {
    isa ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (205)
    prop GlobalHelpTopic :: (105)
    prop dataSize :: (0 * HWI.gNumOf)
    prop localCanCreate :: (self.error("New hardware interrupt objects cannot be created"))
    prop InstancePropertyPage :: ("{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "GBL,OBJ,CLK,IDL,LCK,LOG,MBX,MEM,PIP,PRD,QUE,RTDX,SEM,STS,SYS"
    prop AllocType :: (if self.ZEROTAB {"1\0,	_stubsAllocDesc,	_memSeg,	_placement"} else {if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"2\0,	_stubsAllocDesc,	_memSeg,	_placement,
	   		_vectAllocDesc,		_loadvecSeg,	_minplace"} else {"2\0,	_stubsAllocDesc,	_memSeg,	_placement,
			_vectAllocDesc,		_vecSeg,	_minplace"}})
    prop _stubsAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {"%8t .%1L: {} load > %2s, run\0, name, _loadstubSeg"} else {"%8t .%1L: {} \0, name"})
    prop _vectAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"%8t .%1L_vec: {%12t\n %1U_A_VECS = .;\n *(.hwi_vec)%8t\n } run > %2s align = 0x400, load \0, name, _vecSeg"} else {"%8t .%1L_vec: {%12t\n %1U_A_VECS = .;\n *(.hwi_vec)%8t\n } align = 0x400\0, name"})
    prop _placement :: (0x7fffffff / 2)
    prop _minplace :: 0
    prop GenLinkPrologue :: (if self.ZEROTAB {if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"SECTIONS {%4t\n .%1L_vec: {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }  load >  %2s, run = 0x0 %0t\n}\n\0 , name, _loadvecSeg"} else {"SECTIONS {%4t\n .%1L_vec: 0x0 {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }%0t\n}\n\0, name"}} else {if self.GENERATE_RESET_VEC {"SECTIONS {%4t\n .%1L_reset: 0x0 {}%0t\n}\n\0, name"} else {""}})
    prop localInit :: (if (RTDX.CALLBACKOBJ != nil) {self.error("HWI initialization failure.")} , RTDX.CALLBACKOBJ = HWI)
    prop call :: (if (RTDX.USERTDX == 0) {HWI_RESERVED1.function = @HWI_unused, HWI_RESERVED1.iUseDispatcher = 0, if (HWI_INT9.iSource == JTAGRTDX9 && HWI_INT9.function == @_RTDX_Poll) {HWI_INT9.iSource = MCSP_0_Transmit, HWI_INT9.iReMappable = 1, HWI_INT9.function = @HWI_unused, HWI_INT9.iUseDispatcher = 0, HWI_INT9.iIntrMask = "self", HWI_INT9.IntrMask = 0x200, HWI_INT9.client = "USER"} , if (HWI_INT11.iSource == HSRTDX11 && HWI_INT11.function == @_HSRTDX_xmt) {HWI_INT11.iSource = MCSP_0_Receive, HWI_INT11.iReMappable = 1, HWI_INT11.function = @HWI_unused, HWI_INT11.iUseDispatcher = 0, HWI_INT11.iIntrMask = "self", HWI_INT11.IntrMask = 0x800, HWI_INT11.client = "USER"} , if (HWI_INT12.iSource == HSRTDX12 && HWI_INT12.function == @_HSRTDX_rec) {HWI_INT12.iSource = MCSP_1_Transmit, HWI_INT12.iReMappable = 1, HWI_INT12.function = @HWI_unused, HWI_INT12.iUseDispatcher = 0, HWI_INT12.iIntrMask = "self", HWI_INT12.IntrMask = 0x1000, HWI_INT12.client = "USER"} } else {HWI_RESERVED1.function = @_RTDX_Poll, HWI_RESERVED1.iUseDispatcher = 1, if (RTDX.RTDXTYPE == "HSRTDX") {if (HWI_INT9.iSource == JTAGRTDX9 && HWI_INT9.function == @_RTDX_Poll) {HWI_INT9.iSource = MCSP_0_Transmit, HWI_INT9.iReMappable = 1, HWI_INT9.function = @HWI_unused, HWI_INT9.iUseDispatcher = 0, HWI_INT9.iIntrMask = "self", HWI_INT9.IntrMask = 0x200, HWI_INT9.client = "USER"} , HWI_INT11.iSource = HSRTDX11, HWI_INT11.iReMappable = 0, HWI_INT11.function = @_HSRTDX_xmt, HWI_INT11.iUseDispatcher = 1, HWI_INT11.iIntrMask = "bitmask", HWI_INT11.IntrMask = 0x1808, HWI_INT11.client = "RTDX", HWI_INT12.iSource = HSRTDX12, HWI_INT12.iReMappable = 0, HWI_INT12.function = @_HSRTDX_rec, HWI_INT12.iUseDispatcher = 1, HWI_INT12.iIntrMask = "bitmask", HWI_INT12.IntrMask = 0x1808, HWI_INT12.client = "RTDX"} else {HWI_INT9.iSource = JTAGRTDX9, HWI_INT9.iReMappable = 0, HWI_INT9.function = @_RTDX_Poll, HWI_INT9.iUseDispatcher = 1, HWI_INT9.iIntrMask = "self", HWI_INT9.IntrMask = 0x208, HWI_INT9.client = "RTDX", if (HWI_INT11.iSource == HSRTDX11 && HWI_INT11.function == @_HSRTDX_xmt) {HWI_INT11.iSource = MCSP_0_Receive, HWI_INT11.iReMappable = 1, HWI_INT11.function = @HWI_unused, HWI_INT11.iUseDispatcher = 0, HWI_INT11.iIntrMask = "self", HWI_INT11.IntrMask = 0x800, HWI_INT11.client = "USER"} , if (HWI_INT12.iSource == HSRTDX12 && HWI_INT12.function == @_HSRTDX_rec) {HWI_INT12.iSource = MCSP_1_Transmit, HWI_INT12.iReMappable = 1, HWI_INT12.function = @HWI_unused, HWI_INT12.iUseDispatcher = 0, HWI_INT12.iIntrMask = "self", HWI_INT12.IntrMask = 0x1000, HWI_INT12.client = "USER"} }})
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: ($b = 0, scan ($a; HWI) {if ($a.monitor != "Nothing") {$b = 1} }, if ($b == 1) {"*(.hwi)"} else {"/* no HWI stubs are necessary */"})
    prop name2addr :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "Stack Pointer", "Top of SW Stack", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15"}) {if ($b == nil) {if ($a == $1) {$b = {0, 0, 0, @GBL_stackbeg, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}[$i]} , $i++} }, if ($b == nil) {$b = 0} , $b)
    prop name2type :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "Stack Pointer", "Top of SW Stack", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15"}) {if ($b == nil) {if ($a == $1) {if ($i < 5) {$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]} } , $i++} }, if ($b == nil) {$b = "unsigned"} , $b)
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 65535 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 16 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STUBMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ZEROTAB :: = MEM.VECMEMSEG.base == 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    global VECMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: MEM.codeMember($1)
        prop Set :: (self.VECMEMSEG = $1, if ($1.base == 0) {self.GENERATE_RESET_VEC = 0} , "ok")
    }
    global GENERATE_RESET_VEC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate RESET vector at address 0 "
        prop JSName :: "RESETVECTOR"
        prop Writable :: self.ZEROTAB == 0
        prop Visible :: 1
        prop NoGen :: 0
    }
    global EXT4_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 4 Polarity"
        prop JSName :: "EXTPIN4POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT5_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 5 Polarity"
        prop JSName :: "EXTPIN5POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT6_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 6 Polarity"
        prop JSName :: "EXTPIN6POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT7_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 7 Polarity"
        prop JSName :: "EXTPIN7POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global POLARITYMASK :: = (if self.EXT4_POLARITY == "high-to-low" {1} else {0}) | (if self.EXT5_POLARITY == "high-to-low" {1} else {0}) << 1 | (if self.EXT6_POLARITY == "high-to-low" {1} else {0}) << 2 | (if self.EXT7_POLARITY == "high-to-low" {1} else {0}) << 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global INTRMULTLOW :: = (HWI_INT4.iSource.iIntrSelectNum) | (HWI_INT5.iSource.iIntrSelectNum << 5) | (HWI_INT6.iSource.iIntrSelectNum << 10) | (HWI_INT7.iSource.iIntrSelectNum << 16) | (HWI_INT8.iSource.iIntrSelectNum << 21) | (HWI_INT9.iSource.iIntrSelectNum << 26) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global INTRMULTHIGH :: = (HWI_INT10.iSource.iIntrSelectNum) | (HWI_INT11.iSource.iIntrSelectNum << 5) | (HWI_INT12.iSource.iIntrSelectNum << 10) | (HWI_INT13.iSource.iIntrSelectNum << 16) | (HWI_INT14.iSource.iIntrSelectNum << 21) | (HWI_INT15.iSource.iIntrSelectNum << 26) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iSource :: Reset { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: ISRC
        prop MemberTest :: 1
        prop Label :: "interrupt source"
        prop JSName :: "interruptSource"
        prop Visible :: 1
        prop Writable :: self.iReMappable
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a == Reset) {self.error("The Reset interrupt source cannot be remapped")} else {if ($a == Non_Maskable) {self.error("The Non-Maskable interrupt source cannot be remapped")} else {if ($a == Reserved) {self.error("The Reserved interrupt source cannot be remapped")} else {if (CLK.WHICHHWI == self && $a != self.iSource && CLK.USETIMER) {self.error("This interrupt is in use by CLK, settings may be changed in the CLK Manager")} else {if ($a == CLK.WHICHHWI.iSource && CLK.USETIMER == 1) {self.error("Interrupt source is in use by CLK, settings may be changed in the CLK Manager.")} else {$a.iHwi = self, self.iSource.iHwi = HWI_UNUSED, self.iSource = $1, "ok"}}}}})
    }
    inst iReMappable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIntrEnableMask :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @HWI_unused { 
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if ((self.function == @RESERVED) || (self.client != "USER")) {0} else {1}
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (self.function = $1, GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTSObj :: HWI_RESETSTS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst monitor :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,Stack Pointer,Top of SW Stack,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((self.function != @HWI_unused && self.function != @RESERVED) && (self.iId != 0))
        prop NoGen :: 0
        prop Set :: (if ($1 != self.monitor) {$e = "ok", if ($1 == "Nothing") {if (($e = self.iSTSObj.Delete("HWI")) == "ok") {self.monitor = "Nothing", self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)} } else {if (self.iSTSObj.iIsUsed || ($e = self.iSTSObj.Create("HWI")) == "ok") {self.monitor = $1, if (self.monitor == "Data Value") {self.addr = self.saveAddr, self.dataType = self.saveType} else {self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)}} else {self.monitor = "Nothing"}}, $e} else {"ok"})
    }
    inst saveAddr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst saveType :: "signed" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst addr :: 0 { 
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Data Value" {1} else {0})
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Set :: (self.addr = $1, self.saveAddr = $1, "ok")
    }
    inst dataType :: "signed" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (if (self.monitor != "Nothing") {self.dataType = $1, self.saveType = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst operation :: "STS_add(*addr)" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (if (self.monitor != "Nothing") {self.operation = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst client :: "USER" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: if (self.client == "USER") {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if (self == HWI_NMI) {self.error("HWI dispatcher can't be used for  NMI")} else {self.iUseDispatcher = $1, "ok"})
    }
    inst iArg :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.client == "USER")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (self.iArg = $1, "ok")
    }
    inst iIntrMask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask"
        prop JSName :: "interruptMask"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.IntrMask = 0xffff} else {if ($1 == "self") {self.IntrMask = 1 << self.iId} else {if ($1 == "none") {self.IntrMask = 0} }}, self.iIntrMask = $1, "ok")
    }
    inst IntrMask :: (1 << self.iId) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask"
        prop JSName :: "interruptBitMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIntrMask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.IntrMask = $1, "ok"})
    }
    inst iCacheControl :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't modify cache control"
        prop JSName :: "cacheControl"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == 1) {self.iCCBitMask = 0x1} else {self.iCCBitMask = (self.iPCCBitMask | self.iDCCBitMask)}, self.iCacheControl = $1, "ok")
    }
    inst iPCCMask :: (if (GBL.DSPSUBTYPE == 6200 || GBL.DSPSUBTYPE == 6700) {"mapped"} else {"cache enable"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Program Cache Control Mask"
        prop JSName :: "progCacheMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400) && $1 != "cache enable") {self.error("unsupported cache mode for 6x1x/64x device (cache enable must be selected)")} else {if ($1 == "mapped") {self.iPCCBitMask = 0x0000} else {if ($1 == "cache enable") {self.iPCCBitMask = 0x0040} else {if ($1 == "cache freeze") {self.iPCCBitMask = 0x0060} else {self.iPCCBitMask = 0x0080}}}, self.iPCCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask, "ok"})
    }
    inst iPCCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDCCMask :: (if (GBL.DSPSUBTYPE == 6200 || GBL.DSPSUBTYPE == 6700) {"mapped"} else {"cache enable"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Data Cache Control Mask"
        prop JSName :: "dataCacheMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400) && $1 != "cache enable") {self.error("unsupported cache mode for 6x1x/64x device (cache enable must be selected)")} else {if ($1 == "mapped") {self.iDCCBitMask = 0x0000} else {if ($1 == "cache enable") {self.iDCCBitMask = 0x0008} else {if ($1 == "cache freeze") {self.iDCCBitMask = 0x000C} else {self.iDCCBitMask = 0x0010}}}, self.iDCCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask, "ok"})
    }
    inst iDCCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCCBitMask :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reset
    param iReMappable :: 0
    param iIntrEnableMask :: 1
    param function :: @_c_int00
    param iSTSObj :: HWI_RESET_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 1
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Non_Maskable
    param iReMappable :: 0
    param iIntrEnableMask :: 2
    param function :: @HWI_unused
    param iSTSObj :: HWI_NMI_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 2
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_RESERVED0_STS :: STS {
    param iComment :: "This STS object is being used by a HWI object and cannot be deleted"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESERVED0 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iIsUsed :: 1
    param iId :: 2
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reserved
    param iReMappable :: 0
    param iIntrEnableMask :: 4
    param function :: @RESERVED
    param iSTSObj :: HWI_RESERVED0_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 4
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_RESERVED1_STS :: STS {
    param iComment :: "This STS object is being used by a HWI object and cannot be deleted"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESERVED1 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iIsUsed :: 1
    param iId :: 3
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reserved
    param iReMappable :: 0
    param iIntrEnableMask :: 8
    param function :: @_RTDX_Poll
    param iSTSObj :: HWI_RESERVED1_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 8
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iIsUsed :: 1
    param iId :: 4
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_4
    param iReMappable :: 1
    param iIntrEnableMask :: 16
    param function :: @_External_Interrupt4
    param iSTSObj :: HWI_INT4_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 16
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iIsUsed :: 1
    param iId :: 5
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_5
    param iReMappable :: 1
    param iIntrEnableMask :: 32
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT5_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 32
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT6_STS :: STS {
    param iComment :: "provides statistics for the INT6 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iIsUsed :: 1
    param iId :: 6
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_6
    param iReMappable :: 1
    param iIntrEnableMask :: 64
    param function :: @_External_Interrupt6
    param iSTSObj :: HWI_INT6_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 64
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iIsUsed :: 1
    param iId :: 7
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_7
    param iReMappable :: 1
    param iIntrEnableMask :: 128
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT7_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 128
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iIsUsed :: 1
    param iId :: 8
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: EDMA_Controller
    param iReMappable :: 1
    param iIntrEnableMask :: 256
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT8_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 256
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT9 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT9 :: HWI {
    param iComment :: "defines the INT9 Interrupt"
    param iIsUsed :: 1
    param iId :: 9
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: JTAGRTDX9
    param iReMappable :: 0
    param iIntrEnableMask :: 520
    param function :: @_RTDX_Poll
    param iSTSObj :: HWI_INT9_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 512
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iIsUsed :: 1
    param iId :: 10
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: EMIF_SDRAM_Timer
    param iReMappable :: 1
    param iIntrEnableMask :: 1024
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT10_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 1024
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iIsUsed :: 1
    param iId :: 11
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: MCSP_0_Receive
    param iReMappable :: 1
    param iIntrEnableMask :: 2048
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT11_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 2048
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iIsUsed :: 1
    param iId :: 12
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: MCSP_1_Transmit
    param iReMappable :: 1
    param iIntrEnableMask :: 4096
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT12_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 4096
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iIsUsed :: 1
    param iId :: 13
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Host_Port_Host_to_DSP
    param iReMappable :: 1
    param iIntrEnableMask :: 8192
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT13_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 8192
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iIsUsed :: 1
    param iId :: 14
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Timer_0
    param iReMappable :: 1
    param iIntrEnableMask :: 16384
    param function :: @CLK_F_isr
    param iSTSObj :: HWI_INT14_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "CLK"
    param iUseDispatcher :: 1
    param iArg :: @CLK_A_TABBEG
    param iIntrMask :: "self"
    param IntrMask :: 16384
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param iIsUsed :: 1
    param iId :: 15
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Timer_1
    param iReMappable :: 1
    param iIntrEnableMask :: 32768
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT15_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 32768
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

object HWI_UNUSED :: HWI {
    param iComment :: "a dummy DSP interrupt for unused sources"
    param iIsUsed :: 0
    param iId :: 16
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reset
    param iReMappable :: 1
    param iIntrEnableMask :: 0
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT15_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 65536
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
}

type SWI {
    isa ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (211)
    prop GlobalHelpTopic :: (111)
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop STSGetMaxFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (SWI.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMax :: ($a = if (CLK.HIRES) {$1 * CLK.INSTRPERCLK} else {$1}, $a = $a * (CLK.TDDR + 1), $a)
    prop STSFilterSum :: (SWI.STSFilterMax($1))
    prop GetPriority :: (self.pri)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;%4t\n} > %3s%5s\0, name, objSize, memSeg, linkString, pageString")
    prop GenLinkEpilogue :: ("%0t}\n\0")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {""} else {" PAGE 1"}}
    prop memSeg :: SWI.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {(2 * (11 * 4))} else {(11 * 4)}
    prop maxObjs :: (32767)
    prop dataSize :: ((11 * 4) * SWI.gNumOf)
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {"ok"})
    prop localCreate :: (STS.gNumEmbed += 1, SWI.EXECFXN = @SWI_F_iexec, SWI.RUNFXN = @SWI_F_run, "ok")
    prop localDelete :: (STS.gNumEmbed -= 1, if (self.gNumOf == 1) {SWI.EXECFXN = @FXN_F_nop, SWI.RUNFXN = @FXN_F_nop} , "ok")
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: ("{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "HWI,SIO"
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"swi.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SWI_Obj %0r;\n\0"} else {"extern SWI_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global EHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXECFXN :: @SWI_F_iexec { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RUNFXN :: @SWI_F_run { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive body"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst priority :: = (self.pri + 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst pri :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
        prop Label :: "priority"
        prop JSName :: "priority"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ($a = self.pri, self.pri = $1, if (self == KNL_swi) {if ($1 != 0) {self.pri = $a, self.error("KNL_swi must remain at Priority 0.")} else {"ok"}} else {if ($1 == 0 && KNL_swi.iIsUsed == 1) {self.pri = $a, self.error("Priority 0 reserved for KNL_swi only.")} else {GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.pri = $a, self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {if ($1 > 14) {self.pri = $a, self.error("SWI can only support 15 priority levels.")} else {"ok"}}}})
    }
    inst mailbox :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mailbox"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst dorta :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
}

type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: self.USETSK
    prop IsContainedIn :: SCH
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (314)
    prop InstanceHelpTopic :: (414)
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A65-B1A8-11d0-9885-0020AFEE33C6}")
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop AllocType :: (if (self.USETSK) {"1\0,    _bssAllocDesc, _bssmemSeg, _placement"} else {""})
    prop _objAllocDesc :: ("%8t .TSK$obj: {}")
    prop _bssAllocDesc :: ("%8t .tsk: {%12t\n *(.tsk)%8t\n }")
    prop _bssmemSeg :: self.OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG
    prop AllocInst :: (if self.iAUTOSTK {"1\0, _instStackDesc, _instStackSeg, _placement"} else {"0\0"})
    prop _instStackDesc :: (if (GBL.DSPTYPE == 40) {"%8t .%0s$stk: fill = 0xC0FFEE {%12t\n %0s$stack = .;\n . += %1d;%8t\n }\0, _instStackSize"} else {"%8t .%0s$stk: {%12t\n *(.%0s$stk)%8t\n }\0"})
    prop _self :: self
    prop _instStackSize :: self.iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: self.iSTKSEG
    prop _placement :: (0x7fffffff / 2)
    prop localInit :: (KNL_swi.Create("SWI"), if (self.STACKSEG.iAllocHeap == 1) {self.STACKSEG.iReqHeapCount++, "ok"} else {self.error("TSK default stack segment must be a memory segment with a heap")})
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop STSGetMaxFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (TSK.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMax :: ($a = if (CLK.HIRES) {$1 * CLK.INSTRPERCLK} else {$1}, $a = $a * (CLK.TDDR + 1), $a)
    prop STSFilterSum :: (TSK.STSFilterMax($1))
    prop localCreate :: (STS.gNumEmbed += 1, "ok")
    prop localCanCreate :: ($e = "ok", if (TSK.USETSK != 1) {$e = self.error("TSK manager not enabled")} , $e)
    prop localDelete :: (STS.gNumEmbed -= 1, "ok")
    prop GenLinkPrologue :: (if (self.USETSK == 0) {"_KNL_swi = 0;"} )
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"tsk.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far TSK_Obj %0r;\n\0"} else {"extern TSK_Obj %0r;\n\0"})
    prop _objId :: self.iId
    prop dataSize :: ($d = 0, scan ($i; TSK) {$d += ($i.iSTKSZ + (3 + 21) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))}, $d)
    prop minStackSize :: ($a = self.STACKSIZE, scan ($i; TSK) {if ($i.STACKSIZE < $a) {$a = $i.STACKSIZE} }, $a)
    prop maxObjs :: (32767)
    prop GetPriority :: (self.iPRI)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 9 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USETSK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable TSK Manager"
        prop JSName :: "ENABLETSK"
        prop Visible :: 1
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop NoGen :: 1
        prop Set :: (if ($1 == 0) {if (self.gNumOf > 1) {self.error("Cannot disable TSK until all TSK objects are deleted.")} else {self.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, TSK.OBJMEMSEG = MEM_NULL, TSK_idle.iSTKSEG = MEM_NULL, TSK_idle.Delete("TSK"), KNL_swi.Delete("TSK"), PRD.THOOKFXN = @FXN_F_nop, if (PRD.gNumOf == 0) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @FXN_F_nop} } , self.USETSK = $1, "ok"}} else {$e = "ok", GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {$e = self.error("Current stack size inadequate to enable TSK"), break} , scan ($a; SWI) {if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {$e = self.error("Cannot enable TSK when there are SWI objects at Priority 0."), break} }, if ($e == "ok") {TSK.STACKSEG = MEM_NULL, scan ($b; MEM) {if ($b.iAllocHeap && $b != MEM_NULL) {TSK.STACKSEG = $b, break} }, self.STACKSEG.iReqHeapCount++, self.USETSK = $1, TSK.OBJMEMSEG = SWI.OBJMEMSEG, TSK_idle.iSTKSEG = self.OBJMEMSEG, TSK_idle.Create("TSK"), KNL_swi.Create("TSK"), PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (TSK.TSKTICK == "PRD") {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @PRD_F_tick} } , if (MEM.NOHEAPS) {self.STACKSEG.iReqHeapCount++, $e = "No Memory Heaps Are Allocated for Dynamic TSK creation"} , $e} else {$e}})
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "OBJMEMSEG"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Default stack size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global STACKSEG :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
        prop Label :: "Stack segment for dynamic tasks"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: self.USETSK && (MEM.NOHEAPS == 0)
        prop Set :: (if (self.STACKSEG.iReqHeapCount > 0) {self.STACKSEG.iReqHeapCount--} , self.STACKSEG = $1, self.STACKSEG.iReqHeapCount++, "ok")
    }
    global PRIORITY :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "PRIORITY"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Label :: "Default task priority"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global CREATEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.CREATEFXN = $1, HOOK_KNL.createFxn = self.CREATEFXN, "ok")
        prop NoGen :: 1
    }
    global VCREATEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doCreate} else {self.CREATEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.DELETEFXN = $1, HOOK_KNL.deleteFxn = self.DELETEFXN, "ok")
        prop NoGen :: 1
    }
    global VDELETEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doDelete} else {self.DELETEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.EXITFXN = $1, HOOK_KNL.exitFxn = self.EXITFXN, "ok")
        prop NoGen :: 1
    }
    global VEXITFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doExit} else {self.EXITFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DOSWITCH :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "CALLSWITCHFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOSWITCH = $1, HOOK_KNL.callSwitchFxn = self.DOSWITCH, "ok")
        prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "SWITCHFXN"
        prop Visible :: 1
        prop NoGen :: 1
        prop Writable :: self.DOSWITCH && self.USETSK
        prop Set :: (self.VSWFXN = $1, HOOK_KNL.switchFxn = self.VSWFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global SWITCHFXN :: = if self.DOSWITCH {(if HOOK_KNL.iIsUsed == 1 {@__HOOK_doSwitch} else {self.VSWFXN})} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "CALLREADYFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOREADY = $1, HOOK_KNL.callReadyFxn = self.DOREADY, "ok")
        prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "READYFXN"
        prop Visible :: 1
        prop Writable :: self.DOREADY && self.USETSK
        prop NoGen :: 1
        prop Set :: (self.VRDYFXN = $1, HOOK_KNL.readyFxn = self.VRDYFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global READYFXN :: = if self.DOREADY {(if HOOK_KNL.iIsUsed == 1 {@__HOOK_doReady} else {self.VRDYFXN})} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS :: = HOOK.gNumOf { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global TSKTICK :: "PRD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "PRD,User"
        prop Label :: "TSK tick driven by"
        prop JSName :: "DRIVETSKTICK"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
        prop Set :: (if ($1 != self.TSKTICK) {if ($1 == "PRD") {PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (TSK.USETSK == 1) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @PRD_F_tick} } } , if ($1 == "User") {PRD.THOOKFXN = @_FXN_F_nop, if (PRD.gNumOf == 0) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @FXN_F_nop} } } , if ($1 != "PRD" && $1 != "User") {self.error("Invalid TSK tick driver selection")} } , self.TSKTICK = $1, "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Task function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG2 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 2"
        prop JSName :: "arg2"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG3 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 3"
        prop JSName :: "arg3"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG4 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 4"
        prop JSName :: "arg4"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG5 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 5"
        prop JSName :: "arg5"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG6 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 6"
        prop JSName :: "arg6"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG7 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 7"
        prop JSName :: "arg7"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iAUTOSTK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Automatically allocate stack"
        prop JSName :: "autoAllocateStack"
        prop Set :: (if (($1 == 1) && (self.iAUTOSTK == 0)) {self.iSTKSZ = TSK.STACKSIZE} , self.iAUTOSTK = $1, "ok")
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
    }
    inst iMANSTK :: @null { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Manually allocated stack"
        prop JSName :: "manualStack"
        prop Visible :: 1
        prop Writable :: self.iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Stack size (MAUs)"
        prop JSName :: "stackSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = $1, if ($a < 32) {if (GBL.DSPSUBTYPE == 62) {self.error("Task stack size is too small.")} else {if ($a < 32) {self.error("Task stack size is too small.")} else {self.iSTKSZ = ($1 - ($1 - 1) % 8 + 7), GlobalStatus.gDirty = 1, "ok"}}} else {self.iSTKSZ = ($1 - ($1 - 1) % 8 + 7), GlobalStatus.gDirty = 1, "ok"})
    }
    inst iSTKSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
        prop Label :: "Stack Memory Segment"
        prop JSName :: "stackMemSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY { 
        prop Label :: "Priority"
        prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if (self == TSK_idle) {if ($1 == 0) {"ok"} else {self.error("Cannot change the priority of the idle task.")}} else {if ($1 == 0) {self.error("Priority 0 is reserved for the system idle task")} else {self.iPRI = $1, "ok"}})
    }
    inst iENV :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Environment pointer"
        prop JSName :: "envPointer"
        prop Visible :: 1
        prop Writable :: self.iDelUser != "TSK"
        prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't shut down system while this task is still running"
        prop JSName :: "exitFlag"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Task Name on Target"
        prop JSName :: "allocateTaskName"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iSTATREG :: = GBL.CACHE { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Label :: "Initial Status Register value"
        prop Visible :: 0
        prop Writable :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
}

object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: @IDL_F_loop
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iPRI :: 0
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 1
}

object KNL_swi :: SWI {
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This object cannot be deleted in DSP/BIOS."
    param function :: @_KNL_run
    param pri :: 0
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 2
}

type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (106)
    prop InstanceHelpTopic :: (206)
    prop InstancePropertyPage :: ("{586735F1-770B-11d0-A61F-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{586735F0-770B-11d0-A61F-0000C070F3E9}")
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %3S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\0, name, _objSize, _linkString")
    prop GenLinkEpilogue :: ("%8t %1U_A_CALBEG = .;\n %4S\n %1U_A_CALEND = .;\n %1U_A_CALLEN = (. - %1U_A_CALBEG) / %2d;%4t\n} > %3s%5s%0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj")
    prop _linkString :: "*(.%1L)"
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {""} else {" PAGE 1"}}
    prop _nilBusyObj :: (if ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) {"IDL_busyObj = 0;\n"} else {""})
    prop _memSeg :: IDL.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * (2 * 4))} else {(2 * 4)}
    prop dataSize :: ((2 * 4) * (IDL.gNumOf + 1))
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop idlFxnSum :: ($a = 0, scan ($i; IDL) {$a += $i.cycles}, $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global AUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Auto calculate idle loop instruction count"
        prop JSName :: "AUTOCALCULATE"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER
        prop Set :: (if ($1 == 1 && CLK.USETIMER == 0) {self.error("CLK must be enabled to do idle loop intruction count")} else {if ($1 == 1 && GBL.ENABLEINST == 0) {self.error("Real Time Analysis must be enabled to do idle loop instuction count")} else {self.AUTOCALCULATE = $1, "ok"}})
        prop NoGen :: 1
    }
    global USECLKIDLTIME :: = IDL.AUTOCALCULATE { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global USEIDLBUSYOBJ :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALIBRFXN :: = (if (IDL.AUTOCALCULATE == 1) {if TSK.USETSK {(if GBL.DSPSUBTYPE == 5502 {@IDL_F_stub5502} else {@IDL_F_stub})} else {if (GBL.DSPSUBTYPE == 5502) {@IDL_F_calibrate5502} else {@IDL_F_calibrate}}} else {@GBL_NULL}) { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALIBRERROR :: = (if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {6} else {0}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Error"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LOOPOVERHEAD :: 0 { 
        prop Label :: "Idle Loop Instruction Count"
        prop JSName :: "LOOPINSTCOUNT"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.AUTOCALCULATE == 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst cycles :: 0 { 
        prop Label :: "CPU cycles"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 1
    }
    inst calibration :: 1 { 
        prop Label :: "Include in CPU load calibration"
        prop JSName :: "calibration"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to compute CPU load and can't be deleted"
    param function :: @IDL_F_busy
    param cycles :: 0
    param calibration :: 1
    param Order :: 3
    param iPri :: 0
}

object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to accumulate CPU load data and can't be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1
    prop Visible :: 0
    prop InstancePropertyPage :: ("{91BA37C0-98C3-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{91BA37C1-98C3-11d1-988B-0020AFEE33C6}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHwi :: HWI_UNUSED { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iIntrSelectNum :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object Reset :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_RESET
    param iIntrSelectNum :: -1
}

object Non_Maskable :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_NMI
    param iIntrSelectNum :: -1
}

object Reserved :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_RESERVED0
    param iIntrSelectNum :: -1
}

object Host_Port_Host_to_DSP :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT13
    param iIntrSelectNum :: 0
}

object Timer_0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT14
    param iIntrSelectNum :: 1
}

object Timer_1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT15
    param iIntrSelectNum :: 2
}

object EMIF_SDRAM_Timer :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 3
}

object External_Pin_4 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
    param iIntrSelectNum :: 4
}

object External_Pin_5 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT5
    param iIntrSelectNum :: 5
}

object External_Pin_6 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT6
    param iIntrSelectNum :: 6
}

object External_Pin_7 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT7
    param iIntrSelectNum :: 7
}

object EDMA_Controller :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}

object HSRTDX11 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT11
    param iIntrSelectNum :: 10
}

object HSRTDX12 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT12
    param iIntrSelectNum :: 11
}

object MCSP_0_Transmit :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 12
}

object MCSP_0_Receive :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 13
}

object MCSP_1_Transmit :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 14
}

object MCSP_1_Receive :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 15
}

object HPI_PCI_to_DSP :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 0
}

object EMIFA_SDRAM_Timer :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 3
}

object GPIO_Interrupt_4 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
    param iIntrSelectNum :: 4
}

object GPIO_Interrupt_5 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT5
    param iIntrSelectNum :: 5
}

object GPIO_Interrupt_6 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT6
    param iIntrSelectNum :: 6
}

object GPIO_Interrupt_7 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT7
    param iIntrSelectNum :: 7
}

object EDMA_Interrupt :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}

object JTAGRTDX9 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 9
}

object EMU_DTDMA :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT9
    param iIntrSelectNum :: 9
}

object EMU_RTDX_RX :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 10
}

object EMU_RTDX_TX :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT11
    param iIntrSelectNum :: 11
}

object GPIO_Interrupt_0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 16
}

object MCSP_2_Transmit :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 17
}

object MCSP_2_Receive :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 18
}

object Timer_2 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 19
}

object EMIFB_SDRAM_Timer :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 20
}

object PCI_WAKEUP :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 21
}

object ICINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 22
}

object UTOPIA_Interrupt :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 23
}

object EMAC_MDIO_INT :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 24
}

object VPINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 25
}

object VPINT1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 26
}

object VPINT2 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 27
}

object AXINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 28
}

object ARINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 29
}

type LOG {
    isa ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (207)
    prop GlobalHelpTopic :: (107)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, _printfAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop _printfAllocDesc :: ("%8t .printf (COPY): {}")
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _fillValue :: if GBL.DSPWORDSIZE == 16 {0xffff} else {0xffffffff}
    prop _instAllocDesc :: ("%8t /* %0s buffer */\n .%0s$buf: align = 0x%1x fill = 0x%2x {}\0, _objAlign, _fillValue")
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * (6 * 4))} else {(6 * 4)}
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _objAlign :: if GBL.DSPTYPE == 55 {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2} else {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)}
    prop _objMemSeg :: self.bufseg
    prop LogType :: self.iType
    prop LogFormat :: self.iFormat
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"log.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LOG_Obj %0r;\n\0"} else {"extern LOG_Obj %0r;\n\0"})
    prop dataSize :: ($d = 0, scan ($i; LOG) {if ($i.IsConfObj()) {$d += $i.buflen} , $d += (6 * 4)}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst buflen :: 64 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "buflen (words)"
        prop JSName :: "bufLen"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.buflen = $1, "ok")
    }
    inst logtype :: "circular" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "circular,fixed"
        prop Label :: "logtype"
        prop JSName :: "logType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iType :: "printf" { 
        prop Label :: "datatype"
        prop JSName :: "dataType"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "printf,raw data"
        prop Visible :: 1
        prop Writable :: if self.iType == "system" {0} else {1}
        prop NoGen :: 1
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" { 
        prop Label :: "format"
        prop JSName :: "format"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if self.iType == "raw data" {1} else {0}
        prop NoGen :: 1
    }
}

object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "LOG"
    param iDelMsg :: "LOG_system is a system log and cannot be deleted."
    param buflen :: 64
    param logtype :: "circular"
    param iType :: "system"
    param iFormat :: "0x%x, 0x%x, 0x%x"
}

type PIP {
    isa ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (109)
    prop InstanceHelpTopic :: (209)
    prop name :: "PIP"
    prop maxObjs :: (32767)
    prop dataSize :: ($b = 0, scan ($i; PIP) {if ($i.IsConfObj()) {$b += (12 + $i.framesize) * $i.numframes + 100} }, $b)
    prop InstancePropertyPage :: ("{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: ("ok")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: (if self.bufalign > 1 {"%8t /* %0s buffer */\n .pip%1d: align = 0x%2x {}\0, _objId, _objAlign"} else {"%8t /* %0s buffer */\n .pip%1d: {}\0, _objId"})
    prop _placement :: (0x7fffffff / 2)
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign * 4
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: 100
    prop mkId :: (self.iId = self.gNextId++, self.gNumOf++, self.iId)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"pip.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PIP_Obj %0r;\n\0"} else {"extern PIP_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 2 { 
        prop NoGen :: 0
    }
    global gNextId :: 0
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
    }
    inst bufalign :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "bufAlign"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 == 0) {$e = self.error("Cannot set align value to 0")} else {self.bufalign = $1}, $e)
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: if GBL.DSPTYPE == 62 {0x02} else {0x01 | 0x02}
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {GlobalStatus.gDirty = 1, self.framesize = $1, "ok"})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Pipes must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst monitor :: "reader" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "monitor"
        prop Enum :: "reader,writer,none"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst bufFrameAlign :: = self._objAlign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (310)
    prop InstanceHelpTopic :: (410)
    prop InstancePropertyPage :: ("{D01ACC04-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC05-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .sem: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop dataSize :: ((8 + 3) * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sem.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SEM_Obj %0r;\n\0"} else {"extern SEM_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 9 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Initial semaphore count"
        prop JSName :: "count"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (307)
    prop InstanceHelpTopic :: (407)
    prop InstancePropertyPage :: ("{0EB45D44-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D45-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,	_bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .mbx: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0 _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$que: align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize")
    prop _instMemSeg :: self.iMbxSeg
    prop _qElemSize :: (if ((GBL.DSPTYPE == 55) || (GBL.DSPTYPE == 28)) {$a = self.iMsgSize, if ($a & 0x1) {$a += 1} , (2 + $a) * self.iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2} else {(2 + self.iMsgSize) * self.iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)})
    prop dataSize :: ($d = 0, scan ($i; MBX) {$d += (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + 29)}, $d)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"mbx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far MBX_Obj %0r;\n\0"} else {"extern MBX_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iMsgSize :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Message Size"
        prop JSName :: "messageSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Message size cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMsgSize = $1, "ok"})
    }
    inst iMbxLength :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Mailbox Length"
        prop JSName :: "length"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Mailbox length cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMbxLength = $1, "ok"})
    }
    inst iMbxSeg :: MBX.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Element memory segment"
        prop JSName :: "elementSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (309)
    prop InstanceHelpTopic :: (409)
    prop InstancePropertyPage :: ("{D01ACC01-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC02-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .que: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop dataSize :: (2 * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"que.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far QUE_Obj %0r;\n\0"} else {"extern QUE_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (306)
    prop InstanceHelpTopic :: (406)
    prop InstancePropertyPage :: ("{0EB45D40-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D41-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .lck: {}")
    prop _objAllocDesc :: ("%8t .LCK$obj: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop dataSize :: ((8 + 2) * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"lck.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LCK_Obj %0r;\n\0"} else {"extern LCK_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (311)
    prop InstanceHelpTopic :: (411)
    prop InstancePropertyPage :: ("{7C4C9A60-763E-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7C4C9A61-763E-11d1-988B-0020AFEE33C6}")
    prop DependsOn :: "DEV,UDEV,DGN,DHL,DPI"
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .SIO$bss: {%12t\n *(.SIO$bss)%8t\n }")
    prop _objAllocDesc :: ("%8t .SIO$obj: {%12t\n *(.SIO$obj)%8t\n }")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instBufDesc, _instBufSeg, _placement")
    prop _instBufDesc :: (if self.iAlign > 1 {"%8t .%0s$bufs: align = 0x%1x {}\0, _objAlign"} else {"%8t .%0s$bufs: {}"})
    prop _objAlign :: self.iAlign
    prop _instBufSeg :: self.iBufSegid
    prop defDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, break} }} }, $j)
    prop devList :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, scan ($a; DIO) {if ($a == $i) {$i.numTimeUse++} }, break} }} }, $j)
    prop setDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($i == $1) {$j = $i} }} }, $j)
    prop localCanCreate :: (if (self.defDev == nil) {self.error("A driver device must be created before creating a stream.")} else {"ok"})
    prop localDelete :: (scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, "ok")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sio.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SIO_Obj %0r;\n\0"} else {"extern SIO_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Only Issue/Reclaim Model"
        prop JSName :: "USEISSUERECLAIM"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.USEISSUERECLAIM = $1, if ($1 == 1) {scan ($i; SIO) {$i.iModelName = "Issue/Reclaim"}} , "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: SIO.devList { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop TypeTest :: $1.isDriver == 1
        prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
        prop Label :: "Device"
        prop JSName :: "deviceName"
        prop Set :: (if (($1.iIsTerminal == 0) && (self.iDevCtrlParam == "")) {self.error("To select a stacking device, enter first a terminal device in Device Control String")} else {if ($1.iIsVirtual == 1) {self.error("The device you have selected is a virtual instance, you must select a non-virtual device")} else {scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, scan ($b; DIO) {if ($b == $1) {$1.numTimeUse++} }, self.iDevice = self.setDev($1), "ok"}})
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevCtrlParam :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Device Control String"
        prop JSName :: "controlParameter"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevId :: = self.iDevice.iDevId
    inst iFxns :: = self.iDevice.iFxns
    inst iMode :: "input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "input,output"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufsize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Buffer size"
        prop JSName :: "bufSize"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iNbufs :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Number of buffers"
        prop JSName :: "numBufs"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufSegid :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Place buffers in memory segment"
        prop JSName :: "bufSegId"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iAlign :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "Buffer alignment"
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iFlush :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Flush"
        prop JSName :: "flush"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iModelName :: "Standard" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Standard,Issue/Reclaim"
        prop Label :: "Model"
        prop JSName :: "modelName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($e = "ok", if (self.USEISSUERECLAIM == 1) {if ($1 == "Standard") {$e = self.error("SIO Issue/Reclaim model support selected")} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}, $e)
    }
    inst iAllocBuf :: = self.iSaveAllocBuf { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Static Buffer(s)"
        prop JSName :: "allocStaticBuf"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (self.iSaveAllocBuf = $1, "ok")
    }
    inst iSaveAllocBuf :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
        prop Visible :: 0
        prop Writable :: 0
    }
    inst iTimeout :: = if self.iModel == "SIO_ISSUERECLAIM" {self.iSaveTimeout} else {-1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timeout for I/O operation"
        prop JSName :: "timeout"
        prop Visible :: 1
        prop Writable :: self.iModel == "SIO_ISSUERECLAIM"
        prop Set :: (self.iSaveTimeout = $1, "ok")
    }
    inst iSaveTimeout :: -1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback function"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "callback function"
        prop JSName :: "callBackFxn"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
}

type STS {
    isa ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (212)
    prop GlobalHelpTopic :: (112)
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop localInit :: (if (PRD.CALLBACKOBJ != nil) {self.error("STS initialization failure")} , PRD.CALLBACKOBJ = STS)
    prop _placement :: (0x7fffffff / 2)
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: STS.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * (4 * 4))} else {(4 * 4)}
    prop dataSize :: ((4 * 4) * (STS.gNumOf + STS.gNumEmbed))
    prop maxObjs :: (32767)
    prop InstancePropertyPage :: ("{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: (self.format)
    prop STSGetSumFmt :: (self.format)
    prop STSGetAvgFmt :: ("%.2f")
    prop STSFilterSum :: ((self.iA * $1 + self.iB * $2) / (1.0 * self.iC))
    prop STSFilterMax :: ((self.iA * $1 + self.iB) / (1.0 * self.iC))
    prop HighTimeBased :: (if self.unittype == "High resolution time based" {1} else {0})
    prop LowTimeBased :: (if self.unittype == "Low resolution time based" {1} else {0})
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sts.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far STS_Obj %0r;\n\0"} else {"extern STS_Obj %0r;\n\0"})
    prop modifiable :: ((if (self.iDelUser == "USER" || self.iDelUser == "HWI") {1} else {0}))
    prop call :: (scan ($a; STS) {if ($a.unittype == "High resolution time based") {$a.iA = CLK.INSTRPERCLK} })
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 9 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst prev :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop JSName :: "previousVal"
        prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
        prop Set :: (self.prev = $1, self.prevlow = $1 & 0xffff, self.prevhigh = ($1 >> 16) & 0xffff, "ok")
    }
    inst format :: "%g" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "format"
        prop NoGen :: 1
    }
    inst unittype :: "Not time based" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not time based,High resolution time based,Low resolution time based"
        prop Label :: "unit type"
        prop JSName :: "unitType"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (self.unittype = $1, if ($1 == "High resolution time based") {self.iA = CLK.INSTRPERCLK, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {if ($1 == "Low resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "Nothing"}}, "ok")
    }
    inst operation :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
        prop Label :: "host operation"
        prop JSName :: "operation"
        prop Visible :: 1
        prop Writable :: ((self.unittype != "Low resolution time based") && self.modifiable())
        prop NoGen :: 1
        prop Set :: (self.operation = $1, if ($1 == "Nothing" && self.unittype != "High resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1} else {if ($1 == "A * x") {self.iB = 0, self.iC = 1} else {if ($1 == "A * x + B") {self.iC = 1} }}, "ok")
    }
    inst iA :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && !(self.unittype != "Not time based" || self.operation == "Nothing"))
        prop Label :: "A"
        prop JSName :: "numA"
        prop NoGen :: 1
    }
    inst iB :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && !(self.unittype == "Low resolution time based" || self.operation == "Nothing" || self.operation == "A * x"))
        prop Label :: "B"
        prop JSName :: "numB"
        prop NoGen :: 1
    }
    inst iC :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && (self.unittype == "Not time based" && self.operation == "(A * x + B) / C"))
        prop Label :: "C"
        prop JSName :: "numC"
        prop NoGen :: 1
    }
    inst prevhigh :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    inst prevlow :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (313)
    prop InstanceHelpTopic :: (413)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop AllocType :: (if self.PUTCFXN == @_UTL_doPutc {"2\0, _globalAllocDesc,	_memSeg, _midPlace, \
	      _traceString, _traceSeg, _midPlace"} else {"1\0, _globalAllocDesc,	_memSeg, _midPlace"})
    prop _globalAllocDesc :: ("%8t .sys:     {}")
    prop _traceString :: ("%8t .trace: fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize")
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACESIZE :: 512 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%d"
        prop Style :: 0x01 | 0x02
        prop Label :: "Trace Buffer Size"
        prop JSName :: "TRACESIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TRACESEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Trace Buffer Memory"
        prop JSName :: "TRACESEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Abort Function"
        prop JSName :: "ABORTFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Error Function"
        prop JSName :: "ERRORFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Putc Function"
        prop JSName :: "PUTCFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: self.USEGIO
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (320)
    prop InstanceHelpTopic :: (420)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "DEV,UDEV"
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _midPlace")
    prop _globalAllocDesc :: ("%8t .gio:     {}")
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEGIO :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable General Input/Output Manager"
        prop JSName :: "ENABLEGIO"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CREATEFXN :: = if self.USEGIO == 1 {@_SEM_create} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create Function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global DELETEFXN :: = if self.USEGIO == 1 {@_SEM_delete} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete Function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global PENDFXN :: = if self.USEGIO == 1 {@_SEM_pend} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Pend Function"
        prop JSName :: "PENDFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global POSTFXN :: = if self.USEGIO == 1 {@_SEM_post} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Post Function"
        prop JSName :: "POSTFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
}

type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (BIOSHELP_DEV_FOLDER)
    prop GlobalPropertyPage :: ("{A2BCEC70-5365-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} , if (DGN.gNumOf || DHL.gNumOf || DPI.gNumOf || DIO.gNumOf || UDEV.gNumOf) {"1\0, _devtableDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .dev: {}")
    prop _devtableDesc :: ("%8t .devtable: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    prop DependsOn :: "HWI"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (315)
    prop InstanceHelpTopic :: (415)
    prop InstancePropertyPage :: ("{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .udev: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (if self.fxnTableType == "DEV_Fxns" {"DEV_SIOTYPE"} else {"DEV_IOMTYPE"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iInit :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "init function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iInit = $1, self.initFxn = self.iInit, "ok")
    }
    inst iFxns :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function table ptr"
        prop JSName :: "fxnTable"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst fxnTableType :: "DEV_Fxns" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_Fxns,IOM_Fxns"
        prop Label :: "function table type"
        prop JSName :: "fxnTableType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst driverType :: = self._driverType { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
        prop Visible :: 0
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device id"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iDevId = $1, self.deviceId = self.iDevId, "ok")
    }
    inst iParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device params ptr"
        prop JSName :: "params"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst deviceId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst initFxn :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst iIsStacking :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stacking Device"
        prop JSName :: "stackingDevice"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device global data ptr"
        prop JSName :: "deviceGlobalDataPtr"
        prop Visible :: 1
        prop Writable :: self.fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal :: = if self.fxnTableType == "DEV_Fxns" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (302)
    prop InstanceHelpTopic :: (402)
    prop InstancePropertyPage :: ("{054FE166-B014-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{054FE167-B014-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dgn: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: "user" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: if GBL.DSPARITHMETIC == "FLOAT" {"user,sine,random,constant,printFloat,printHex,printInt"} else {"user,sine,random,constant,printHex,printInt"}
        prop Label :: "Device category"
        prop JSName :: "device"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a != self.iDevice) {self.iDevice = $a, self.iUserFxn = @_FXN_F_nop} , if ($a == "user") {self.iUserFxn = self.iSaveUserFxn} , if ($a == "printFloat") {self.iUserFxn = @_DGN_printFloat} , if ($a == "printHex") {self.iUserFxn = @_DGN_printHex} , if ($a == "printInt") {self.iUserFxn = @_DGN_printInt} , "ok")
    }
    inst iUseDefaults :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use default parameters"
        prop Visible :: 1
        prop JSName :: "useDefaultParam"
        prop Writable :: self.iDevice == "sine" || self.iDevice == "constant" || self.iDevice == "random" || self.iDevice == "user"
    }
    inst iDevId :: = if self.iDevice == "constant" {@DGN_CONST} else {if self.iDevice == "random" {@DGN_RAND} else {if self.iDevice == "sine" {@DGN_SINE} else {@DGN_USER}}} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Device ID"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iConstant :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Constant value"
        prop JSName :: "constant"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "constant" || self.iDevice == "user")
    }
    inst iRandSeed :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Seed value"
        prop JSName :: "seedValue"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandLower :: if GBL.DSPARITHMETIC == "FIXED" {-32767} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Lower limit"
        prop JSName :: "lowerLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandUpper :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Upper limit"
        prop JSName :: "upperLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iSineGain :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Gain"
        prop JSName :: "gain"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineFreq :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1000.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Frequency (Hz)"
        prop JSName :: "frequency"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSinePhase :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Phase (radians)"
        prop JSName :: "phase"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineRate :: if GBL.DSPARITHMETIC == "FIXED" {256} else {44000} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Sample rate (samples/sec)"
        prop JSName :: "rate"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iUserFxn :: if self.iDevice == "printFloat" {@_DGN_printFloat} else {if self.iDevice == "printHex" {@_DGN_printHex} else {if self.iDevice == "printInt" {@_DGN_printInt} else {@_FXN_F_nop}}} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
        prop Set :: (self.iUserFxn = $1, self.iSaveUserFxn = self.iUserFxn, "ok")
    }
    inst iSaveUserFxn :: @_FXN_F_nop { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iUserArg :: = 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function argument"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
    }
    inst iFxns :: @_DGN_FXNS { 
        prop NoGen :: 1
    }
}

type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    prop dataSize :: (7 + 11 * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop localCanCreate :: (if (self.gChannelsAvailable > 0) {"ok"} else {self.warning("No HST channels are available for a new DHL device.")})
    prop localCreate :: (self.gChannelsAvailable--, self.seizeHSTChannel(self.iHSTChannel), "ok")
    prop seizeHSTChannel :: ($1.iDelUser = "DHL", $1.iDHLAvailable = 0, $1.notify = @_DHL_notify, $1.arg0 = $1.iId, "ok")
    prop localDelete :: (self.gChannelsAvailable++, self.releaseHSTChannel(self.iHSTChannel), "ok")
    prop releaseHSTChannel :: ($1.iDelUser = "USER", $1.iDHLAvailable = 1, $1.notify = @_FXN_F_nop, $1.arg0 = 0, "ok")
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: "%8t .dhl: {}"
    prop _memSeg :: self.OBJMEMSEG
    prop _placement :: (0x7fffffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gChannelsAvailable :: 0
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHSTChannel :: (scan ($i; HST) {if ($i.iDHLAvailable == 1) {$a = $i} }, $a) { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Underlying HST Channel"
        prop JSName :: "hstChannel"
        prop MemberType :: HST
        prop MemberTest :: (if (($1.iDHLAvailable == 1) || ($1 == self.iHSTChannel)) {1} else {0})
        prop Set :: (if ($1.iDHLAvailable != 1) {self.error("This channel is already in use.")} else {self.releaseHSTChannel(self.iHSTChannel), self.seizeHSTChannel($1), self.iHSTChannel = $1, "ok"})
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode :: = self.iHSTChannel.mode { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDevId :: = (self.iHSTChannel.iId) { 
        prop NoGen :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS { 
        prop NoGen :: 1
    }
}

type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (304)
    prop InstanceHelpTopic :: (404)
    prop InstancePropertyPage :: ("{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop localCreate :: (self.gCurDevId += 1, "ok")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gCurDevId :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop Set :: (self.error("DPI.iDevId parameter no longer settable, it is now handled automatically"))
    }
    inst iIsVirtual :: 0 { 
        prop Label :: "Allow virtual instances of this device."
        prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 1) {$a = "ok", $b = 1, scan ($i; SIO) {if ($i.iDevice == self) {$a = self.error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"), $b = 0} }, if ($b == 1) {self.iIsVirtual = 1} , $a} else {self.iIsVirtual = 0, "ok"})
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DPI_FXNS { 
        prop NoGen :: 1
    }
}

type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (318)
    prop InstanceHelpTopic :: (418)
    prop localCreate :: (if (self.gNumOf == 0) {HOOK_KNL.iIsUsed = 1, self.mkId(0)} , "ok")
    prop localDelete :: (if (self.gNumOf == 2) {HOOK_KNL.iIsUsed = 0, self.rmId} , "ok")
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global KNLID :: = (HOOK_KNL.Order - 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst initFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Initialization function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "createFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "deleteFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "exitFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "callSwitchFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "switchFxn"
        prop Visible :: 1
        prop Writable :: self.callSwitchFxn
    }
    inst callReadyFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "callReadyFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "readyFxn"
        prop Visible :: 1
        prop Writable :: self.callReadyFxn
    }
    inst Order :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object HOOK_KNL :: HOOK {
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: @_FXN_F_nop
    param deleteFxn :: @_FXN_F_nop
    param exitFxn :: @_FXN_F_nop
    param callSwitchFxn :: 0
    param switchFxn :: @_FXN_F_nop
    param callReadyFxn :: 0
    param readyFxn :: @_FXN_F_nop
    param Order :: 1
    param iPri :: 0
}

type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (319)
    prop InstanceHelpTopic :: (419)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dio: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop isDriver :: (1)
    prop mdObject :: ($h = nil, $j = nil, scan ($h; UDEV) {if ($h.driverType == "DEV_IOMTYPE") {$j = $h, break} }, $j)
    prop localCanCreate :: (if (self.mdObject == nil) {self.error("An IOM type device must be created first.")} else {"ok"})
    prop numTsk :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 0) {$a = $a + $h.numTimeUse} }, $a)
    prop numSwi :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 1) {$a = $a + $h.numTimeUse} }, $a)
    prop functionTablePtr :: (if (self.STATIC) {if (self.useCallBackFxn) {@_DIO_cbStaticFxns} else {@_DIO_tskStaticFxns}} else {if (self.useCallBackFxn) {@_DIO_cbDynamicFxns} else {@_DIO_tskDynamicFxns}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: ISRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STATIC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Create all DIO Objects Statically"
        prop JSName :: "STATICCREATE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global NUMTSKBASE :: = self.numTsk { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TSK based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global NUMSWIBASE :: = self.numSwi { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "SWI based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback version of DIO function table"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst fxnsTable :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst deviceName :: self.mdObject { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: UDEV
        prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label :: "device name"
        prop JSName :: "deviceName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst chanParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "channel parameters"
        prop JSName :: "chanParams"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst numTimeUse :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFxns :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type CSL {
    isa ModuleFolder
    prop name :: "CSL"
    prop Label :: "CSL - Chip Support Library"
    prop NoGen :: 1
    prop cGen :: 1
    prop cHeaderName :: (if ((externDecl.HeaderName() == "csl.h") || (externDecl.HeaderFile != "NULL") || (dmaCfg.cHeaderName() == "csl_dma.h" && self.DMA_SUPPORT) || (hDma.cHeaderName() == "csl_dma.h" && self.DMA_SUPPORT) || (dmaGblCfg.cHeaderName() == "csl_dma.h" && self.DMA_SUPPORT) || (edmaCfg.cHeaderName() != "" && self.EDMA_SUPPORT) || (hEdma.cHeaderName() == "csl_edma.h" && self.EDMA_SUPPORT) || (hEdmaTbl.cHeaderName() == "csl_edma.h" && self.EDMA_SUPPORT) || (emifCfg.cHeaderName() == "csl_emif.h" && self.EMIF_SUPPORT) || (emifaCfg.cHeaderName() == "csl_emifa.h" && self.EMIFA_SUPPORT) || (emifbCfg.cHeaderName() == "csl_emifb.h" && self.EMIFB_SUPPORT) || (mcbspCfg.cHeaderName() == "csl_mcbsp.h" && self.MCBSP_SUPPORT) || (hMcbsp.cHeaderName() == "csl_mcbsp.h" && self.MCBSP_SUPPORT) || (tcpCfg.cHeaderName() == "csl_tcp.h" && self.TCP_SUPPORT) || (timerCfg.cHeaderName() == "csl_timer.h" && self.TIMER_SUPPORT) || (hTimer.cHeaderName() == "csl_timer.h" && self.TIMER_SUPPORT) || (vcpCfg.cHeaderName() == "csl_vcp.h" && self.VCP_SUPPORT) || (xbusCfg.cHeaderName() == "csl_xbus.h" && self.XBUS_SUPPORT)) {"csl.h"} else {""})
    prop GlobalIcon :: 156
    prop GlobalHelpTopic :: (1000)
    prop GlobalPropertyPage :: "{33A68984-598D-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{33A68985-598D-11d4-B5CC-0050DA2E2CC0}"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIP_6201 :: = (GBL.CHIPTYPE == "6201") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6201"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6202 :: = (GBL.CHIPTYPE == "6202") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6202"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6203 :: = (GBL.CHIPTYPE == "6203") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6203"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6204 :: = (GBL.CHIPTYPE == "6204") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6204"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6205 :: = (GBL.CHIPTYPE == "6205") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6205"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6211 :: = (GBL.CHIPTYPE == "6211") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6211"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6701 :: = (GBL.CHIPTYPE == "6701") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6701"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6711 :: = (GBL.CHIPTYPE == "6711") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6711"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6712 :: = (GBL.CHIPTYPE == "6712") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6712"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6713 :: = (GBL.CHIPTYPE == "6713") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6713"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_DA610 :: = (GBL.CHIPTYPE == "DA610") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " DA610"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_DM642 :: = (GBL.CHIPTYPE == "DM642") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " DM642"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6412 :: = (GBL.CHIPTYPE == "6412") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6412"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6414 :: = (GBL.CHIPTYPE == "6414") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6414"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6415 :: = (GBL.CHIPTYPE == "6415") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6400"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6416 :: = (GBL.CHIPTYPE == "6416") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6400"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_6400 :: = (GBL.CHIPTYPE == "6400") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " 6400"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global CHIP_NONE :: = (GBL.CHIPTYPE == "other") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " NONE"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global C11_SUPPORT :: = (self.CHIP_6211 || self.CHIP_6711 || self.CHIP_6712 || self.CHIP_6713 || self.CHIP_DA610) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C11_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global C64_SUPPORT :: = (self.CHIP_6400 || self.CHIP_6414 || self.CHIP_6415 || self.CHIP_6416 || self.CHIP_DM642 || self.CHIP_6412) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C64_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global TIMER_SUPPORT :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TIMER_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global TIMER2_SUPPORT :: = (self.C64_SUPPORT) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TIMER2_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global MCBSP_SUPPORT :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "MCBSP_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global MCBSP2_SUPPORT :: = (self.C64_SUPPORT || self.CHIP_6202 || self.CHIP_6203) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "MCBSP2_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global EMIF_SUPPORT :: = (!self.CHIP_6400 && !self.CHIP_NONE) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "EMIF_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global EMIFA_SUPPORT :: = (self.C64_SUPPORT) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "EMIFA_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global EMIFB_SUPPORT :: = (self.C64_SUPPORT) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "EMIFB_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global DMA_SUPPORT :: = (self.CHIP_6201 || self.CHIP_6202 || self.CHIP_6203 || self.CHIP_6204 || self.CHIP_6205 || self.CHIP_6701) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DMA_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global EDMA_SUPPORT :: = (self.C11_SUPPORT || self.C64_SUPPORT) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "EDMA_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global XBUS_SUPPORT :: = (self.CHIP_6202 || self.CHIP_6203 || self.CHIP_6204) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "XBUS_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global TCP_SUPPORT :: = (self.CHIP_6416) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TCP_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global VCP_SUPPORT :: = (self.CHIP_6416) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "VCP_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
    global L2_SUPPORT :: = (self.C11_SUPPORT) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2_SUPPORT"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

type externDecl {
    isa ObjectMgr
    prop name :: "externDecl"
    prop Label :: "CSL Extern Declaration"
    prop JSName :: "ExternDecl"
    prop IsContainedIn :: CSL
    prop GlobalPropertyPage :: "{33A68986-598D-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{33A68987-598D-11d4-B5CC-0050DA2E2CC0}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop HeaderName :: if self.gNumOf > 0 {"csl.h"} else {""}
    prop GlobalHelpTopic :: (1005)
    prop InstanceHelpTopic :: (1005)
    prop NoGen :: 1
    prop cGen :: 1
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; externDecl) {$a = $a + 1}, "ok")
    prop HeaderStr :: if (self.HeaderFile != "NULL") {self.HeaderFile} else {""}
    prop IncludeStr :: if (self.HeaderFile != "NULL") {"#include "} else {""}
    prop IncludeEndStr :: if (self.HeaderFile != "NULL") {"\n"} else {""}
    prop cGenCPrologue :: ("%1S%2S%3S\n\0,IncludeStr,HeaderStr,IncludeEndStr")
    prop SymType :: if (self.BuffName != "NULL" && self.BuffType != "NULL") {self.BuffType} else {""}
    prop SymName :: if (self.BuffName != "NULL" && self.BuffType != "NULL") {self.BuffName} else {""}
    prop SymSpec :: if (self.BuffName != "NULL" && self.BuffType != "NULL" && self.BuffSpec == "Array") {"[]"} else {""}
    prop ExternStr :: if (self.BuffName != "NULL" && self.BuffType != "NULL") {"extern far "} else {""}
    prop EndStr :: if (self.BuffName != "NULL" && self.BuffType != "NULL") {";\n"} else {""}
    prop cGenCInst :: ("%1S%2S %3S%4S%5S\n\0,ExternStr,SymType,SymName,SymSpec,EndStr")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global HeaderFile :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enter header filename between quotes "
        prop JSName :: "HEADER_FILENAME"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == "") {self.HeaderFile = "NULL", "ok"} else {self.HeaderFile = $1, "ok"})
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst BuffType :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CSL Symbol Type (ex: Uint32)"
        prop JSName :: "bufType"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (self.BuffType = $1, "ok")
    }
    inst BuffName :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Symbol Name (ex: BuffA)"
        prop JSName :: "bufName"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 == $b.BuffName) {$a += 1} }, if ($a > 0) {self.error(" Symbol Name already used ")} else {self.BuffName = $1, "ok"})
    }
    inst BuffSpec :: "Non-array" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Non-array,Array"
        prop Label :: "Symbol Specification"
        prop JSName :: "bufSpec"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (self.BuffSpec = $1, "ok")
    }
}

object EXTERN_NOTHING :: externDecl {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param BuffType :: "NULL"
    param BuffName :: "NULL"
    param BuffSpec :: "Non-array"
}

object DeclNull :: externDecl {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param BuffType :: "NULL"
    param BuffName :: "NULL"
    param BuffSpec :: "Non-array"
}

type DMAFOLDER {
    prop Label :: "DMA Direct Memory Access"
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalHelpTopic :: 1020
    prop GlobalPropertyPage :: "{B936FB91-49A5-11d4-967C-0050048381B7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type dmaCfg {
    isa ObjectMgr
    prop name :: "dmaCfg"
    prop Label :: "DMA Configuration Manager"
    prop JSName :: "DMA"
    prop IsContainedIn :: DMAFOLDER
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalHelpTopic :: 1021
    prop InstanceHelpTopic :: 1021
    prop NoGen :: 1
    prop cGen :: CSL.DMA_SUPPORT
    prop cStruct :: CSL.DMA_SUPPORT
    prop cStructType :: "DMA_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_dma.h"} else {""}
    prop cStructQual :: "far"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; dmaCfg) {$a = $a + 1}, if ($a == 2) {scan ($c; hDma) {$c.PINIT_ENABLE = 0}} , "ok")
    prop START_PRICTL :: (if (self.START_SETUP == "Stop") {0x00000000} else {if (self.START_SETUP == "Start w/o Autoinit") {0x00000001} else {if (self.START_SETUP == "Pause") {0x00000002} else {if (self.START_SETUP == "Start w/ Autoinit") {0x00000003} }}})
    prop SRCDIR_PRICTL :: (if (self.SRCDIR_SETUP == "None") {0x00000000} else {if (self.SRCDIR_SETUP == "Increment") {0x00000010} else {if (self.SRCDIR_SETUP == "Decrement") {0x00000020} else {if (self.SRCDIR_SETUP == "Index") {0x00000030} }}})
    prop DSTDIR_PRICTL :: (if (self.DSTDIR_SETUP == "None") {0x00000000} else {if (self.DSTDIR_SETUP == "Increment") {0x00000040} else {if (self.DSTDIR_SETUP == "Decrement") {0x00000080} else {if (self.DSTDIR_SETUP == "Index") {0x000000C0} }}})
    prop ESIZE_PRICTL :: (if (self.ESIZE_SETUP == "32-bit") {0x00000000} else {if (self.ESIZE_SETUP == "16-bit") {0x00000100} else {if (self.ESIZE_SETUP == "8-bit") {0x00000200} }})
    prop SPLIT_PRICTL :: (if (self.SPLIT_SETUP == "Disable") {0x00000000} else {if (self.SPLIT_SETUP == "Global Address Register A") {0x00000400} else {if (self.SPLIT_SETUP == "Global Address Register B") {0x00000800} else {if (self.SPLIT_SETUP == "Global Address Register C") {0x00000C00} }}})
    prop CNTRLD_PRICTL :: (if (self.CNTRLD_SETUP == "Count Reload Reg A") {0x00000000} else {if (self.CNTRLD_SETUP == "Count Reload Reg B") {0x00001000} })
    prop INDEX_PRICTL :: (if (self.INDEX_SETUP == "Global Index Register A") {0x00000000} else {if (self.INDEX_SETUP == "Global Index Register B") {0x00002000} })
    prop RSYNC_PRICTL :: (if (self.RSYNC_SETUP == "None") {0x00000000} else {if (self.RSYNC_SETUP == "Timer 0 Interrupt") {0x00004000} else {if (self.RSYNC_SETUP == "Timer 1 Interrupt") {0x00008000} else {if (self.RSYNC_SETUP == "EMIF Timer Interrupt") {0x0000C000} else {if (self.RSYNC_SETUP == "External Interrupt Pin 4") {0x00010000} else {if (self.RSYNC_SETUP == "External Interrupt Pin 5") {0x00014000} else {if (self.RSYNC_SETUP == "External Interrupt Pin 6") {0x00018000} else {if (self.RSYNC_SETUP == "External Interrupt Pin 7") {0x0001C000} else {if (self.RSYNC_SETUP == "DMA Channel 0 Interrupt") {0x00020000} else {if (self.RSYNC_SETUP == "DMA Channel 1 Interrupt") {0x00024000} else {if (self.RSYNC_SETUP == "DMA Channel 2 Interrupt") {0x00028000} else {if (self.RSYNC_SETUP == "DMA Channel 3 Interrupt") {0x0002C000} else {if (self.RSYNC_SETUP == "McBSP 0 Transmit Event") {0x00030000} else {if (self.RSYNC_SETUP == "McBSP 0 Receive Event") {0x00034000} else {if (self.RSYNC_SETUP == "McBSP 1 Transmit Event") {0x00038000} else {if (self.RSYNC_SETUP == "McBSP 1 Receive Event") {0x0003C000} else {if (self.RSYNC_SETUP == "Host to DSP Interrupt") {0x00040000} else {if (self.RSYNC_SETUP == "McBSP 2 Transmit Event") {0x00044000} else {if (self.RSYNC_SETUP == "McBSP 2 Receive Event") {0x00048000} }}}}}}}}}}}}}}}}}})
    prop WSYNC_PRICTL :: (if (self.WSYNC_SETUP == "None") {0x00000000} else {if (self.WSYNC_SETUP == "Timer 0 Interrupt") {0x00080000} else {if (self.WSYNC_SETUP == "Timer 1 Interrupt") {0x00100000} else {if (self.WSYNC_SETUP == "EMIF Timer Interrupt") {0x00180000} else {if (self.WSYNC_SETUP == "External Interrupt Pin 4") {0x00200000} else {if (self.WSYNC_SETUP == "External Interrupt Pin 5") {0x00280000} else {if (self.WSYNC_SETUP == "External Interrupt Pin 6") {0x00300000} else {if (self.WSYNC_SETUP == "External Interrupt Pin 7") {0x00380000} else {if (self.WSYNC_SETUP == "DMA Channel 0 Interrupt") {0x00400000} else {if (self.WSYNC_SETUP == "DMA Channel 1 Interrupt") {0x00480000} else {if (self.WSYNC_SETUP == "DMA Channel 2 Interrupt") {0x00500000} else {if (self.WSYNC_SETUP == "DMA Channel 3 Interrupt") {0x00580000} else {if (self.WSYNC_SETUP == "McBSP 0 Transmit Event") {0x00600000} else {if (self.WSYNC_SETUP == "McBSP 0 Receive Event") {0x00680000} else {if (self.WSYNC_SETUP == "McBSP 1 Transmit Event") {0x00700000} else {if (self.WSYNC_SETUP == "McBSP 1 Receive Event") {0x00780000} else {if (self.WSYNC_SETUP == "Host to DSP Interrupt") {0x00800000} else {if (self.WSYNC_SETUP == "McBSP 2 Transmit Event") {0x00880000} else {if (self.WSYNC_SETUP == "McBSP 2 Receive Event") {0x00900000} }}}}}}}}}}}}}}}}}})
    prop PRI_PRICTL :: (if (self.PRI_SETUP == "CPU") {0x00000000} else {if (self.PRI_SETUP == "DMA") {0x01000000} })
    prop TCINT_PRICTL :: (if (self.TCINT_SETUP == "Disable") {0x00000000} else {if (self.TCINT_SETUP == "Enable") {0x02000000} })
    prop FS_PRICTL :: (if (self.FS_SETUP == "Disable") {0x00000000} else {if (self.FS_SETUP == "RSYNC") {0x04000000} })
    prop EMOD_PRICTL :: (if (self.EMOD_SETUP == "Continue") {0x00000000} else {if (self.EMOD_SETUP == "Pause") {0x08000000} })
    prop SRCRLD_PRICTL :: (if (self.SRCRLD_SETUP == "No Reload") {0x00000000} else {if (self.SRCRLD_SETUP == "Global Address Register B") {0x10000000} else {if (self.SRCRLD_SETUP == "Global Address Register C") {0x20000000} else {if (self.SRCRLD_SETUP == "Global Address Register D") {0x30000000} }}})
    prop DSTRLD_PRICTL :: (if (self.DSTRLD_SETUP == "No Reload") {0x00000000} else {if (self.DSTRLD_SETUP == "Global Address Register B") {0x40000000} else {if (self.DSTRLD_SETUP == "Global Address Register C") {0x80000000} else {if (self.DSTRLD_SETUP == "Global Address Register D") {0xC0000000} }}})
    prop SXCOND_SECCTL :: (if (self.SXCOND_SETUP == "Clear") {0x00000000} else {if (self.SXCOND_SETUP == "No Effect") {0x00000001} })
    prop FRAMECOND_SECCTL :: (if (self.FRAMECOND_SETUP == "Clear") {0x00000000} else {if (self.FRAMECOND_SETUP == "No Effect") {0x00000004} })
    prop LASTCOND_SECCTL :: (if (self.LASTCOND_SETUP == "Clear") {0x00000000} else {if (self.LASTCOND_SETUP == "No Effect") {0x00000010} })
    prop BLOCKCOND_SECCTL :: (if (self.BLOCKCOND_SETUP == "Clear") {0x00000000} else {if (self.BLOCKCOND_SETUP == "No Effect") {0x00000040} })
    prop RDROPCOND_SECCTL :: (if (self.RDROPCOND_SETUP == "Clear") {0x00000000} else {if (self.RDROPCOND_SETUP == "No Effect") {0x00000100} })
    prop WDROPCOND_SECCTL :: (if (self.WDROPCOND_SETUP == "Clear") {0x00000000} else {if (self.WDROPCOND_SETUP == "No Effect") {0x00000400} })
    prop SXIE_SECCTL :: (if (self.SXIE_SETUP == "Disable") {0x00000000} else {if (self.SXIE_SETUP == "Enable") {0x00000002} })
    prop FRAMEIE_SECCTL :: (if (self.FRAMEIE_SETUP == "Disable") {0x00000000} else {if (self.FRAMEIE_SETUP == "Enable") {0x00000008} })
    prop LASTIE_SECCTL :: (if (self.LASTIE_SETUP == "Disable") {0x00000000} else {if (self.LASTIE_SETUP == "Enable") {0x00000020} })
    prop BLOCKIE_SECCTL :: (if (self.BLOCKIE_SETUP == "Enable") {0x00000080} else {if (self.BLOCKIE_SETUP == "Disable") {0x00000000} })
    prop RDROPIE_SECCTL :: (if (self.RDROPIE_SETUP == "Disable") {0x00000000} else {if (self.RDROPIE_SETUP == "Enable") {0x00000200} })
    prop WDROPIE_SECCTL :: (if (self.WDROPIE_SETUP == "Disable") {0x00000000} else {if (self.WDROPIE_SETUP == "Enable") {0x00000800} })
    prop RSYNCSTAT_SECCTL :: (if (self.RSYNCSTAT_SETUP == "Not Received") {0x00000000} else {if (self.RSYNCSTAT_SETUP == "Received") {0x00001000} })
    prop WSYNCSTAT_SECCTL :: (if (self.WSYNCSTAT_SETUP == "Not Received") {0x00000000} else {if (self.WSYNCSTAT_SETUP == "Received") {0x00004000} })
    prop RSYNCCLR_SECCTL :: (if (self.RSYNCCLR_SETUP == "None") {0x00000000} else {if (self.RSYNCCLR_SETUP == "Clear") {0x00002000} })
    prop WSYNCCLR_SECCTL :: (if (self.WSYNCCLR_SETUP == "None") {0x00000000} else {if (self.WSYNCCLR_SETUP == "Clear") {0x00008000} })
    prop DMACEN_SECCTL :: (if (self.DMACEN_SETUP == "Low") {0x00000000} else {if (self.DMACEN_SETUP == "High") {0x00010000} else {if (self.DMACEN_SETUP == "RSYNC STAT") {0x00020000} else {if (self.DMACEN_SETUP == "WSYNC STAT") {0x00030000} else {if (self.DMACEN_SETUP == "FRAME COND") {0x00040000} else {if (self.DMACEN_SETUP == "BLOCK COND") {0x00050000} }}}}})
    prop FSIG_SECCTL :: (if (self.FSIG_SETUP == "None") {0x00000000} else {if (self.FSIG_SETUP == "Ignore") {0x00080000} })
    prop RSPOL_SECCTL :: (if (self.RSPOL_SETUP == "Active Low") {0x00000000} else {if (self.RSPOL_SETUP == "Active High") {0x00100000} })
    prop WSPOL_SECCTL :: (if (self.WSPOL_SETUP == "Active Low") {0x00000000} else {if (self.WSPOL_SETUP == "Active High") {0x00200000} })
    prop PRICTL_VALUE_update :: (self.START_PRICTL() | self.SRCDIR_PRICTL() | self.DSTDIR_PRICTL() | self.ESIZE_PRICTL() | self.SPLIT_PRICTL() | self.CNTRLD_PRICTL() | self.INDEX_PRICTL() | self.RSYNC_PRICTL() | self.WSYNC_PRICTL() | self.PRI_PRICTL() | self.TCINT_PRICTL() | self.FS_PRICTL() | self.EMOD_PRICTL() | self.SRCRLD_PRICTL() | self.DSTRLD_PRICTL())
    prop PRICTL_SETUP_update :: (self.START_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000001) {"Start w/o Autoinit"} else {if ($a == 0x00000002) {"Pause"} else {if ($a == 0x00000003) {"Start w/ Autoinit"} else {"Stop"}}}), self.SRCDIR_SETUP = ($a = ($1 & 0x00000030), if ($a == 0x00000010) {"Increment"} else {if ($a == 0x00000020) {"Decrement"} else {if ($a == 0x00000030) {"Index"} else {"None"}}}), self.DSTDIR_SETUP = ($a = ($1 & 0x000000C0), if ($a == 0x00000040) {"Increment"} else {if ($a == 0x00000080) {"Decrement"} else {if ($a == 0x000000C0) {"Index"} else {"None"}}}), self.ESIZE_SETUP = ($a = ($1 & 0x00000300), if ($a == 0x00000100) {"16-bit"} else {if ($a == 0x00000200) {"8-bit"} else {"32-bit"}}), self.SPLIT_SETUP = ($a = ($1 & 0x00000C00), if ($a == 0x00000400) {"Global Address Register A"} else {if ($a == 0x00000800) {"Global Address Register B"} else {if ($a == 0x00000C00) {"Global Address Register C"} else {"Disable"}}}), self.CNTRLD_SETUP = if ($1 & 0x00001000) {"Count Reload Reg B"} else {"Count Reload Reg A"}, self.INDEX_SETUP = if ($1 & 0x00002000) {"Global Index Register B"} else {"Global Index Register A"}, self.RSYNC_SETUP = ($a = ($1 & 0x0007C000), if ($a == 0x00004000) {"Timer 0 Interrupt"} else {if ($a == 0x00008000) {"Timer 1 Interrupt"} else {if ($a == 0x0000C000) {"EMIF Timer Interrupt"} else {if ($a == 0x00010000) {"External Interrupt Pin 4"} else {if ($a == 0x00014000) {"External Interrupt Pin 5"} else {if ($a == 0x00018000) {"External Interrupt Pin 6"} else {if ($a == 0x0001C000) {"External Interrupt Pin 7"} else {if ($a == 0x00020000) {"DMA Channel 0 Interrupt"} else {if ($a == 0x00024000) {"DMA Channel 1 Interrupt"} else {if ($a == 0x00028000) {"DMA Channel 2 Interrupt"} else {if ($a == 0x0002C000) {"DMA Channel 3 Interrupt"} else {if ($a == 0x00030000) {"McBSP 0 Transmit Event"} else {if ($a == 0x00034000) {"McBSP 0 Receive Event"} else {if ($a == 0x00038000) {"McBSP 1 Transmit Event"} else {if ($a == 0x0003C000) {"McBSP 1 Receive Event"} else {if ($a == 0x00040000) {"Host to DSP Interrupt"} else {if ($a == 0x00044000) {"McBSP 2 Transmit Event"} else {if ($a == 0x00048000) {"McBSP 2 Receive Event"} else {"None"}}}}}}}}}}}}}}}}}}), self.WSYNC_SETUP = ($a = ($1 & 0x00F80000), if ($a == 0x00080000) {"Timer 0 Interrupt"} else {if ($a == 0x00100000) {"Timer 1 Interrupt"} else {if ($a == 0x00180000) {"EMIF Timer Interrupt"} else {if ($a == 0x00200000) {"External Interrupt Pin 4"} else {if ($a == 0x00280000) {"External Interrupt Pin 5"} else {if ($a == 0x00300000) {"External Interrupt Pin 6"} else {if ($a == 0x00380000) {"External Interrupt Pin 7"} else {if ($a == 0x00400000) {"DMA Channel 0 Interrupt"} else {if ($a == 0x00480000) {"DMA Channel 1 Interrupt"} else {if ($a == 0x00500000) {"DMA Channel 2 Interrupt"} else {if ($a == 0x00580000) {"DMA Channel 3 Interrupt"} else {if ($a == 0x00600000) {"McBSP 0 Transmit Event"} else {if ($a == 0x00680000) {"McBSP 0 Receive Event"} else {if ($a == 0x00700000) {"McBSP 1 Transmit Event"} else {if ($a == 0x00780000) {"McBSP 1 Receive Event"} else {if ($a == 0x00800000) {"Host to DSP Interrupt"} else {if ($a == 0x00880000) {"McBSP 2 Transmit Event"} else {if ($a == 0x00900000) {"McBSP 2 Receive Event"} else {"None"}}}}}}}}}}}}}}}}}}), self.PRI_SETUP = if ($1 & 0x01000000) {"DMA"} else {"CPU"}, self.TCINT_SETUP = if ($1 & 0x02000000) {"Enable"} else {"Disable"}, self.FS_SETUP = if ($1 & 0x04000000) {"RSYNC"} else {"Disable"}, self.EMOD_SETUP = if ($1 & 0x08000000) {"Pause"} else {"Continue"}, self.SRCRLD_SETUP = ($a = ($1 & 0x30000000), if ($a == 0x10000000) {"Global Address Register B"} else {if ($a == 0x20000000) {"Global Address Register C"} else {if ($a == 0x30000000) {"Global Address Register D"} else {"No Reload"}}}), self.DSTRLD_SETUP = ($a = ($1 & 0xC0000000), if ($a == 0x40000000) {"Global Address Register B"} else {if ($a == 0x80000000) {"Global Address Register C"} else {if ($a == 0xC0000000) {"Global Address Register D"} else {"No Reload"}}}))
    prop SECCTL_VALUE_update :: (self.SXCOND_SECCTL() | self.FRAMECOND_SECCTL() | self.LASTCOND_SECCTL() | self.BLOCKCOND_SECCTL() | self.RDROPCOND_SECCTL() | self.WDROPCOND_SECCTL() | self.SXIE_SECCTL() | self.FRAMEIE_SECCTL() | self.LASTIE_SECCTL() | self.BLOCKIE_SECCTL() | self.RDROPIE_SECCTL() | self.WDROPIE_SECCTL() | self.RSYNCSTAT_SECCTL() | self.WSYNCSTAT_SECCTL() | self.DMACEN_SECCTL() | self.RSYNCCLR_SECCTL() | self.WSYNCCLR_SECCTL() | (if GBL.SUBTYPE == 6700 {self.FSIG_SECCTL()} else {0}) | (if GBL.SUBTYPE == 6700 {self.RSPOL_SECCTL()} else {0}) | (if GBL.SUBTYPE == 6700 {self.WSPOL_SECCTL()} else {0}))
    prop SECCTL_SETUP_update :: (self.SXCOND_SETUP = if ($1 & 0x00000001) {"No Effect"} else {"Clear"}, self.FRAMECOND_SETUP = if ($1 & 0x00000004) {"No Effect"} else {"Clear"}, self.LASTCOND_SETUP = if ($1 & 0x00000010) {"No Effect"} else {"Clear"}, self.BLOCKCOND_SETUP = if ($1 & 0x00000040) {"No Effect"} else {"Clear"}, self.RDROPCOND_SETUP = if ($1 & 0x00000100) {"No Effect"} else {"Clear"}, self.WDROPCOND_SETUP = if ($1 & 0x00000400) {"No Effect"} else {"Clear"}, self.SXIE_SETUP = if ($1 & 0x00000002) {"Enable"} else {"Disable"}, self.FRAMEIE_SETUP = if ($1 & 0x00000008) {"Enable"} else {"Disable"}, self.LASTIE_SETUP = if ($1 & 0x00000020) {"Enable"} else {"Disable"}, self.BLOCKIE_SETUP = if ($1 & 0x00000080) {"Enable"} else {"Disable"}, self.RDROPIE_SETUP = if ($1 & 0x00000200) {"Enable"} else {"Disable"}, self.WDROPIE_SETUP = if ($1 & 0x00000800) {"Enable"} else {"Disable"}, self.RSYNCSTAT_SETUP = if ($1 & 0x00001000) {"Received"} else {"Not Received"}, self.WSYNCSTAT_SETUP = if ($1 & 0x00004000) {"Received"} else {"Not Received"}, self.RSYNCCLR_SETUP = if ($1 & 0x00002000) {"Clear"} else {"None"}, self.WSYNCCLR_SETUP = if ($1 & 0x00008000) {"Clear"} else {"None"}, self.DMACEN_SETUP = ($a = ($1 & 0x00070000), if ($a == 0x00010000) {"High"} else {if ($a == 0x00020000) {"RSYNC STAT"} else {if ($a == 0x00030000) {"WSYNC STAT"} else {if ($a == 0x00040000) {"FRAME COND"} else {if ($a == 0x00050000) {"BLOCK COND"} else {"Low"}}}}}), if (GBL.SUBTYPE == 6700) {self.FSIG_SETUP = if ($1 & 0x00080000) {"Ignore"} else {"None"}, if ((self.RSYNC_SETUP == "External Interrupt Pin 4") || (self.RSYNC_SETUP == "External Interrupt Pin 5") || (self.RSYNC_SETUP == "External Interrupt Pin 6") || (self.RSYNC_SETUP == "External Interrupt Pin 7")) {self.RSPOL_SETUP = if ($1 & 0x00100000) {"Active High"} else {"Active Low"}} , if ((self.WSYNC_SETUP == "External Interrupt Pin 4") || (self.WSYNC_SETUP == "External Interrupt Pin 5") || (self.WSYNC_SETUP == "External Interrupt Pin 6") || (self.WSYNC_SETUP == "External Interrupt Pin 7")) {self.WSPOL_SETUP = if ($1 & 0x00200000) {"Active High"} else {"Active Low"}} } )
    prop configStruct :: self
    prop cfgStrCNT :: if (self.XFRCNT_FORMAT == "User's Header file") {"%5t%3s.xfrcnt = DMA_XFRCNT_RMK("} else {""}
    prop FramecntStr :: (if (self.XFRCNT_FORMAT == "User's Header file" && self.FRAMECNT_HEADER == "NULL") {"0"} else {if (self.XFRCNT_FORMAT == "User's Header file" && self.FRAMECNT_HEADER != "NULL") {self.FRAMECNT_HEADER} else {""}})
    prop ElmcntStr :: (if (self.XFRCNT_FORMAT == "User's Header file" && self.ELMCNT_HEADER == "NULL") {"0"} else {if (self.XFRCNT_FORMAT == "User's Header file" && self.ELMCNT_HEADER != "NULL") {self.ELMCNT_HEADER} else {""}})
    prop XfrCntStr :: if (self.XFRCNT_FORMAT == "User's Header file") {"%4s,%5s);\n%0t"} else {""}
    prop cfgStrSRC :: if (self.SRCADDR_FORMAT == "McBSP handle (DRR)" && self.SRCADDR_HANDLE != "NULL") {"%5t%3s.src = DMA_SRC_RMK("} else {""}
    prop SrcHandle :: if (self.SRCADDR_FORMAT == "McBSP handle (DRR)" && self.SRCADDR_HANDLE != "NULL") {self.SRCADDR_HANDLE} else {""}
    prop SrcStr :: if (self.SRCADDR_FORMAT == "McBSP handle (DRR)" && self.SRCADDR_HANDLE != "NULL") {"%8s->drrAddr);\n%0t"} else {""}
    prop cfgStrDST :: if (self.DSTADDR_FORMAT == "McBSP handle (DXR)" && self.DSTADDR_HANDLE != "NULL") {"%5t%3s.dst = DMA_DST_RMK("} else {""}
    prop DstHandle :: if (self.DSTADDR_FORMAT == "McBSP handle (DXR)" && self.DSTADDR_HANDLE != "NULL") {self.DSTADDR_HANDLE} else {""}
    prop DstStr :: if (self.DSTADDR_FORMAT == "McBSP handle (DXR)" && self.DSTADDR_HANDLE != "NULL") {"%11s->dxrAddr);\n%0t"} else {""}
    prop cGenFxnPostInst :: ("%1S%2S%6S%7S%9S%10S\0,cfgStrCNT,XfrCntStr,configStruct,FramecntStr,ElmcntStr,cfgStrSRC,SrcStr,SrcHandle,cfgStrDST,DstStr,DstHandle")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst START_SETUP :: "Stop" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop,Start w/o Autoinit,Pause,Start w/ Autoinit"
        prop Label :: "Start/Autoinit, Pause(START)"
        prop JSName :: "dmaPrictlStart"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.START_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst SRCDIR_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Source Address Modification(SRC DIR)"
        prop JSName :: "dmaPrictlSrcDir"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (self.SRCDIR_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst DSTDIR_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Destination Address Modification(DST DIR)"
        prop JSName :: "dmaPrictlDstDir"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (self.DSTDIR_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst ESIZE_SETUP :: "32-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit,16-bit,8-bit"
        prop Label :: "Element Size(ESIZE)"
        prop JSName :: "dmaPrictlEsize"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.ESIZE_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst SPLIT_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Global Address Register A,Global Address Register B,Global Address Register C"
        prop Label :: "Split Channel Mode(SPLIT)"
        prop JSName :: "dmaPrictlSplit"
        prop Visible :: 1
        prop Writable :: if ((CSL.DMA_SUPPORT != 0) && (self.RSYNC_SETUP == "None") || (self.WSYNC_SETUP == "None")) {0} else {1}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.SPLIT_SETUP = $1, if ((self.RSYNC_SETUP == "None") || (self.WSYNC_SETUP == "None") && (self.SPLIT_SETUP != "Disable")) {self.SPLIT_SETUP = "Disable"} , self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst CNTRLD_SETUP :: "Count Reload Reg A" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Count Reload Reg A,Count Reload Reg B"
        prop Label :: "Transfer Count Reload(CNT RELOAD)"
        prop JSName :: "dmaPrictlCntReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (self.CNTRLD_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst INDEX_SETUP :: "Global Index Register A" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Global Index Register A,Global Index Register B"
        prop Label :: "Select Programmable Index(INDEX)"
        prop JSName :: "dmaPrictlIndex"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (self.INDEX_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst RSYNC_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Timer 0 Interrupt,Timer 1 Interrupt,EMIF Timer Interrupt,External Interrupt Pin 4,External Interrupt Pin 5,External Interrupt Pin 6,External Interrupt Pin 7,DMA Channel 0 Interrupt,DMA Channel 1 Interrupt,DMA Channel 2 Interrupt,DMA Channel 3 Interrupt,McBSP 0 Transmit Event,McBSP 0 Receive Event,McBSP 1 Transmit Event,McBSP 1 Receive Event,Host to DSP Interrupt,McBSP 2 Transmit Event,McBSP 2 Receive Event"
        prop Label :: "Read Transfer Sync(RSYNC)"
        prop JSName :: "dmaPrictlRsync"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.RSYNC_SETUP = $1, if ((self.RSYNC_SETUP == "None") && (self.SPLIT_SETUP != "Disable")) {self.SPLIT_SETUP = "Disable"} , self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst WSYNC_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Timer 0 Interrupt,Timer 1 Interrupt,EMIF Timer Interrupt,External Interrupt Pin 4,External Interrupt Pin 5,External Interrupt Pin 6,External Interrupt Pin 7,DMA Channel 0 Interrupt,DMA Channel 1 Interrupt,DMA Channel 2 Interrupt,DMA Channel 3 Interrupt,McBSP 0 Transmit Event,McBSP 0 Receive Event,McBSP 1 Transmit Event,McBSP 1 Receive Event,Host to DSP Interrupt,McBSP 2 Transmit Event,McBSP 2 Receive Event"
        prop Label :: "Write Transfer Sync(WSYNC)"
        prop JSName :: "dmaPrictlWsync"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.WSYNC_SETUP = $1, if ((self.FS_SETUP == "RSYNC") && (self.WSYNC_SETUP != "None")) {self.WSYNC_SETUP = "None"} , if ((self.WSYNC_SETUP == "None") && (self.SPLIT_SETUP != "Disable")) {self.SPLIT_SETUP = "Disable"} , self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst PRI_SETUP :: "CPU" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CPU,DMA"
        prop Label :: "Priority Mode(PRI)"
        prop JSName :: "dmaPrictlPri"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.PRI_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst TCINT_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Transfer Controller Interrupt(TCINT)"
        prop JSName :: "dmaPrictlTcint"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.TCINT_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst FS_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,RSYNC"
        prop Label :: "Frame Sync(FS)"
        prop JSName :: "dmaPrictlFs"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.FS_SETUP = $1, if (self.FS_SETUP == "RSYNC") {self.WSYNC_SETUP = "None", self.SPLIT_SETUP = "Disable"} , self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst EMOD_SETUP :: "Continue" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Continue,Pause"
        prop Label :: "Emulation Mode(EMOD)"
        prop JSName :: "dmaPrictlEmod"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.EMOD_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst SRCRLD_SETUP :: "No Reload" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Reload,Global Address Register B,Global Address Register C,Global Address Register D"
        prop Label :: "Src. Addr. Reload(SRC RELOAD)"
        prop JSName :: "dmaPrictlSrcReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (self.SRCRLD_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst DSTRLD_SETUP :: "No Reload" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Reload,Global Address Register B,Global Address Register C,Global Address Register D"
        prop Label :: "Dst. Addr. Reload(DST RELOAD)"
        prop JSName :: "dmaPrictlDstReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (self.DSTRLD_SETUP = $1, self.PRICTL_VALUE = self.PRICTL_VALUE_update(), "ok")
    }
    inst SXCOND_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Split Transmit Overrun Receive Condition(SX COND)"
        prop JSName :: "dmaSecctlSxCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (self.SXCOND_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst FRAMECOND_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Frame Complete Condition(FRAME COND)"
        prop JSName :: "dmaSecctlFrameCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (self.FRAMECOND_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst LASTCOND_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Last Frame Condition(LAST COND)"
        prop JSName :: "dmaSecctlLastCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (self.LASTCOND_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst BLOCKCOND_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Block Transfer Finished Condition(BLOCK COND)"
        prop JSName :: "dmaSecctlBlockCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (self.BLOCKCOND_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst RDROPCOND_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Dropped Read Synchronization Condition(RDROP COND)"
        prop JSName :: "dmaSecctlRdropCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (self.RDROPCOND_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst WDROPCOND_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Dropped Write Synchronization Condition(RDROP COND)"
        prop JSName :: "dmaSecctlWdropCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (self.WDROPCOND_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst SXIE_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Split Transmit Overrun Receive IE(SX IE)"
        prop JSName :: "dmaSecctlSxIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.SXIE_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst FRAMEIE_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Frame Complete IE(FRAME IE)"
        prop JSName :: "dmaSecctlFrameIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.FRAMEIE_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst LASTIE_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Last Frame IE(LAST IE)"
        prop JSName :: "dmaSecctlLastIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.LASTIE_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst BLOCKIE_SETUP :: "Enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
        prop Label :: "Block Transfer Finished IE(BLOCK IE)"
        prop JSName :: "dmaSecctlBlockIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.BLOCKIE_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst RDROPIE_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Dropped Read Synchronization IE(RDROP IE)"
        prop JSName :: "dmaSecctlRdropIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.RDROPIE_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst WDROPIE_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Dropped Write Synchronization IE(WDROP IE)"
        prop JSName :: "dmaSecctlWdropIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (self.WDROPIE_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst RSYNCSTAT_SETUP :: "Not Received" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not Received,Received"
        prop Label :: "Read Sync Status(RSYNC STAT)"
        prop JSName :: "dmaSecctlRsyncStat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.RSYNCSTAT_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst WSYNCSTAT_SETUP :: "Not Received" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not Received,Received"
        prop Label :: "Write Sync Status(WSYNC STAT)"
        prop JSName :: "dmaSecctlWsyncStat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.WSYNCSTAT_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst RSYNCCLR_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Clear"
        prop Label :: "Read Sync Status Clear(RSYNC CLR)"
        prop JSName :: "dmaSecctlRsyncClr"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.RSYNCCLR_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst WSYNCCLR_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Clear"
        prop Label :: "Write Sync Status Clear(WSYNC CLR)"
        prop JSName :: "dmaSecctlWsyncClr"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.WSYNCCLR_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst DMACEN_SETUP :: "Low" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,High,RSYNC STAT,WSYNC STAT,FRAME COND,BLOCK COND"
        prop Label :: "DMA Action Complete(DMAC EN)"
        prop JSName :: "dmaSecctlDmacEn"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.DMACEN_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst FSIG_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Ignore"
        prop Label :: "Frame Sync Ignore(FSIG, C6202 only)"
        prop JSName :: "dmaSecctlFsig"
        prop Visible :: 1
        prop Writable :: (if (CSL.DMA_SUPPORT != 0) && (CSL.CHIP_6202 == 1) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.FSIG_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst RSPOL_SETUP :: = "Active Low" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active Low,Active High"
        prop Label :: "Read Sync Event Polarity(RSPOL, C6202 only)"
        prop JSName :: "dmaSecctlRspol"
        prop Visible :: 1
        prop Writable :: (if (CSL.DMA_SUPPORT != 0) && (CSL.CHIP_6202 == 1) && ((self.RSYNC_SETUP == "External Interrupt Pin 4") || (self.RSYNC_SETUP == "External Interrupt Pin 5") || (self.RSYNC_SETUP == "External Interrupt Pin 6") || (self.RSYNC_SETUP == "External Interrupt Pin 7")) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.RSPOL_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst WSPOL_SETUP :: = "Active Low" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active Low,Active High"
        prop Label :: "Write Sync Event Polarity(WSPOL, C6202 only)"
        prop JSName :: "dmaSecctlWspol"
        prop Visible :: 1
        prop Writable :: (if (CSL.DMA_SUPPORT != 0) && (CSL.CHIP_6202 == 1) && ((self.WSYNC_SETUP == "External Interrupt Pin 4") || (self.WSYNC_SETUP == "External Interrupt Pin 5") || (self.WSYNC_SETUP == "External Interrupt Pin 6") || (self.WSYNC_SETUP == "External Interrupt Pin 7")) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (self.WSPOL_SETUP = $1, self.SECCTL_VALUE = self.SECCTL_VALUE_update(), "ok")
    }
    inst SRCADDR_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label :: "Source Address Format"
        prop JSName :: "dmaSrcAddrFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.SRCADDR_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.SRCADDR_FORMAT = "Numeric", self.error("You must enter a Header file name - See CSL extern Declaration")} else {self.SRCADDR_FORMAT = $1, self.SRCADDR_FORMAT_ADV = self.SRCADDR_FORMAT, if ($1 == "Numeric") {self.SRCADDR_SYM = "NULL", self.SRCADDR_HANDLE = "NULL", self.SRCADDR_HEADER = "NULL"} , if ($1 == "User's Header file") {self.SRCADDR_HANDLE = "NULL", self.SRCADDR_SYM = "NULL"} , if ($1 == "Extern Decl. Obj.") {self.SRCADDR_HANDLE = "NULL", self.SRCADDR_HEADER = "NULL"} , if ($1 == "McBSP handle (DRR)") {self.SRCADDR_SYM = "NULL", self.SRCADDR_HEADER = "NULL"} , "ok"}})
    }
    inst SRCADDR_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Source Address - Numeric "
        prop JSName :: "dmaSrcAddrNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.SRCADDR_NUM = $1, self.SRCADDR_NUM_VALUE = self.SRCADDR_NUM, self.SRCADDR_HANDLE = "NULL", self.SRCADDR_HEADER = "NULL", self.SRCADDR_HEADER_VALUE = self.SRCADDR_HEADER, self.SRCADDR_SYM = "NULL", self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok"})
    }
    inst SRCADDR_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Src Addr - Extern Decl. Symbol name "
        prop JSName :: "dmaSrcAddrSymbol"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT == "Extern Decl. Obj."
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.DSTADDR_SYM) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Address  Not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.SRCADDR_SYM = $1, self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok"}}})
    }
    inst SRCADDR_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Src Addr - Enter full address "
        prop JSName :: "dmaSrcAddrFull"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT == "User's Header file"
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRCADDR_HEADER = $1, self.SRCADDR_HEADER_VALUE = self.SRCADDR_HEADER, "ok")
    }
    inst SRCADDR_HANDLE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Src Addr - Enter Handle Name "
        prop JSName :: "dmaSrcAddrHandle"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT == "McBSP handle (DRR)"
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ($a = 0, $c = 0, scan ($b; hMcbsp) {if ($1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1) {$a = 1} }, if ($a == 0) {self.error("Handle object Name has to be declared and defined (open)  - ")} else {self.SRCADDR_HANDLE = $1, "ok"})
    }
    inst DSTADDR :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Destination Address (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.DSTADDR = $1, self.DSTADDR_FORMAT = "Numeric", self.DSTADDR_FORMAT_ADV = self.DSTADDR_FORMAT, self.DSTADDR_NUM = self.DSTADDR, self.DSTADDR_NUM_VALUE = self.DSTADDR_NUM, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok"})
    }
    inst DSTADDR_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label :: "Dst Address Format"
        prop JSName :: "dmaDstAddrFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.DSTADDR_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL Extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.DSTADDR_FORMAT = "Numeric", self.error("You must enter a Header file name - See CSL Extern Declaration")} else {self.DSTADDR_FORMAT = $1, self.DSTADDR_FORMAT_ADV = $1, if ($1 == "Numeric") {self.DSTADDR_SYM = "NULL", self.DSTADDR_HANDLE = "NULL", self.DSTADDR_HEADER = "NULL"} , if ($1 == "User's Header file") {self.DSTADDR_HANDLE = "NULL", self.DSTADDR_SYM = "NULL"} , if ($1 == "Extern Decl. Obj.") {self.DSTADDR_HANDLE = "NULL", self.DSTADDR_HEADER = "NULL"} , if ($1 == "McBSP handle (DXR)") {self.DSTADDR_SYM = "NULL", self.DSTADDR_HEADER = "NULL"} , "ok"}})
    }
    inst DSTADDR_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Dst Addr - Enter Numeric value "
        prop JSName :: "dmaDstAddrNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.DSTADDR_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.DSTADDR_NUM = $1, self.DSTADDR_NUM_VALUE = self.DSTADDR_NUM, self.DSTADDR_HANDLE = "NULL", self.DSTADDR_HEADER = "NULL", self.DSTADDR_HEADER_VALUE = self.DSTADDR_HEADER, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok"})
    }
    inst DSTADDR_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Dst Addr - Extern Decl. Symbol Name "
        prop JSName :: "dmaDstAddrSymbol"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.DSTADDR_FORMAT == "Extern Decl. Obj."
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.SRCADDR_SYM) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Address  Not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.DSTADDR_SYM = $1, self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok"}}})
    }
    inst DSTADDR_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Dst Addr - Enter full address "
        prop JSName :: "dmaDstAddrFull"
        prop Visible :: 1
        prop Writable :: (CSL.DMA_SUPPORT && self.DSTADDR_FORMAT == "User's Header file")
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DSTADDR_HEADER = $1, self.DSTADDR_NUM_VALUE = 0x00000000, self.DSTADDR_HEADER_VALUE = self.DSTADDR_HEADER, "ok")
    }
    inst DSTADDR_HANDLE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Dst Addr - Enter Handle Name "
        prop JSName :: "dmaDstAddrHandle"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.DSTADDR_FORMAT == "McBSP handle (DXR)"
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ($a = 0, $c = 0, scan ($b; hMcbsp) {if ($1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1) {$a = 1} }, if ($a == 0) {self.error("Handle object Name has to be declared and defined (open)  - ")} else {self.DSTADDR_HANDLE = $1, "ok"})
    }
    inst FRAMECNT :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Count"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (if (($1 > 0x65535) | ($1 < 0)) {self.error("Invalid Number")} else {self.FRAMECNT = $1, self.FRAMECNT_NUM = $1, self.FRAMECNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0x0000FFFF, self.XFRCNT_NUM_VALUE |= (self.FRAMECNT_NUM << 16), "ok"})
    }
    inst ELMCNT :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Count"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (if (($1 > 65535) | ($1 < 0)) {self.error("Invalid Number")} else {self.ELMCNT = $1, self.ELMCNT_NUM = $1, self.ELMCNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0xFFFF0000, self.XFRCNT_NUM_VALUE |= self.ELMCNT_NUM, "ok"})
    }
    inst XFRCNT_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label :: " Transfer Counter Format"
        prop JSName :: "dmaXfrcntFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.XFRCNT_FORMAT = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {self.XFRCNT_FORMAT = $1, self.XFRCNT_FORMAT_ADV = self.XFRCNT_FORMAT, if ($1 == "Numeric") {self.ELMCNT_HEADER = "NULL", self.FRAMECNT_HEADER = "NULL"} else {self.FRAMECNT_NUM = 0x0000, self.ELMCNT_NUM = 0x0000, self.XFRCNT_NUM_VALUE = 0x00000000}, "ok"})
    }
    inst FRAMECNT_NUM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "   Frame Count(FC) - Enter 16-bit value"
        prop JSName :: "dmaXfrcntFrameCountNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.XFRCNT_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (if (($1 > 65535) || ($1 < 0)) {self.error("Invalid Number [0..65535]")} else {self.FRAMECNT_NUM = $1, self.FRAMECNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0x0000FFFF, self.XFRCNT_NUM_VALUE |= (self.FRAMECNT_NUM << 16), "ok"})
    }
    inst FRAMECNT_HEADER :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Frame Count(FC) - Enter Num or Symbol value  "
        prop JSName :: "dmaXfrcntFrameCountSymbol"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.XFRCNT_FORMAT != "Numeric"
        prop NoGen :: 1
        prop TabName :: "Count/Index"
        prop Set :: (self.FRAMECNT_HEADER = $1, self.FRAMECNT_NUM = 0x0000, self.XFRCNT_NUM_VALUE = (self.XFRCNT_NUM_VALUE & 0x0000FFFF), "ok")
    }
    inst ELMCNT_NUM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "   Elt Counter (EC) - Enter 16-bit value"
        prop JSName :: "dmaXfrcntElementCountNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.XFRCNT_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (if (($1 > 65535) || ($1 < 0)) {self.error("Invalid Number [0..65535]")} else {self.ELMCNT_NUM = $1, self.ELMCNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0xFFFF0000, self.XFRCNT_NUM_VALUE |= self.ELMCNT_NUM, "ok"})
    }
    inst ELMCNT_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    Elt Count(EC) - Enter  Num or Sym value "
        prop JSName :: "dmaXfrcntElementCountSymbol"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.XFRCNT_FORMAT != "Numeric"
        prop NoGen :: 1
        prop TabName :: "Count/Index"
        prop Set :: (self.ELMCNT_HEADER = $1, self.ELMCNT_NUM = 0x0000, self.XFRCNT_NUM_VALUE = ((self.XFRCNT_NUM_VALUE & 0xFFFF0000)), "ok")
    }
    inst PRICTL_VALUE :: self.PRICTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Primary Control Register"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaPrictl"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x04000000, $b = $1 & 0x00F80000, $c = $1 & 0x0007C000, $d = $1 & 0x00000C00, if (($a != 0) && ($b != 0)) {self.error("Conflict Setting between FS(bit26) and WSYNC(bit[19..24])")} else {if (($c == 0) && ($d != 0)) {self.error("Conflict Setting between SPLIT(bit[10..11]) and RSYNC(bit[14..18])")} else {if (($b == 0) && ($d != 0)) {self.error("Conflict Setting between SPLIT(bit[10..11]) and WSYNC(bit[19..24])")} else {if (($1 & 0x00000300) == 0x00000300) {self.error("No such option for bit field ESIZE(bit[8..9])")} else {if (($1 & 0x0000000C) != 0) {self.error("Bit field STATUS(bit[2..3]) is reserved")} else {if (($1 & 0x00F80000) > 0x00900000) {self.error("No such option for bit field WSYNC(bit[19..24])")} else {if (($1 & 0x0007C000) > 0x00048000) {self.error("No such option for bit field RSYNC(bit[14..18])")} else {self.PRICTL_VALUE = $1, self.PRICTL_SETUP_update($1), "ok"}}}}}}})
    }
    inst SECCTL_VALUE :: self.SECCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Secondary Control Register"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaSecctl"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFF80000, $b = $1 & 0xFFC00000, $c = $1 & 0x00070000, if (($a != 0) && (GBL.DSPSUBTYPE != 6700)) {self.error("Bit field(bit[19..31]) is reserved")} else {if (($b != 0) && (GBL_CHIPTYPE == "6211")) {self.error("Bit field(bit[22..31]) is reserved")} else {if ($c > 0x00050000) {self.error("No such option for bit field DMAC EN(bit[16..18])")} else {if ((($1 & 0x00100000) == 0x00100000) && ((self.RSYNC_PRICTL < 0x00200000) || (self.RSYNC_PRICTL > 0x00380000))) {self.error("Bit field RSPOL(bit20) only valid if EXT_INTx is selected")} else {if ((($1 & 0x00200000) == 0x00200000) && ((self.WSYNC_PRICTL < 0x00010000) || (self.WSYNC_PRICTL > 0x0001C000))) {self.error("Bit field WSPOL(bit21) only valid if EXT_INTx is selected")} else {self.SECCTL_VALUE = $1, self.SECCTL_SETUP_update($1), "ok"}}}}})
    }
    inst SRCADDR_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Address (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SRCADDR_VALUE = $1, self.SRCADDR_FORMAT = "Numeric", self.SRCADDR_FORMAT_ADV = self.SRCADDR_FORMAT, self.SRCADDR_NUM = self.SRCADDR_VALUE, self.SRCADDR_NUM_VALUE = self.SRCADDR_NUM, self.SRCADDR_SYM = "NULL", self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok")
    }
    inst SRCADDR_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label :: "Source Address Format"
        prop JSName :: "dmaSrcAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.SRCADDR_FORMAT_ADV = "Numeric", self.error("You must create a Symbolic object - See CSL extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.SRCADDR_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL extern Declartion")} else {self.SRCADDR_FORMAT_ADV = $1, self.SRCADDR_FORMAT = $1, if ($1 == "Numeric") {self.SRCADDR_SYM_VALUE = "NULL"} else {self.SRCADDR_NUM_VALUE = 0x00000000}, "ok"}})
    }
    inst SRCADDR_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Address - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaSrcAddrNumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && (self.SRCADDR_FORMAT_ADV == "Numeric" || self.SRCADDR_FORMAT_ADV == "McBSP handle (DRR)" || (self.SRCADDR_FORMAT_ADV == "User's Header file" && self.SRCADDR_HEADER_VALUE == "NULL") || (self.SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && self.SRCADDR_SYM_VALUE == "NULL"))
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SRCADDR_NUM_VALUE = $1, self.SRCADDR_NUM = $1, "ok")
    }
    inst SRCADDR_SYM_VALUE :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Source Address - Extern Decl.Obj"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && self.SRCADDR_SYM_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.SRCADDR_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.DSTADDR_SYM_VALUE) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Address  Not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.SRCADDR_SYM = $1, self.SRCADDR_SYM_VALUE = $1, "ok"}}})
    }
    inst SRCADDR_HEADER_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Source Address - From User's Header File"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.SRCADDR_FORMAT_ADV == "User's Header file" && self.SRCADDR_HEADER_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ("(Uint32) ")
    }
    inst DSTADDR_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Address (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.DSTADDR_VALUE = $1, self.DSTADDR_FORMAT = "Numeric", self.DSTADDR_FORMAT_ADV = self.DSTADDR_FORMAT, self.DSTADDR_NUM = self.DSTADDR_VALUE, self.DSTADDR_NUM_VALUE = self.DSTADDR_NUM, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok")
    }
    inst DSTADDR_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label :: "Destination Address Format"
        prop JSName :: "dmaDstAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.DSTADDR_FORMAT_ADV = "Numeric", self.error("You must create a Symbolic Object - See CSL extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.DSTADDR_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL extern Declartion")} else {self.DSTADDR_FORMAT_ADV = $1, self.DSTADDR_FORMAT = $1, if ($1 == "Numeric") {self.DSTADDR_SYM_VALUE = "NULL"} else {self.DSTADDR_NUM_VALUE = 0x00000000}, "ok"}})
    }
    inst DSTADDR_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Address - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaDstAddrNumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.DSTADDR_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && (self.DSTADDR_FORMAT_ADV == "Numeric" || self.DSTADDR_FORMAT_ADV == "McBSP handle (DXR)" || (self.DSTADDR_FORMAT_ADV == "User's Header file" && self.DSTADDR_HEADER_VALUE == "NULL") || (self.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && self.DSTADDR_SYM_VALUE == "NULL"))
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.DSTADDR_NUM_VALUE = $1, self.DSTADDR_NUM = $1, self.DSTADDR_HANDLE = "NULL", self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, self.DSTADDR_HEADER = "NULL", self.DSTADDR_HEADER_VALUE = self.DSTADDR_HEADER, "ok")
    }
    inst DSTADDR_SYM_VALUE :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Destination Address - Extern Decl. Obj"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && (self.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && self.DSTADDR_SYM_VALUE != "NULL")
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.DSTADDR_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.SRCADDR_SYM_VALUE) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Address  Not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.DSTADDR_SYM = $1, self.DSTADDR_SYM_VALUE = $1, "ok"}}})
    }
    inst DSTADDR_HEADER_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Destination Address - From User's Header file"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.DSTADDR_FORMAT_ADV == "User's Header file" && self.DSTADDR_HEADER_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ("(Uint32) ")
    }
    inst XFRCNT_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label :: "Transfer Counter Format"
        prop JSName :: "dmaXfrcntFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.XFRCNT_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {if ($1 == "Numeric") {self.ELMCNT_HEADER = "NULL", self.FRAMECNT_HEADER = "NULL"} else {self.XFRCNT_NUM_VALUE = 0x00000001, self.ELMCNT_NUM = 0x0001, self.FRAMECNT_NUM = 0x0000}, self.XFRCNT_FORMAT_ADV = $1, self.XFRCNT_FORMAT = self.XFRCNT_FORMAT_ADV, "ok"})
    }
    inst XFRCNT_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Counter Register"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XFRCNT_VALUE = $1, self.XFRCNT_NUM_VALUE = $1, self.FRAMECNT_NUM = $1 >> 16, self.ELMCNT_NUM = ($1 & 0x0000FFFF), "ok")
    }
    inst XFRCNT_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Counter - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaXfrcnt"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.XFRCNT_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XFRCNT_NUM_VALUE = $1, self.FRAMECNT_NUM = $1 >> 16, self.ELMCNT_NUM = ($1 & 0x0000FFFF), "ok")
    }
}

type hDma {
    isa ObjectMgr
    prop name :: "hDma"
    prop Label :: "DMA Resource Manager"
    prop JSName :: "HDMA"
    prop IsContainedIn :: DMAFOLDER
    prop GlobalPropertyPage :: "{1E62DD10-59A8-11d4-947D-0050048381B7}"
    prop InstancePropertyPage :: "{1E62DD11-59A8-11d4-947D-0050048381B7}"
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalHelpTopic :: 1022
    prop InstanceHelpTopic :: 1023
    prop maxObjs :: 4
    prop NoGen :: 1
    prop cGen :: CSL.DMA_SUPPORT
    prop cHandle :: self.cOpenGen
    prop cHeaderName :: ($a = "", scan ($b; hDma) {if ($b.DMA_HANDLE_ENABLE == 1) {$a = "csl_dma.h"} }, $a)
    prop cHandleType :: "DMA_Handle"
    prop cOpenName :: "DMA_open"
    prop cConfigName :: "DMA_config"
    prop cHandleName :: self.HandleName
    prop cStructQual :: "far"
    prop localCanCreate :: (self.error("New DMA handle objects cannot be created"))
    prop localCanDelete :: (self.error("DMA handle objects cannot be deleted"))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 4 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst DEVICE :: "DMACHA0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DMACHA0,DMACHA1,DMACHA2,DMACHA3"
        prop Label :: "DMA channel"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
    }
    inst cOpenGen :: = ((self.DMA_HANDLE_ENABLE != 0) && (CSL.DMA_SUPPORT != 0) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Handle"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst cOpenArg0 :: "DMA_CHAANY" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 0"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "DMA_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 1"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
    }
    inst DMA_HANDLE_ENABLE :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open DMA Channel"
        prop JSName :: "dmaHandleEnable"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.DMA_HANDLE_ENABLE = $1, if ($1 == 0) {self.DMA_HANDLE_ENABLE = $1, self.PINIT_ENABLE = $1, self.cOpenArg0 = "DMA_None", self.PINIT = DMA_NOTHING, "ok"} else {if (self.DEVICE == "DMACHA0") {self.cOpenArg0 = "DMA_CHA0", "ok"} else {if (self.DEVICE == "DMACHA1") {self.cOpenArg0 = "DMA_CHA1", "ok"} else {if (self.DEVICE == "DMACHA2") {self.cOpenArg0 = "DMA_CHA2", "ok"} else {if (self.DEVICE == "DMACHA3") {self.cOpenArg0 = "DMA_CHA3", "ok"} }}}})
    }
    inst HandleName :: = self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Handle"
        prop JSName :: "dmaHandleName"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT & self.DMA_HANDLE_ENABLE
    }
    inst PINIT_ENABLE :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "dmaEnablePreInit"
        prop Visible :: 1
        prop Writable :: if ((CSL.DMA_SUPPORT != 0) && (self.DMA_HANDLE_ENABLE != 0)) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; dmaCfg) {$a += 1}, if ($a == 1) {self.PINIT_ENABLE = 0, self.error("You must create a DMA configuration object first")} else {self.PINIT_ENABLE = $1, if ($1 == 0) {self.PINIT = DMA_NOTHING} , "ok"})
    }
    inst PINIT :: DMA_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: dmaCfg
        prop Label :: "Pre-Initialize with"
        prop JSName :: "dmaPreInit"
        prop Visible :: 1
        prop Writable :: (CSL.DMA_SUPPORT != 0) & (self.PINIT_ENABLE == 1) & (self.DMA_HANDLE_ENABLE != 0)
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((CSL.DMA_SUPPORT != 0) && (self.DMA_HANDLE_ENABLE == 1) && (self.HandleName != "") && (self.PINIT_ENABLE == 1) && (self.PINIT != DMA_NOTHING) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Configuration"
        prop Visible :: 0
        prop Writable :: if (CSL.DMA_SUPPORT != 0) & (self.cConfigGen == 1) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst cConfigArg0 :: = self.cHandleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
        prop Writable :: if (CSL.DMA_SUPPORT != 0) & (self.cConfigGen == 1) {1} else {0}
        prop Set :: (self.cConfigArg0 = self.HandleName, "ok")
    }
    inst cConfigArg1 :: = self.PINIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 1"
        prop Visible :: 0
        prop Writable :: if (CSL.DMA_SUPPORT != 0) & (self.cConfigGen == 1) {1} else {0}
        prop cPreVal :: "&"
    }
}

object DMA_Channel0 :: hDma {
    param iComment :: "DMA channel 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDma"
    param iDelMsg :: "This DMA Handle object cannot be deleted"
    param DEVICE :: "DMACHA0"
    param cOpenArg0 :: "DMA_CHAANY"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param HandleName :: "hDma0"
    param PINIT :: DMA_NOTHING
}

object DMA_Channel1 :: hDma {
    param iComment :: "DMA channel 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDma"
    param iDelMsg :: "This DMA Handle object cannot be deleted"
    param DEVICE :: "DMACHA1"
    param cOpenArg0 :: "DMA_CHAANY"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param HandleName :: "hDma1"
    param PINIT :: DMA_NOTHING
}

object DMA_Channel2 :: hDma {
    param iComment :: "DMA channel 2"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDma"
    param iDelMsg :: "This DMA Handle object cannot be deleted"
    param DEVICE :: "DMACHA2"
    param cOpenArg0 :: "DMA_CHAANY"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param HandleName :: "hDma2"
    param PINIT :: DMA_NOTHING
}

object DMA_Channel3 :: hDma {
    param iComment :: "DMA channel 3"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDma"
    param iDelMsg :: "This DMA Handle object cannot be deleted"
    param DEVICE :: "DMACHA3"
    param cOpenArg0 :: "DMA_CHAANY"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param HandleName :: "hDma3"
    param PINIT :: DMA_NOTHING
}

object DMA_NOTHING :: dmaCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param START_SETUP :: "Stop"
    param SRCDIR_SETUP :: "None"
    param DSTDIR_SETUP :: "None"
    param ESIZE_SETUP :: "32-bit"
    param SPLIT_SETUP :: "Disable"
    param CNTRLD_SETUP :: "Count Reload Reg A"
    param INDEX_SETUP :: "Global Index Register A"
    param RSYNC_SETUP :: "None"
    param WSYNC_SETUP :: "None"
    param PRI_SETUP :: "CPU"
    param TCINT_SETUP :: "Disable"
    param FS_SETUP :: "Disable"
    param EMOD_SETUP :: "Continue"
    param SRCRLD_SETUP :: "No Reload"
    param DSTRLD_SETUP :: "No Reload"
    param SXCOND_SETUP :: "Clear"
    param FRAMECOND_SETUP :: "Clear"
    param LASTCOND_SETUP :: "Clear"
    param BLOCKCOND_SETUP :: "Clear"
    param RDROPCOND_SETUP :: "Clear"
    param WDROPCOND_SETUP :: "Clear"
    param SXIE_SETUP :: "Disable"
    param FRAMEIE_SETUP :: "Disable"
    param LASTIE_SETUP :: "Disable"
    param BLOCKIE_SETUP :: "Enable"
    param RDROPIE_SETUP :: "Disable"
    param WDROPIE_SETUP :: "Disable"
    param RSYNCSTAT_SETUP :: "Not Received"
    param WSYNCSTAT_SETUP :: "Not Received"
    param RSYNCCLR_SETUP :: "None"
    param WSYNCCLR_SETUP :: "None"
    param DMACEN_SETUP :: "Low"
    param FSIG_SETUP :: "None"
    param SRCADDR_FORMAT :: "Numeric"
    param SRCADDR_NUM :: 0
    param SRCADDR_SYM :: "NULL"
    param SRCADDR_HEADER :: "NULL"
    param SRCADDR_HANDLE :: "NULL"
    param DSTADDR :: 0
    param DSTADDR_FORMAT :: "Numeric"
    param DSTADDR_NUM :: 0
    param DSTADDR_SYM :: "NULL"
    param DSTADDR_HEADER :: "NULL"
    param DSTADDR_HANDLE :: "NULL"
    param FRAMECNT :: 0
    param ELMCNT :: 0
    param XFRCNT_FORMAT :: "Numeric"
    param FRAMECNT_NUM :: 0
    param ELMCNT_NUM :: 0
    param ELMCNT_HEADER :: "NULL"
    param PRICTL_VALUE :: 0
    param SECCTL_VALUE :: 128
    param SRCADDR_FORMAT_ADV :: "Numeric"
    param SRCADDR_HEADER_VALUE :: "NULL"
    param DSTADDR_FORMAT_ADV :: "Numeric"
    param DSTADDR_HEADER_VALUE :: "NULL"
    param XFRCNT_FORMAT_ADV :: "Numeric"
    param XFRCNT_VALUE :: 0
}

type dmaGblCfg {
    isa ObjectMgr
    prop name :: "dmaGblCfg"
    prop Label :: "DMA Global Register Manager"
    prop JSName :: "GDMA"
    prop IsContainedIn :: DMAFOLDER
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalHelpTopic :: 1024
    prop InstanceHelpTopic :: 1025
    prop NoGen :: 1
    prop cGen :: CSL.DMA_SUPPORT
    prop cHandleType :: "Uint32"
    prop cOpenName :: "DMA_globalAlloc"
    prop cConfigName :: "DMA_globalConfig"
    prop cHandleName :: self.HandleName
    prop cStruct :: CSL.DMA_SUPPORT
    prop cStructType :: "DMA_GlobalConfig"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_dma.h"} else {""}
    prop cStructQual :: "far"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; dmaGblCfg) {$a = $a + 1}, if ($a == 2) {self.PINIT_ENABLE = 0} , "ok")
    prop gblRegMask :: self.GBLREG_MASK
    prop pinitName :: self.PINIT
    prop cGenFxnPrologue :: (if (self.GBLREG_MASK != 0 && self.PINIT_ENABLE == 1) {"%5t%1s = %2s(0x%3x);\n%4s(%5s, &%6s);%0t\n\0, cHandleName, cOpenName, gblRegMask, cConfigName, cHandleName, pinitName"} else {if (self.GBLREG_MASK != 0) {"%5t%1s = %2s(0x%3x);%0t\n\0, cHandleName, cOpenName, gblRegMask"} else {if (self.PINIT_ENABLE == 1) {"%5t%1s(%2s, &%3s);%0t\n\0, cConfigName, cHandleName, pinitName"} else {""}}})
    prop cGenCEpilogue :: (if (self.GBLREG_MASK != 0) {"%1s %2s;\n\0, cHandleType, cHandleName"} else {""})
    prop cGenHEpilogue :: (if (self.GBLREG_MASK != 0) {"extern far %1s %2s;\n\0, cHandleType, cHandleName"} else {""})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GBLADDRA_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Address Reload Register A"
        prop JSName :: "DMA_PRE_ALLOC_GBLADDRA"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLADDRA_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFFE) | self.GBLADDRA_ALLOC, "ok")
    }
    global GBLADDRB_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Address Reload Register B"
        prop JSName :: "DMA_PRE_ALLOC_GBLADDRB"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLADDRB_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFFD) | (self.GBLADDRB_ALLOC << 1), "ok")
    }
    global GBLADDRC_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Address Reload Register C"
        prop JSName :: "DMA_PRE_ALLOC_GBLADDRC"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLADDRC_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFFB) | (self.GBLADDRC_ALLOC << 2), "ok")
    }
    global GBLADDRD_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Address Reload Register D"
        prop JSName :: "DMA_PRE_ALLOC_GBLADDRD"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLADDRD_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFF7) | (self.GBLADDRD_ALLOC << 3), "ok")
    }
    global GBLIDXA_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Index Register A"
        prop JSName :: "DMA_PRE_ALLOC_GBLIDXA"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLIDXA_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFEF) | (self.GBLIDXA_ALLOC << 4), "ok")
    }
    global GBLIDXB_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Index Register B"
        prop JSName :: "DMA_PRE_ALLOC_GBLIDXB"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLIDXB_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFDF) | (self.GBLIDXB_ALLOC << 5), "ok")
    }
    global GBLCNTA_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Count Reload Register A"
        prop JSName :: "DMA_PRE_ALLOC_GBLCNTA"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLCNTA_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFFBF) | (self.GBLCNTA_ALLOC << 6), "ok")
    }
    global GBLCNTB_ALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-allocation Global Count Reload Register B"
        prop JSName :: "DMA_PRE_ALLOC_GBLCNTB"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (self.GBLCNTB_ALLOC = $1, self.GBLREG_MASK = (self.GBLREG_MASK & 0xFFFFFF7F) | (self.GBLCNTB_ALLOC << 7), "ok")
    }
    global GBLREG_MASK :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Register Mask"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    global HandleName :: "dmaGblRegId" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DMA Global Register ID"
        prop JSName :: "DMA_HANDLE_NAME"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLREG_MASK
        prop Set :: (self.HandleName = $1, "ok")
    }
    global PINIT_ENABLE :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "DMA_ENABLE_PRE_INIT"
        prop Visible :: 1
        prop Writable :: ((self.GBLREG_MASK != 0) && (CSL.DMA_SUPPORT != 0))
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; dmaGblCfg) {$a += 1}, if ($a == 1) {self.PINIT_ENABLE = 0, self.error("You must create a global register configuration object first")} else {self.PINIT_ENABLE = $1, if ($1 == 0) {self.PINIT = DMAGBL_NOTHING} , "ok"})
    }
    global PINIT :: = DMAGBL_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: dmaGblCfg
        prop Label :: "Pre-Initialize with"
        prop JSName :: "DMA_PRE_INIT"
        prop Visible :: 1
        prop Writable :: (self.PINIT_ENABLE == 1) && (self.GBLREG_MASK != 0) && (CSL.DMA_SUPPORT != 0)
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst GBLADDRA :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Global Address Reload Register A (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRA = $1, self.GBLADDRA_FORMAT = "Numeric", self.GBLADDRA_FORMAT_ADV = self.GBLADDRA_FORMAT, self.GBLADDRA_NUM = self.GBLADDRA, self.GBLADDRA_NUM_VALUE = self.GBLADDRA_NUM, self.GBLADDRA_SYM = "NULL", self.GBLADDRA_SYM_VALUE = self.GBLADDRA_SYM, "ok"})
    }
    inst GBLADDRA_FORMAT :: = "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Register A Format"
        prop JSName :: "dmaGbladdrAFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Symbolic") {self.GBLADDRA_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL extern Declaration")} else {self.GBLADDRA_FORMAT = $1, self.GBLADDRA_FORMAT_ADV = $1, if ($1 == "Numeric") {self.GBLADDRA_SYM = "NULL"} , "ok"})
    }
    inst GBLADDRA_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "    Reload Register A - Numeric "
        prop JSName :: "dmaGbladdrANumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRA_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRA_NUM = $1, self.GBLADDRA_NUM_VALUE = self.GBLADDRA_NUM, "ok"})
    }
    inst GBLADDRA_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    Reload Register A - Symbolic "
        prop JSName :: "dmaGbladdrASymbolic"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRA_FORMAT == "Symbolic"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRA_SYM = $1, self.GBLADDRA_SYM_VALUE = self.GBLADDRA_SYM, "ok"}})
    }
    inst GBLADDRB :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Global Address Reload Register B (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRB = $1, self.GBLADDRB_FORMAT = "Numeric", self.GBLADDRB_FORMAT_ADV = self.GBLADDRB_FORMAT, self.GBLADDRB_NUM = self.GBLADDRB, self.GBLADDRB_NUM_VALUE = self.GBLADDRB_NUM, self.GBLADDRB_SYM = "NULL", self.GBLADDRB_SYM_VALUE = self.GBLADDRB_SYM, "ok"})
    }
    inst GBLADDRB_FORMAT :: = "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Register B Format"
        prop JSName :: "dmaGbladdrBFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Symbolic") {self.GBLADDRB_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL extern Declaration")} else {self.GBLADDRB_FORMAT = $1, self.GBLADDRB_FORMAT_ADV = $1, if ($1 == "Numeric") {self.GBLADDRB_SYM = "NULL"} , "ok"})
    }
    inst GBLADDRB_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "    Reload Register B - Numeric "
        prop JSName :: "dmaGbladdrBNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRB_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRB_NUM = $1, self.GBLADDRB_NUM_VALUE = self.GBLADDRB_NUM, "ok"})
    }
    inst GBLADDRB_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    Reload Register B - Symbolic "
        prop JSName :: "dmaGbladdrBSymbolic"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRB_FORMAT == "Symbolic"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRB_SYM = $1, self.GBLADDRB_SYM_VALUE = self.GBLADDRB_SYM, "ok"}})
    }
    inst GBLADDRC :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Global Address Reload Register C (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRC = $1, self.GBLADDRC_FORMAT = "Numeric", self.GBLADDRC_FORMAT_ADV = self.GBLADDRC_FORMAT, self.GBLADDRC_NUM = self.GBLADDRC, self.GBLADDRC_NUM_VALUE = self.GBLADDRC_NUM, self.GBLADDRC_SYM = "NULL", self.GBLADDRC_SYM_VALUE = self.GBLADDRC_SYM, "ok"})
    }
    inst GBLADDRC_FORMAT :: = "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Register C Format"
        prop JSName :: "dmaGbladdrCFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Symbolic") {self.GBLADDRC_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL extern Declaration")} else {self.GBLADDRC_FORMAT = $1, self.GBLADDRC_FORMAT_ADV = $1, if ($1 == "Numeric") {self.GBLADDRC_SYM = "NULL"} , "ok"})
    }
    inst GBLADDRC_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "    Reload Register C - Numeric "
        prop JSName :: "dmaGbladdrCNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRC_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRC_NUM = $1, self.GBLADDRC_NUM_VALUE = self.GBLADDRC_NUM, "ok"})
    }
    inst GBLADDRC_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    Reload Register C - Symbolic "
        prop JSName :: "dmaGbladdrCSymbolic"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRC_FORMAT == "Symbolic"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRC_SYM = $1, self.GBLADDRC_SYM_VALUE = self.GBLADDRC_SYM, "ok"}})
    }
    inst GBLADDRD :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Global Address Reload Register D (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRD = $1, self.GBLADDRD_FORMAT = "Numeric", self.GBLADDRD_FORMAT_ADV = self.GBLADDRD_FORMAT, self.GBLADDRD_NUM = self.GBLADDRD, self.GBLADDRD_NUM_VALUE = self.GBLADDRD_NUM, self.GBLADDRD_SYM = "NULL", self.GBLADDRD_SYM_VALUE = self.GBLADDRD_SYM, "ok"})
    }
    inst GBLADDRD_FORMAT :: = "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Register D Format"
        prop JSName :: "dmaGbladdrDFormat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Symbolic") {self.GBLADDRD_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL extern Declaration")} else {self.GBLADDRD_FORMAT = $1, self.GBLADDRD_FORMAT_ADV = $1, if ($1 == "Numeric") {self.GBLADDRD_SYM = "NULL"} , "ok"})
    }
    inst GBLADDRD_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "    Reload Register D - Numeric "
        prop JSName :: "dmaGbladdrDNumeric"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRD_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.GBLADDRD_NUM = $1, self.GBLADDRD_NUM_VALUE = self.GBLADDRD_NUM, "ok"})
    }
    inst GBLADDRD_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    Reload Register D - Symbolic "
        prop JSName :: "dmaGbladdrDSymbolic"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRD_FORMAT == "Symbolic"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRD_SYM = $1, self.GBLADDRD_SYM_VALUE = self.GBLADDRD_SYM, "ok"}})
    }
    inst IDXA_FRAME :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Index for Index Register A"
        prop JSName :: "dmaGblidxAFrameIndex"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
        prop Set :: (if (($1 > 32767) | ($1 < -32768)) {self.error("Invalid Number, [-32768..32767]")} else {self.IDXA_FRAME = $1, self.IDXA_VALUE &= 0x0000FFFF, self.IDXA_VALUE |= ((self.IDXA_FRAME & 0xFFFF) << 16), "ok"})
    }
    inst IDXA_ELM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Index for Index Register A"
        prop JSName :: "dmaGblidxAElementIndex"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
        prop Set :: (if (($1 > 32767) | ($1 < -32768)) {self.error("Invalid Number, [-32768..32767]")} else {self.IDXA_ELM = $1, self.IDXA_VALUE &= 0xFFFF0000, self.IDXA_VALUE |= (self.IDXA_ELM & 0xFFFF), "ok"})
    }
    inst IDXB_FRAME :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Index for Index Register B"
        prop JSName :: "dmaGblidxBFrameIndex"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
        prop Set :: (if (($1 > 32767) | ($1 < -32768)) {self.error("Invalid Number, [-32768..32767]")} else {self.IDXB_FRAME = $1, self.IDXB_VALUE &= 0x0000FFFF, self.IDXB_VALUE |= ((self.IDXB_FRAME & 0xFFFF) << 16), "ok"})
    }
    inst IDXB_ELM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Index for Index Register B"
        prop JSName :: "dmaGblidxBElementIndex"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
        prop Set :: (if (($1 > 32767) | ($1 < -32768)) {self.error("Invalid Number, [-32768..32767]")} else {self.IDXB_ELM = $1, self.IDXB_VALUE &= 0xFFFF0000, self.IDXB_VALUE |= self.IDXB_ELM & 0xFFFF, "ok"})
    }
    inst CNTA_FRAME :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Count for Global Count Reload Register A"
        prop JSName :: "dmaGblcntAFrameCountReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
        prop Set :: (if (($1 > 0x65535) | ($1 < 0)) {self.error("Invalid Number, [0..65535]")} else {self.CNTA_FRAME = $1, self.CNTA_VALUE &= 0x0000FFFF, self.CNTA_VALUE |= (self.CNTA_FRAME << 16), "ok"})
    }
    inst CNTA_ELM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Count for Global Count Reload Register A"
        prop JSName :: "dmaGblcntAElementCountReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
        prop Set :: (if (($1 > 65535) | ($1 < 0)) {self.error("Invalid Number, [0..65535]")} else {self.CNTA_ELM = $1, self.CNTA_VALUE &= 0xFFFF0000, self.CNTA_VALUE |= self.CNTA_ELM, "ok"})
    }
    inst CNTB_FRAME :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Count for Global Count Reload Register B"
        prop JSName :: "dmaGblcntBFrameCountReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
        prop Set :: (if (($1 > 0x65535) | ($1 < 0)) {self.error("Invalid Number, [0..65535]")} else {self.CNTB_FRAME = $1, self.CNTB_VALUE &= 0x0000FFFF, self.CNTB_VALUE |= (self.CNTB_FRAME << 16), "ok"})
    }
    inst CNTB_ELM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Count for Global Count Reload Register B"
        prop JSName :: "dmaGblcntBElementCountReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
        prop Set :: (if (($1 > 65535) | ($1 < 0)) {self.error("Invalid Number, [0..65535]")} else {self.CNTB_ELM = $1, self.CNTB_VALUE &= 0xFFFF0000, self.CNTB_VALUE |= self.CNTB_ELM, "ok"})
    }
    inst GBLADDRA_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Address Reload Register A (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRA_VALUE = $1, self.GBLADDRA_FORMAT = "Numeric", self.GBLADDRA_FORMAT_ADV = self.GBLADDRA_FORMAT, self.GBLADDRA_NUM = self.GBLADDRA, self.GBLADDRA_NUM_VALUE = self.GBLADDRA_NUM, self.GBLADDRA_SYM = "NULL", self.GBLADDRA_SYM_VALUE = self.GBLADDRA_SYM, "ok")
    }
    inst GBLADDRA_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Reg A (GBLADDRA) Format"
        prop JSName :: "dmaGbladdrAFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRA_FORMAT_ADV = $1, self.GBLADDRA_FORMAT = $1, "ok")
    }
    inst GBLADDRA_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Reload Register A - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGbladdrANumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRA_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRA_FORMAT_ADV == "Numeric"
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRA_NUM_VALUE = $1, self.GBLADDRA_NUM = $1, "ok")
    }
    inst GBLADDRA_SYM_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reload Register A - Symbolic "
        prop JSName :: "dmaGbladdrASymbolicAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRA_FORMAT_ADV == "Symbolic"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRA_FORMAT_ADV == "Symbolic"
        prop TabName :: "Advanced"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.GBLADDRA_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRA_SYM = $1, self.GBLADDRA_SYM_VALUE = $1, "ok"}})
    }
    inst GBLADDRB_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Address Reload Register B (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRB_VALUE = $1, self.GBLADDRB_FORMAT = "Numeric", self.GBLADDRB_FORMAT_ADV = self.GBLADDRB_FORMAT, self.GBLADDRB_NUM = self.GBLADDRB, self.GBLADDRB_NUM_VALUE = self.GBLADDRB_NUM, self.GBLADDRB_SYM = "NULL", self.GBLADDRB_SYM_VALUE = self.GBLADDRB_SYM, "ok")
    }
    inst GBLADDRB_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Reg B (GBLADDRB) Format"
        prop JSName :: "dmaGbladdrBFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRB_FORMAT_ADV = $1, self.GBLADDRB_FORMAT = $1, "ok")
    }
    inst GBLADDRB_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Reload Register B - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGbladdrBNumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRB_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRB_FORMAT_ADV == "Numeric"
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRB_NUM_VALUE = $1, self.GBLADDRB_NUM = $1, "ok")
    }
    inst GBLADDRB_SYM_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reload Register B - Symbolic "
        prop JSName :: "dmaGbladdrBSymbolicAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRB_FORMAT_ADV == "Symbolic"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRB_FORMAT_ADV == "Symbolic"
        prop TabName :: "Advanced"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.GBLADDRB_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRB_SYM = $1, self.GBLADDRB_SYM_VALUE = $1, "ok"}})
    }
    inst GBLADDRC_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Address Reload Register C (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRC_VALUE = $1, self.GBLADDRC_FORMAT = "Numeric", self.GBLADDRC_FORMAT_ADV = self.GBLADDRC_FORMAT, self.GBLADDRC_NUM = self.GBLADDRC, self.GBLADDRC_NUM_VALUE = self.GBLADDRC_NUM, self.GBLADDRC_SYM = "NULL", self.GBLADDRC_SYM_VALUE = self.GBLADDRC_SYM, "ok")
    }
    inst GBLADDRC_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Reg C (GBLADDRC) Format"
        prop JSName :: "dmaGbladdrCFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRC_FORMAT_ADV = $1, self.GBLADDRC_FORMAT = $1, "ok")
    }
    inst GBLADDRC_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Reload Register C - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGbladdrCNumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRC_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRC_FORMAT_ADV == "Numeric"
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRC_NUM_VALUE = $1, self.GBLADDRC_NUM = $1, "ok")
    }
    inst GBLADDRC_SYM_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reload Register C - Symbolic "
        prop JSName :: "dmaGbladdrCSymbolicAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRC_FORMAT_ADV == "Symbolic"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRC_FORMAT_ADV == "Symbolic"
        prop TabName :: "Advanced"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.GBLADDRC_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRC_SYM = $1, self.GBLADDRC_SYM_VALUE = $1, "ok"}})
    }
    inst GBLADDRD_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Address Reload Register D (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRD_VALUE = $1, self.GBLADDRD_FORMAT = "Numeric", self.GBLADDRD_FORMAT_ADV = self.GBLADDRD_FORMAT, self.GBLADDRD_NUM = self.GBLADDRD, self.GBLADDRD_NUM_VALUE = self.GBLADDRD_NUM, self.GBLADDRD_SYM = "NULL", self.GBLADDRD_SYM_VALUE = self.GBLADDRD_SYM, "ok")
    }
    inst GBLADDRD_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label :: "Global Address Reload Reg D (GBLADDRD) Format"
        prop JSName :: "dmaGbladdrDFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRD_FORMAT_ADV = $1, self.GBLADDRD_FORMAT = $1, "ok")
    }
    inst GBLADDRD_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Reload Register D - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGbladdrDNumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRD_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRD_FORMAT_ADV == "Numeric"
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.GBLADDRD_NUM_VALUE = $1, self.GBLADDRD_NUM = $1, "ok")
    }
    inst GBLADDRD_SYM_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reload Register D - Symbolic "
        prop JSName :: "dmaGbladdrDSymbolicAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && self.GBLADDRD_FORMAT_ADV == "Symbolic"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && self.GBLADDRD_FORMAT_ADV == "Symbolic"
        prop TabName :: "Advanced"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.GBLADDRD_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {$a = 2}} }, if ($a == 0) {self.error("Symbolic Address Not declared - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {self.GBLADDRD_SYM = $1, self.GBLADDRD_SYM_VALUE = $1, "ok"}})
    }
    inst IDXA_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Index Reg A (GBLIDXA)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGblidxAAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IDXA_VALUE = $1, self.IDXA_FRAME = ($1 >> 16) & 0x0000FFFF, self.IDXA_ELM = ($1 & 0x0000FFFF), "ok")
    }
    inst IDXB_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Index Reg B (GBLIDXB)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGblidxBAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IDXB_VALUE = $1, self.IDXB_FRAME = ($1 >> 16) & 0x0000FFFF, self.IDXB_ELM = ($1 & 0x0000FFFF), "ok")
    }
    inst CNTA_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Count Reload Reg A (GBLCNTA)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGblcntAAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.CNTA_VALUE = $1, self.CNTA_FRAME = ($1 >> 16) & 0x0000FFFF, self.CNTA_ELM = ($1 & 0x0000FFFF), "ok")
    }
    inst CNTB_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Count Reload Reg B (GBLCNTB)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "dmaGblcntBAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.CNTB_VALUE = $1, self.CNTB_FRAME = ($1 >> 16) & 0x0000FFFF, self.CNTB_ELM = ($1 & 0x0000FFFF), "ok")
    }
}

object DMAGBL_NOTHING :: dmaGblCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param GBLADDRA :: 0
    param GBLADDRA_NUM :: 0
    param GBLADDRA_SYM :: "NULL"
    param GBLADDRB :: 0
    param GBLADDRB_NUM :: 0
    param GBLADDRB_SYM :: "NULL"
    param GBLADDRC :: 0
    param GBLADDRC_NUM :: 0
    param GBLADDRC_SYM :: "NULL"
    param GBLADDRD :: 0
    param GBLADDRD_NUM :: 0
    param GBLADDRD_SYM :: "NULL"
    param IDXA_FRAME :: 0
    param IDXA_ELM :: 0
    param IDXB_FRAME :: 0
    param IDXB_ELM :: 0
    param CNTA_FRAME :: 0
    param CNTA_ELM :: 0
    param CNTB_FRAME :: 0
    param CNTB_ELM :: 0
    param GBLADDRA_FORMAT_ADV :: "Numeric"
    param GBLADDRA_SYM_VALUE :: "NULL"
    param GBLADDRB_FORMAT_ADV :: "Numeric"
    param GBLADDRB_SYM_VALUE :: "NULL"
    param GBLADDRC_FORMAT_ADV :: "Numeric"
    param GBLADDRC_SYM_VALUE :: "NULL"
    param GBLADDRD_FORMAT_ADV :: "Numeric"
    param GBLADDRD_SYM_VALUE :: "NULL"
}

type EDMAFOLDER {
    prop Label :: "EDMA Enhanced Direct Memory Access"
    prop GlobalIcon :: 165
    prop InstanceIcon :: 166
    prop GlobalHelpTopic :: 1030
    prop GlobalPropertyPage :: "{B936FB91-49A5-11d4-967C-0050048381B7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type edmaCfg {
    isa ObjectMgr
    prop name :: "edmaCfg"
    prop Label :: "EDMA Configuration Manager"
    prop JSName :: "EDMA"
    prop IsContainedIn :: EDMAFOLDER
    prop GlobalIcon :: 165
    prop InstanceIcon :: 166
    prop GlobalHelpTopic :: 1031
    prop InstanceHelpTopic :: 1031
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop NoGen :: 1
    prop cGen :: CSL.EDMA_SUPPORT
    prop cStruct :: CSL.EDMA_SUPPORT
    prop cStructType :: "EDMA_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_edma.h"} else {""}
    prop cStructQual :: "far"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; edmaCfg) {$a += 1}, if ($a == 2) {scan ($c; hEdma) {$c.PINIT_ENABLE = 0}, scan ($d; hEdmaTbl) {$d.PINIT_ENABLE = 0}} , "ok")
    prop FSYNC_OPTION :: (if (self.FSYNC_SETUP == "None") {0x00000000} else {if (self.FSYNC_SETUP == "Enable") {0x00000001} })
    prop TDS_OPTION :: (if (self.TDS_SETUP == "Disable") {0x00000000} else {if (self.TDS_SETUP == "Enable") {0x04000000} })
    prop TDD_OPTION :: (if (self.TDD_SETUP == "Disable") {0x00000000} else {if (self.TDD_SETUP == "Enable") {0x00800000} })
    prop DUM_OPTION :: (if (self.DUM_SETUP == "None") {0x00000000} else {if (self.DUM_SETUP == "Increment") {0x00200000} else {if (self.DUM_SETUP == "Decrement") {0x00400000} else {if (self.DUM_SETUP == "Index") {0x00600000} }}})
    prop SUM_OPTION :: (if (self.SUM_SETUP == "None") {0x00000000} else {if (self.SUM_SETUP == "Increment") {0x01000000} else {if (self.SUM_SETUP == "Decrement") {0x02000000} else {if (self.SUM_SETUP == "Index") {0x03000000} }}})
    prop PDTS_OPTION :: (if (self.PDTS_SETUP == "Disable") {0x00000000} else {if (self.PDTS_SETUP == "Enable") {0x00000008} })
    prop ESIZE_OPTION :: (if (self.ESIZE_SETUP == "32-bit") {0x00000000} else {if (self.ESIZE_SETUP == "16-bit") {0x08000000} else {if (self.ESIZE_SETUP == "8-bit") {0x10000000} }})
    prop PRI_OPTION :: (if (CSL.C64_SUPPORT) {if (self.PRI_SETUP == "Urgent(64x)") {0x00000000} else {if (self.PRI_SETUP == "High") {0x20000000} else {if (self.PRI_SETUP == "Medium") {0x40000000} else {if (self.PRI_SETUP == "Low") {0x60000000} }}}} else {if (self.PRI_SETUP == "High") {0x20000000} else {if (self.PRI_SETUP == "Low") {0x40000000} }})
    prop TCINT_OPTION :: (if (self.TCINT_SETUP == "Disable") {0x00000000} else {if (self.TCINT_SETUP == "Enable") {0x00100000} })
    prop TCC_OPTION :: (self.TCC_SETUP_NEW << 16)
    prop TCC_OPTION_OLD :: (if (self.TCC_SETUP == "Host to DSP Interrupt") {0x00000000 >> 16} else {if (self.TCC_SETUP == "Timer 0 Interrupt") {0x00010000 >> 16} else {if (self.TCC_SETUP == "Timer 1 Interrupt") {0x00020000 >> 16} else {if (self.TCC_SETUP == "EMIF Timer Interrupt") {0x00030000 >> 16} else {if (self.TCC_SETUP == "External Interrupt Pin 4") {0x00040000 >> 16} else {if (self.TCC_SETUP == "External Interrupt Pin 5") {0x00050000 >> 16} else {if (self.TCC_SETUP == "External Interrupt Pin 6") {0x00060000 >> 16} else {if (self.TCC_SETUP == "External Interrupt Pin 7") {0x00070000 >> 16} else {if (self.TCC_SETUP == "EDMA_TCC 1000b Interrupt") {0x00080000 >> 16} else {if (self.TCC_SETUP == "EDMA_TCC 1001b Interrupt") {0x00090000 >> 16} else {if (self.TCC_SETUP == "EDMA_TCC 1010b Interrupt") {0x000A0000 >> 16} else {if (self.TCC_SETUP == "EDMA_TCC 1011b Interrupt") {0x000B0000 >> 16} else {if (self.TCC_SETUP == "McBSP 0 Transmit Event") {0x000C0000 >> 16} else {if (self.TCC_SETUP == "McBSP 0 Receive Event") {0x000D0000 >> 16} else {if (self.TCC_SETUP == "McBSP 1 Transmit Event") {0x000E0000 >> 16} else {if (self.TCC_SETUP == "McBSP 1 Receive Event") {0x000F0000 >> 16} }}}}}}}}}}}}}}})
    prop TCCM_OPTION :: (self.TCCM_SETUP << 13)
    prop ATCINT_OPTION :: (if (self.ATCINT_SETUP == "Disable") {0x00000000} else {if (self.ATCINT_SETUP == "Enable") {0x00001000} })
    prop ATCC_OPTION :: (self.ATCC_SETUP << 5)
    prop PDTD_OPTION :: (if (self.PDTD_SETUP == "Disable") {0x00000000} else {if (self.PDTD_SETUP == "Enable") {0x00000004} })
    prop LINK_OPTION :: (if (self.LINK_SETUP == "Disable") {0x00000000} else {if (self.LINK_SETUP == "Enable") {0x00000002} })
    prop OPTION_VALUE_update :: (self.FSYNC_OPTION() | self.LINK_OPTION() | self.TCC_OPTION() | (if (CSL.C64_SUPPORT) {self.TCCM_OPTION()} else {0}) | self.TCINT_OPTION() | (if (CSL.C64_SUPPORT) {self.ATCINT_OPTION()} else {0}) | (if (CSL.C64_SUPPORT) {self.ATCC_OPTION()} else {0}) | (if (CSL.C64_SUPPORT) {self.PDTS_OPTION()} else {0}) | (if (CSL.C64_SUPPORT) {self.PDTD_OPTION()} else {0}) | self.DUM_OPTION() | self.TDD_OPTION() | self.SUM_OPTION() | self.TDS_OPTION() | self.ESIZE_OPTION() | self.PRI_OPTION())
    prop OPTION_SETUP_update :: (self.FSYNC_SETUP = if ($1 & 0x00000001) {"Enable"} else {"None"}, if (CSL.C64_SUPPORT) {self.PDTS_SETUP = if ($1 & 0x00000008) {"Enable"} else {"Disable"}, self.PDTD_SETUP = if ($1 & 0x00000004) {"Enable"} else {"Disable"}} , self.LINK_SETUP = if ($1 & 0x00000002) {"Enable"} else {"Disable"}, if (CSL.C64_SUPPORT) {self.TCCM_SETUP = ($1 & 0x00006000) >> 13} , self.TCC_SETUP_NEW = ($1 & 0x000F0000) >> 16, self.TCINT_SETUP = if ($1 & 0x00100000) {"Enable"} else {"Disable"}, if (CSL.C64_SUPPORT) {self.ATCINT_SETUP = if ($1 & 0x00001000) {"Enable"} else {"Disable"}, self.ATCC_SETUP = ($1 & 0x000007E0) >> 5} , self.DUM_SETUP = ($a = ($1 & 0x00600000), if ($a == 0x00200000) {"Increment"} else {if ($a == 0x00400000) {"Decrement"} else {if ($a == 0x00600000) {"Index"} else {"None"}}}), self.TDD_SETUP = if ($1 & 0x00800000) {"Enable"} else {"Disable"}, self.SUM_SETUP = ($a = ($1 & 0x03000000), if ($a == 0x01000000) {"Increment"} else {if ($a == 0x02000000) {"Decrement"} else {if ($a == 0x03000000) {"Index"} else {"None"}}}), self.TDS_SETUP = if ($1 & 0x04000000) {"Enable"} else {"Disable"}, self.ESIZE_SETUP = ($a = ($1 & 0x18000000), if ($a == 0x08000000) {"16-bit"} else {if ($a == 0x10000000) {"8-bit"} else {"32-bit"}}), if (CSL.C64_SUPPORT) {self.PRI_SETUP = ($a = ($1 & 0xE0000000), if ($a == 0x00000000) {"Urgent(64x)"} else {if ($a == 0x40000000) {"Medium"} else {if ($a == 0x20000000) {"High"} else {"Low"}}})} else {self.PRI_SETUP = ($a = ($1 & 0xE0000000), if ($a == 0x20000000) {"High"} else {"Low"})})
    prop CheckAllocateTable :: ($a = 0, scan ($b; hEdmaTbl) {if (self.LINK_TBLHANDLE == $b) {if ($b.EDMA_PRAMTABLE_ALLOC == 1) {$a += 1} } }, if ($a == 0) {self.LINK_PARAMTBL = PARAMTBL_NOTHING, "Allocate Table first"} else {"done"})
    prop configStruct :: self
    prop cfgStrRLD :: if (self.LINK_FORMAT == "Table Handle" && self.LINK_TBLHANDLE != PARAMTBL_NOTHING && self.CheckAllocateTable == "done") {"%5t%3s.rld = (%3s.rld & 0xFFFF0000) | (EDMA_RLD_RMK(0,"} else {""}
    prop TblHandle :: if (self.LINK_FORMAT == "Table Handle" && self.LINK_TBLHANDLE != PARAMTBL_NOTHING && self.CheckAllocateTable == "done") {self.LINK_TBLHANDLE} else {""}
    prop TblMaskStr :: if (self.LINK_FORMAT == "Table Handle" && self.LINK_TBLHANDLE != PARAMTBL_NOTHING && self.CheckAllocateTable == "done") {"%4s));\n%0t"} else {""}
    prop cfgStrCNT :: if (self.XFRCNT_FORMAT == "User's Header file") {"%5t%3s.cnt = EDMA_CNT_RMK("} else {""}
    prop FramecntStr :: (if (self.XFRCNT_FORMAT == "User's Header file" && self.FRAMECNT_HEADER == "NULL") {"0"} else {if (self.XFRCNT_FORMAT == "User's Header file" && self.FRAMECNT_HEADER != "NULL") {self.FRAMECNT_HEADER} else {""}})
    prop ElmcntStr :: (if (self.XFRCNT_FORMAT == "User's Header file" && self.ELMCNT_HEADER == "NULL") {"0"} else {if (self.XFRCNT_FORMAT == "User's Header file" && self.ELMCNT_HEADER != "NULL") {self.ELMCNT_HEADER} else {""}})
    prop XfrCntStr :: if (self.XFRCNT_FORMAT == "User's Header file") {"%7s,%8s);\n%0t"} else {""}
    prop cfgStrIDX :: if (self.XFRIDX_FORMAT == "User's Header file") {"%5t%3s.idx = EDMA_IDX_RMK("} else {""}
    prop FrameidxStr :: (if (self.XFRIDX_FORMAT == "User's Header file" && self.FRAMEIDX_HEADER == "NULL") {"0"} else {if (self.XFRIDX_FORMAT == "User's Header file" && self.FRAMEIDX_HEADER != "NULL") {self.FRAMEIDX_HEADER} else {""}})
    prop ElmidxStr :: (if (self.XFRIDX_FORMAT == "User's Header file" && self.ELMIDX_HEADER == "NULL") {"0"} else {if (self.XFRIDX_FORMAT == "User's Header file" && self.ELMIDX_HEADER != "NULL") {self.ELMIDX_HEADER} else {""}})
    prop XfrIdxStr :: if (self.XFRIDX_FORMAT == "User's Header file") {"%11s,%12s);\n%0t"} else {""}
    prop cfgStrSRC :: if (self.SRCADDR_FORMAT == "McBSP handle (DRR)" && self.SRCADDR_HANDLE != "NULL") {"%5t%3s.src = EDMA_SRC_RMK("} else {""}
    prop SrcHandle :: if (self.SRCADDR_FORMAT == "McBSP handle (DRR)" && self.SRCADDR_HANDLE != "NULL") {self.SRCADDR_HANDLE} else {""}
    prop SrcStr :: if (self.SRCADDR_FORMAT == "McBSP handle (DRR)" && self.SRCADDR_HANDLE != "NULL") {"%15s->drrAddr);\n%0t"} else {""}
    prop cfgStrDST :: if (self.DSTADDR_FORMAT == "McBSP handle (DXR)" && self.DSTADDR_HANDLE != "NULL") {"%5t%3s.dst = EDMA_DST_RMK("} else {""}
    prop DstHandle :: if (self.DSTADDR_FORMAT == "McBSP handle (DXR)" && self.DSTADDR_HANDLE != "NULL") {self.DSTADDR_HANDLE} else {""}
    prop DstStr :: if (self.DSTADDR_FORMAT == "McBSP handle (DXR)" && self.DSTADDR_HANDLE != "NULL") {"%18s->dxrAddr);\n%0t"} else {""}
    prop cGenFxnPostInst :: ("%1S%2S%5S%6S%9S%10S%13S%14S%16S%17S\0,cfgStrRLD,TblMaskStr,configStruct,TblHandle,cfgStrCNT,XfrCntStr,FramecntStr,ElmcntStr,cfgStrIDX,XfrIdxStr,FrameidxStr,ElmidxStr,cfgStrSRC,SrcStr,SrcHandle,cfgStrDST,DstStr,DstHandle")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst FSYNC_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Enable"
        prop Label :: "Frame Sync(FS)"
        prop JSName :: "edmaOptionsFS"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.FSYNC_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst TDS_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Two Dimensional Source Transfer(2DS)"
        prop JSName :: "edmaOptions2ds"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (self.TDS_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst TDD_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Two Dimensional Destination Transfer(2DD)"
        prop Visible :: 1
        prop JSName :: "edmaOptions2dd"
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (self.TDD_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst DUM_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Destination Address Update Mode(DUM)"
        prop Visible :: 1
        prop JSName :: "edmaOptionsDum"
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (self.DUM_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst SUM_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Source Address Update Mode(SUM)"
        prop Visible :: 1
        prop JSName :: "edmaOptionsSum"
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (self.SUM_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst PDTS_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Peripheral Device Transfer Srce(PDTS)"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && CSL.C64_SUPPORT) {1} else {0}
        prop JSName :: "edmaOptionsPdts"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (self.PDTS_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst ESIZE_SETUP :: "32-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit,16-bit,8-bit"
        prop Label :: "Element Size(ESIZE)"
        prop Visible :: 1
        prop JSName :: "edmaOptionsEsize"
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (self.ESIZE_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst PRI_SETUP :: "Urgent(64x)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,Medium,High,Urgent(64x)"
        prop Label :: "Priority Levels(PRI)"
        prop Visible :: 1
        prop JSName :: "edmaOptionsPri"
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (if (!CSL.C64_SUPPORT) {if ($1 == "Medium" || $1 == "Urgent(64x)") {self.error("Invalid Selection, For C64x only")} else {self.PRI_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok"}} else {self.PRI_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok"})
    }
    inst TCINT_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Transfer Complete Interrupt(TCINT)"
        prop JSName :: "edmaOptionsTcint"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (self.TCINT_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst TCC_SETUP :: "Host to DSP Interrupt" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Host to DSP Interrupt,Timer 0 Interrupt,Timer 1 Interrupt,EMIF Timer Interrupt,External Interrupt Pin 4,External Interrupt Pin 5,External Interrupt Pin 6,External Interrupt Pin 7,EDMA_TCC 1000b Interrupt,EDMA_TCC 1001b Interrupt,EDMA_TCC 1010b Interrupt,EDMA_TCC 1011b Interrupt,McBSP 0 Transmit Event,McBSP 0 Receive Event,McBSP 1 Transmit Event,McBSP 1 Receive Event"
        prop Label :: "Transfer Complete Code(TCC)"
        prop Visible :: 0
        prop Writable :: (if ((CSL.EDMA_SUPPORT != 0) && (self.TCINT_SETUP != "Disable")) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (self.TCC_SETUP = $1, self.TCC_SETUP_NEW = self.TCC_OPTION_OLD(), self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst TCC_SETUP_NEW :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: 0x01 | 0x02
        prop Label :: "Transfer Complete Code(TCC)"
        prop Visible :: 1
        prop JSName :: "edmaOptionsTcc"
        prop Writable :: (if ((CSL.EDMA_SUPPORT != 0) && (self.TCINT_SETUP != "Disable")) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" TCC value has to be set between 0 and 15")} else {self.TCC_SETUP_NEW = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok"})
    }
    inst TCCM_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: 0x01 | 0x02
        prop Style :: 0x01
        prop Label :: "Most Significant Bits of Transfer Complete Code(TCCM)"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.TCINT_SETUP != "Disable") && CSL.C64_SUPPORT) {1} else {0}
        prop JSName :: "edmaOptionsTccm"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (if ($1 > 3) {self.error("Invalid Number, Should be between 0 and 3")} else {self.TCCM_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok"})
    }
    inst ATCINT_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Alternate Transfer Complete Interrupt(ATCINT)"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && CSL.C64_SUPPORT) {1} else {0}
        prop JSName :: "edmaOptionsAtcint"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (self.ATCINT_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst ATCC_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: 0x01 | 0x02
        prop Label :: "Alternate Transfer Complete Code(ATCC)"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.ATCINT_SETUP != "Disable") && CSL.C64_SUPPORT) {1} else {0}
        prop JSName :: "edmaOptionsAtcc"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (if ($1 > 63) {self.error("Invalid Number, Should be between 0 and 63")} else {self.ATCC_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok"})
    }
    inst SRCADDR :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Source Address (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.SRCADDR = $1, self.SRCADDR_FORMAT = "Numeric", self.SRCADDR_FORMAT_ADV = self.SRCADDR_FORMAT, self.SRCADDR_NUM = self.SRCADDR, self.SRCADDR_NUM_VALUE = self.SRCADDR_NUM, self.SRCADDR_SYM = "NULL", self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok"})
    }
    inst SRCADDR_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label :: "Source Address Format"
        prop JSName :: "edmaSrcAddrFormat"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.SRCADDR_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.SRCADDR_FORMAT = "Numeric", self.error("You must enter a Header file name - See CSL extern Declaration")} else {self.SRCADDR_FORMAT = $1, self.SRCADDR_FORMAT_ADV = $1, if ($1 == "Numeric") {self.SRCADDR_HANDLE = "NULL", self.SRCADDR_SYM = "NULL", self.SRCADDR_HEADER = "NULL"} , if ($1 == "User's Header file") {self.SRCADDR_HANDLE = "NULL", self.SRCADDR_SYM = "NULL"} , if ($1 == "Extern Decl. Obj.") {self.SRCADDR_HANDLE = "NULL", self.SRCADDR_HEADER = "NULL"} , if ($1 == "McBSP handle (DRR)") {self.SRCADDR_SYM = "NULL", self.SRCADDR_HEADER = "NULL"} , "ok"}})
    }
    inst SRCADDR_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Src Addr - Enter Numeric value "
        prop JSName :: "edmaSrcAddrNumeric"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.SRCADDR_NUM = $1, self.SRCADDR_NUM_VALUE = self.SRCADDR_NUM, self.SRCADDR_HANDLE = "NULL", self.SRCADDR_HEADER = "NULL", self.SRCADDR_HEADER_VALUE = self.SRCADDR_HEADER, self.SRCADDR_SYM = "NULL", self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok"})
    }
    inst SRCADDR_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Src Addr - Extern Decl. Symbol name "
        prop JSName :: "edmaSrcAddrSymbol"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT == "Extern Decl. Obj."
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.DSTADDR_SYM) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic object Name not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.SRCADDR_HANDLE = "NULL", self.SRCADDR_SYM = $1, self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok"}}})
    }
    inst SRCADDR_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Src Addr - Enter full address "
        prop JSName :: "edmaSrcAddrFull"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT == "User's Header file"
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRCADDR_HANDLE = "NULL", self.SRCADDR_SYM = "NULL", self.SRCADDR_HEADER = $1, self.SRCADDR_HEADER_VALUE = self.SRCADDR_HEADER, "ok")
    }
    inst SRCADDR_HANDLE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Src Addr - Enter Handle Name "
        prop JSName :: "edmaSrcAddrHandle"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT == "McBSP handle (DRR)"
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ($a = 0, $c = 0, scan ($b; hMcbsp) {if ($1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1) {$a = 1} }, if ($a == 0) {self.error("Handle object Name has to be declared and defined (open)  - ")} else {self.SRCADDR_HANDLE = $1, "ok"})
    }
    inst PDTD_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Peripheral Device Transfer Dest.(PDTD)"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && CSL.C64_SUPPORT) {1} else {0}
        prop NoGen :: 1
        prop JSName :: "edmaOptionsPdtd"
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (self.PDTD_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst DSTADDR :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Destination Address (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.DSTADDR = $1, self.DSTADDR_FORMAT = "Numeric", self.DSTADDR_FORMAT_ADV = self.DSTADDR_FORMAT, self.DSTADDR_NUM = self.DSTADDR, self.DSTADDR_NUM_VALUE = self.DSTADDR_NUM, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok"})
    }
    inst DSTADDR_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label :: "Destination Address Format"
        prop JSName :: "edmaDstAddrFormat"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.DSTADDR_FORMAT = "Numeric", self.error("You must create a Symbol Address - See CSL Extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.DSTADDR_FORMAT = "Numeric", self.error("You must enter a Header file name - See CSL Extern Declaration")} else {self.DSTADDR_FORMAT = $1, self.DSTADDR_FORMAT_ADV = $1, if ($1 == "Numeric") {self.DSTADDR_SYM = "NULL", self.DSTADDR_HANDLE = "NULL", self.DSTADDR_HEADER = "NULL"} , if ($1 == "User's Header file") {self.DSTADDR_HANDLE = "NULL", self.DSTADDR_SYM = "NULL"} , if ($1 == "Extern Decl. Obj.") {self.DSTADDR_HANDLE = "NULL", self.DSTADDR_HEADER = "NULL"} , if ($1 == "McBSP handle (DXR)") {self.DSTADDR_SYM = "NULL", self.DSTADDR_HEADER = "NULL"} , "ok"}})
    }
    inst DSTADDR_NUM :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Dst Addr - Enter Numeric value "
        prop JSName :: "edmaDstAddrNumeric"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0 && self.DSTADDR_FORMAT == "Numeric") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (if (0) {self.error("Invalid Number")} else {self.DSTADDR_NUM = $1, self.DSTADDR_NUM_VALUE = self.DSTADDR_NUM, self.DSTADDR_HANDLE = "NULL", self.DSTADDR_HEADER = "NULL", self.DSTADDR_HEADER_VALUE = self.DSTADDR_HEADER, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok"})
    }
    inst DSTADDR_SYM :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Dst Addr - Extern Decl. Symbol Name "
        prop JSName :: "edmaDstAddrSymbol"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.DSTADDR_FORMAT == "Extern Decl. Obj."
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.SRCADDR_SYM) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Object Name not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.DSTADDR_SYM = $1, self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok"}}})
    }
    inst DSTADDR_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Dst Addr - Enter full address "
        prop JSName :: "edmaDstAddrFull"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT && self.DSTADDR_FORMAT == "User's Header file")
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DSTADDR_HEADER = $1, self.DSTADDR_NUM_VALUE = 0x00000000, self.DSTADDR_HEADER_VALUE = self.DSTADDR_HEADER, "ok")
    }
    inst DSTADDR_HANDLE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Dst Addr - Enter Handle Name "
        prop JSName :: "edmaDstAddrHandle"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.DSTADDR_FORMAT == "McBSP handle (DXR)"
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ($a = 0, $c = 0, scan ($b; hMcbsp) {if ($1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1) {$a = 1} }, if ($a == 0) {self.error("Handle object Name has to be declared and defined (open)  - ")} else {self.DSTADDR_HANDLE = $1, "ok"})
    }
    inst FRAMECNT :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Count(FC)"
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
        prop Set :: (if (($1 > 65535) || ($1 < 0)) {self.error("Invalid Number [0..65535]")} else {self.FRAMECNT = $1, self.FRAMECNT_NUM = $1, self.FRAMECNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0x0000FFFF, self.XFRCNT_NUM_VALUE |= (self.FRAMECNT_NUM << 16), "ok"})
    }
    inst XFRCNT_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label :: " Transfer Counter Format"
        prop JSName :: "edmaTransferCounterFormat"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
        prop Set :: (if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.XFRCNT_FORMAT = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {self.XFRCNT_FORMAT = $1, self.XFRCNT_FORMAT_ADV = self.XFRCNT_FORMAT, if ($1 == "Numeric") {self.ELMCNT_HEADER = "NULL", self.FRAMECNT_HEADER = "NULL"} else {self.FRAMECNT_NUM = 0x0000, self.ELMCNT_NUM = 0x0000, self.XFRCNT_NUM_VALUE = 0x00000000}, "ok"})
    }
    inst FRAMECNT_NUM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "   Frame Cnt(FC) - Enter 16-bit value"
        prop JSName :: "edmaFrameCountNumeric"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRCNT_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
        prop Set :: (if (($1 > 65535) || ($1 < 0)) {self.error("Invalid Number [0..65535]")} else {self.FRAMECNT_NUM = $1, self.FRAMECNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0x0000FFFF, self.XFRCNT_NUM_VALUE |= (self.FRAMECNT_NUM << 16), "ok"})
    }
    inst FRAMECNT_HEADER :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Frame Cnt(FC) - Enter Num or Symbol value  "
        prop JSName :: "edmaFrameCountSymbol"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRCNT_FORMAT != "Numeric"
        prop NoGen :: 1
        prop TabName :: "Transfer Count"
        prop Set :: (self.FRAMECNT_HEADER = $1, self.FRAMECNT_NUM = 0x0000, self.XFRCNT_NUM_VALUE = (self.XFRCNT_NUM_VALUE & 0x0000FFFF), "ok")
    }
    inst ELMCNT :: 0x0001 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Count(EC)"
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
        prop Set :: (if (($1 > 65535) || ($1 < 1)) {self.error("Invalid Number [1..65535]")} else {self.ELMCNT = $1, self.ELMCNT_NUM = $1, self.ELMCNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0xFFFF0000, self.XFRCNT_NUM_VALUE |= self.ELMCNT_NUM, "ok"})
    }
    inst ELMCNT_NUM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "   Elt Counter(EC) - Enter 16-bit value"
        prop JSName :: "edmaElementCountNumeric"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRCNT_FORMAT == "Numeric"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
        prop Set :: (if (($1 > 65535) || ($1 < 0)) {self.error("Invalid Number [1..65535]")} else {self.ELMCNT_NUM = $1, self.ELMCNT_HEADER = "NULL", self.XFRCNT_NUM_VALUE &= 0xFFFF0000, self.XFRCNT_NUM_VALUE |= self.ELMCNT_NUM, "ok"})
    }
    inst ELMCNT_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Elt Count(EC) - Enter  Num or Sym value "
        prop JSName :: "edmaElementCountSymbol"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRCNT_FORMAT != "Numeric"
        prop NoGen :: 1
        prop TabName :: "Transfer Count"
        prop Set :: (self.ELMCNT_HEADER = $1, self.ELMCNT_NUM = 0x0000, self.XFRCNT_NUM_VALUE = (self.XFRCNT_NUM_VALUE & 0xFFFF0000), "ok")
    }
    inst XFRIDX_FORMAT :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label :: " Index Format"
        prop JSName :: "edmaIndexFormat"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Index"
        prop Set :: (if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.XFRIDX_FORMAT = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {self.XFRIDX_FORMAT = $1, self.XFRIDX_FORMAT_ADV = self.XFRIDX_FORMAT, if ($1 == "Numeric") {self.FRAMEIDX_HEADER = "NULL", self.ELMIDX_HEADER = "NULL"} else {self.FRAMEIDX_NUM = 0x0000, self.ELMIDX_NUM = 0x0000, self.XFRIDX_NUM_VALUE = 0x00000000}, "ok"})
    }
    inst FRAMEIDX :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Index(FIX)"
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Index"
        prop Set :: (if (($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {self.error("Invalid Number")} else {self.FRAMEIDX = $1, self.FRAMEIDX_NUM = $1, self.FRAMEIDX_HEADER = "NULL", self.XFRIDX_NUM_VALUE &= 0x0000FFFF, self.XFRIDX_NUM_VALUE |= (self.FRAMEIDX_NUM << 16), "ok"})
    }
    inst FRAMEIDX_NUM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Frame Index(FIX)- 16-bit"
        prop JSName :: "edmaFrameIndexNumeric"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT && self.XFRIDX_FORMAT == "Numeric")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Index"
        prop Set :: (if (($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {self.error("Invalid Number")} else {self.FRAMEIDX_NUM = $1, self.FRAMEIDX_HEADER = "NULL", self.XFRIDX_NUM_VALUE &= 0x0000FFFF, self.XFRIDX_NUM_VALUE |= (self.FRAMEIDX_NUM << 16), "ok"})
    }
    inst FRAMEIDX_HEADER :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Frame Index(FIX) - Enter Num or Symbol value  "
        prop JSName :: "edmaFrameIndexSymbol"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRIDX_FORMAT != "Numeric"
        prop NoGen :: 1
        prop TabName :: "Index"
        prop Set :: (self.FRAMEIDX_HEADER = $1, self.FRAMEIDX_NUM = 0x0000, self.XFRIDX_NUM_VALUE = (self.XFRIDX_NUM_VALUE & 0x0000FFFF), "ok")
    }
    inst ELMIDX :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Index(EIX)"
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Index"
        prop Set :: (if (($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {self.error("Invalid Number")} else {self.ELMIDX = $1, self.ELMIDX_NUM = $1, self.ELMIDX_HEADER = "NULL", self.XFRIDX_NUM_VALUE &= 0xFFFF0000, self.XFRIDX_NUM_VALUE |= self.ELMIDX_NUM, "ok"})
    }
    inst ELMIDX_NUM :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Index(EIX) - 16-bit"
        prop JSName :: "edmaElementIndexNumeric"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT && self.XFRIDX_FORMAT == "Numeric")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Index"
        prop Set :: (if (($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {self.error("Invalid Number")} else {self.ELMIDX_NUM = $1, self.ELMIDX_HEADER = "NULL", self.XFRIDX_NUM_VALUE &= 0xFFFF0000, self.XFRIDX_NUM_VALUE |= self.ELMIDX_NUM, "ok"})
    }
    inst ELMIDX_HEADER :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Element Index(EIX) - Enter  Num or Sym value "
        prop JSName :: "edmaElementIndexSymbol"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRIDX_FORMAT != "Numeric"
        prop NoGen :: 1
        prop TabName :: "Index"
        prop Set :: (self.ELMIDX_HEADER = $1, self.ELMIDX_NUM = 0x0000, self.XFRIDX_NUM_VALUE = (self.XFRIDX_NUM_VALUE & 0xFFFF0000), "ok")
    }
    inst ECRLD :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "Element Count Reload(ECRLD)"
        prop JSName :: "edmaElementCountReload"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
        prop Set :: (if (($1 > 65535) || ($1 < 1)) {self.error("Invalid Number")} else {self.ECRLD = $1, self.RLD_LNK_VALUE &= 0x0000FFFF, self.RLD_LNK_VALUE |= (self.ECRLD << 16), "ok"})
    }
    inst LINK_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Linking Event(LINK)"
        prop JSName :: "edmaLink"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
        prop Set :: (self.LINK_SETUP = $1, self.OPTION_VALUE = self.OPTION_VALUE_update(), "ok")
    }
    inst LINK_FORMAT :: = "Table Number" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Table Number,Table Handle"
        prop Label :: "Link Format"
        prop JSName :: "edmaLinkFormat"
        prop Visible :: 1
        prop Writable :: (if ((self.LINK_SETUP == "Enable") && (CSL.EDMA_SUPPORT != 0)) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
        prop Set :: ($a = 0, scan ($b; hEdmaTbl) {$a += 1}, if ($a == 1 && $1 == "Table Handle") {self.LINK_FORMAT = "Table Number", self.error(" A table object has to be created AND ALLOCATED under Param Table Entry")} else {self.LINK_FORMAT = $1, if ($1 == "Table Number") {self.LINK_TBLHANDLE = PARAMTBL_NOTHING} , "ok"})
    }
    inst LINK_TBLHANDLE :: PARAMTBL_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: hEdmaTbl
        prop Label :: "Link Handle Table"
        prop JSName :: "edmaLinkHandle"
        prop Visible :: 1
        prop Writable :: (if ((self.LINK_SETUP == "Enable") && (CSL.EDMA_SUPPORT != 0) && (self.LINK_FORMAT == "Table Handle")) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
    }
    inst LINKADDR :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "Link to Table Number"
        prop JSName :: "edmaLinkNumber"
        prop Visible :: 1
        prop Writable :: (if ((self.LINK_SETUP == "Enable") && (CSL.EDMA_SUPPORT != 0) && (self.LINK_FORMAT == "Table Number")) {1} else {0})
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
        prop Set :: (if (!CSL.C64_SUPPORT) {if (($1 > 64) || ($1 < 0)) {self.error("Invalid Number, valid number range [0..64]")} else {self.LINKADDR = $1, self.RLD_LNK_VALUE &= 0xFFFF0000, self.RLD_LNK_VALUE |= (self.LINKADDR * 24) + 0x01B0, "ok"}} else {if (($1 > 16) || ($1 < 0)) {self.error("Invalid Number, valid number range [0..16]")} else {self.LINKADDR = $1, self.RLD_LNK_VALUE &= 0xFFFF0000, self.RLD_LNK_VALUE |= (self.LINKADDR * 24) + 0x0630, "ok"}})
    }
    inst OPTION_VALUE :: self.OPTION_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Option"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "edmaOptions"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (if (!CSL.C64_SUPPORT) {$a = $1 & 0x0000FFFC, $b = $1 & 0x18000000, $c = $1 & 0xE0000000, if ($a != 0) {self.error("Bit field(bit[2..15]) is reserved")} else {if ($b == 0x18000000) {self.error("No such option for bit field ESIZE(bit[27..28])")} else {if (($c != 0x20000000) && ($c != 0x40000000)) {self.error("Option selected is not available for EDMA in bit field PRI(bit[29..31])")} else {self.OPTION_VALUE = $1, self.OPTION_SETUP_update($1), "ok"}}}} else {$a = $1 & 0x00000010, $b = $1 & 0x00000800, $c = $1 & 0x00008000, $d = $1 & 0x18000000, $e = $1 & 0x80000000, $f = $1 & 0xE0000000, if ($a != 0) {self.error("Bit field 4 is reserved")} else {if ($b != 0) {self.error("Bit field 11 is reserved")} else {if ($c != 0) {self.error("Bit field 15 is reserved")} else {if ($d == 0x18000000) {self.error("No such option for bit field ESIZE(bit[27..28])")} else {if (($f != 0x00000000) && ($f != 0x20000000) && ($f != 0x40000000) && ($f != 0x60000000)) {self.error("Option selected is not available for EDMA in bit field PRI(bit[29..31])")} else {self.OPTION_VALUE = $1, self.OPTION_SETUP_update($1), "ok"}}}}}})
    }
    inst SRCADDR_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Address (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SRCADDR_VALUE = $1, self.SRCADDR_FORMAT = "Numeric", self.SRCADDR_FORMAT_ADV = self.SRCADDR_FORMAT, self.SRCADDR_NUM = self.SRCADDR_VALUE, self.SRCADDR_NUM_VALUE = self.SRCADDR_NUM, self.SRCADDR_SYM = "NULL", self.SRCADDR_SYM_VALUE = self.SRCADDR_SYM, "ok")
    }
    inst SRCADDR_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label :: "Source Address Format"
        prop JSName :: "edmaSrcAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.SRCADDR_FORMAT_ADV = "Numeric", self.error("You must create a Symbolic Address - See CSL Extern Declaration")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.SRCADDR_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {self.SRCADDR_FORMAT_ADV = $1, self.SRCADDR_FORMAT = $1, if ($1 == "Numeric") {self.SRCADDR_SYM_VALUE = "NULL", self.SRCADDR_HEADER_VALUE = "NULL"} else {self.SRCADDR_NUM_VALUE = 0x00000000}, "ok"}})
    }
    inst SRCADDR_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Address - Numeric "
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "edmaSrcAddrNumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && (self.SRCADDR_FORMAT_ADV == "Numeric" || self.SRCADDR_FORMAT_ADV == "McBSP handle (DRR)" || (self.SRCADDR_FORMAT_ADV == "User's Header file" && self.SRCADDR_HEADER_VALUE == "NULL") || (self.SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && self.SRCADDR_SYM_VALUE == "NULL"))
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SRCADDR_NUM_VALUE = $1, self.SRCADDR_NUM = $1, "ok")
    }
    inst SRCADDR_SYM_VALUE :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Source Address - Extern Decl.Obj"
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && self.SRCADDR_SYM_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.SRCADDR_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.DSTADDR_SYM_VALUE) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Address  Not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.SRCADDR_SYM = $1, self.SRCADDR_SYM_VALUE = $1, "ok"}}})
    }
    inst SRCADDR_HEADER_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Source Address - From User's Header File"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && self.SRCADDR_FORMAT_ADV == "User's Header file" && self.SRCADDR_HEADER_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ("(Uint32) ")
    }
    inst XFRCNT_VALUE :: 0x00000001 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Counter"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XFRCNT_VALUE = $1, self.FRAMECNT_NUM = $1 >> 16, self.ELMCNT_NUM = ($1 & 0x0000FFFF), "ok")
    }
    inst XFRCNT_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label :: "Transfer Counter Format"
        prop JSName :: "edmaTransferCounterFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.XFRCNT_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {if ($1 == "Numeric") {self.ELMCNT_HEADER = "NULL", self.FRAMECNT_HEADER = "NULL"} else {self.XFRCNT_NUM_VALUE = 0x00000000, self.ELMCNT_NUM = 0x0000, self.FRAMECNT_NUM = 0x0000}, self.XFRCNT_FORMAT_ADV = $1, self.XFRCNT_FORMAT = self.XFRCNT_FORMAT_ADV, "ok"})
    }
    inst XFRCNT_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Counter - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "edmaTransferCounterNumeric"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRCNT_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XFRCNT_NUM_VALUE = $1, self.FRAMECNT_NUM = $1 >> 16, self.ELMCNT_NUM = ($1 & 0x0000FFFF), "ok")
    }
    inst DSTADDR_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Address (Old - should not be visible)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.DSTADDR_VALUE = $1, self.DSTADDR_FORMAT = "Numeric", self.DSTADDR_FORMAT_ADV = self.DSTADDR_FORMAT, self.DSTADDR_NUM = self.DSTADDR_VALUE, self.DSTADDR_NUM_VALUE = self.DSTADDR_NUM, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, "ok")
    }
    inst DSTADDR_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label :: "Destination Address Format"
        prop JSName :: "edmaDstAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ($a = 0, scan ($b; externDecl) {$a += 1}, if ($a == 1 && $1 == "Extern Decl. Obj.") {self.DSTADDR_FORMAT_ADV = "Numeric", self.error("You must create a Symbolic object - See CSL Extern Declaration.")} else {if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.DSTADDR_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration.")} else {self.DSTADDR_FORMAT_ADV = $1, self.DSTADDR_FORMAT = $1, if ($1 == "Numeric") {self.DSTADDR_SYM_VALUE = "NULL"} else {self.DSTADDR_NUM_VALUE = 0x00000000}, "ok"}})
    }
    inst DSTADDR_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Address - Numeric "
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "edmaDstAddrNumericAdv"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0 && self.DSTADDR_FORMAT_ADV == "Numeric") {1} else {0}
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && (self.DSTADDR_FORMAT_ADV == "Numeric" || self.DSTADDR_FORMAT_ADV == "McBSP handle (DXR)" || (self.DSTADDR_FORMAT_ADV == "User's Header file" && self.DSTADDR_HEADER_VALUE == "NULL") || (self.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && self.DSTADDR_SYM_VALUE == "NULL"))
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.DSTADDR_NUM_VALUE = $1, self.DSTADDR_NUM = self.DSTADDR_NUM_VALUE, self.DSTADDR_SYM = "NULL", self.DSTADDR_SYM_VALUE = self.DSTADDR_SYM, self.DSTADDR_HEADER = "NULL", self.DSTADDR_HEADER_VALUE = self.DSTADDR_HEADER, "ok")
    }
    inst DSTADDR_SYM_VALUE :: = "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Destination Address - Extern Decl. Obj"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && (self.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && self.DSTADDR_SYM_VALUE != "NULL")
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ($a = "", scan ($b; externDecl) {if (self.DSTADDR_SYM_VALUE == $b.BuffName) {if ($b.BuffSpec == "Array") {$a = "(Uint32) "} else {$a = "(Uint32) &"}} }, $a)
        prop Set :: ($a = 0, scan ($b; externDecl) {if ($1 != "NULL" && $1 == $b.BuffName) {if ($b.BuffType == "NULL") {$a = 1} else {if ($1 == self.SRCADDR_SYM_VALUE) {$a = 2} else {$a = 3}}} }, if ($a == 0) {self.error("Symbolic Address  Not declared  - See CSL Extern Declaration")} else {if ($a == 1) {self.error("Symbol Type of this object is incorrect - See CSL Extern Declaration")} else {if ($a == 2) {self.error("Source and Destination must be different")} else {self.DSTADDR_SYM = $1, self.DSTADDR_SYM_VALUE = $1, "ok"}}})
    }
    inst DSTADDR_HEADER_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Destination Address - From User's Header file"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && self.DSTADDR_FORMAT_ADV == "User's Header file" && self.DSTADDR_HEADER_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]"
        prop cPreVal :: ("(Uint32) ")
    }
    inst INDEX_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Index -Old stuff "
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.INDEX_VALUE = $1, self.XFRIDX_NUM_VALUE = $1, self.FRAMEIDX_NUM = $1 >> 16, self.ELMIDX_NUM = ($1 & 0x0000FFFF), "ok")
    }
    inst XFRIDX_FORMAT_ADV :: "Numeric" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label :: "Index Format"
        prop JSName :: "edmaIndexFormatAdv"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: (if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {self.XFRIDX_FORMAT_ADV = "Numeric", self.error("You must enter a Header file name  - See CSL Extern Declaration")} else {if ($1 == "Numeric") {self.ELMIDX_HEADER = "NULL", self.FRAMEIDX_HEADER = "NULL"} else {self.XFRIDX_NUM_VALUE = 0x0000, self.ELMIDX_NUM = 0x0000, self.FRAMEIDX_NUM = 0x0000}, self.XFRIDX_FORMAT_ADV = $1, self.XFRIDX_FORMAT = self.XFRIDX_FORMAT_ADV, "ok"})
    }
    inst XFRIDX_NUM_VALUE :: = 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Index register - Numeric"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "edmaIndexNumeric"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT && self.XFRIDX_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XFRIDX_NUM_VALUE = $1, self.FRAMEIDX_NUM = $1 >> 16, self.ELMIDX_NUM = ($1 & 0x0000FFFF), "ok")
    }
    inst RLD_LNK_VALUE :: = (if (self.LINK_SETUP == "Enable" && self.LINK_FORMAT == "Table Number" && !CSL.C64_SUPPORT) {0x000001B0} else {if (self.LINK_SETUP == "Enable" && self.LINK_FORMAT == "Table Number" && CSL.C64_SUPPORT) {0x00000630} else {0x00000000}}) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Element Count Reload and Link Address"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "edmaEcrldLinkAddr"
        prop Visible :: 1
        prop Writable :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop cGen :: if (CSL.EDMA_SUPPORT != 0) {1} else {0}
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = ($1 & 0x0000FFFF), if (!CSL.C64_SUPPORT) {if (self.LINK_FORMAT == "Table Number" && ($a > 0x07E0 || $a < 0x01B0)) {self.error(" Link Address wrong : Table 0 (0x01B0) - Table 68 (0x07E0)")} else {if (self.LINK_FORMAT == "Table Number") {self.ECRLD = $1 >> 16, self.LINKADDR = (($1 & 0x0000FFFF) - 0x01B0) / 24, self.RLD_LNK_VALUE = ($1 & 0xFFFF000) | ((self.LINKADDR * 24) + 0x01B0), "ok"} else {self.RLD_LNK_VALUE = ($1 & 0xFFFF0000), self.ECRLD = $1 >> 16, self.LINKADDR = (($1 & 0x0000FFFF) - 0x01B0) / 24, "ok"}}} else {if (self.LINK_FORMAT == "Table Number" && ($a > 0x07E0 || $a < 0x0630)) {self.error(" Link Address wrong : Table 0 (0x0630) - Table 17 (0x07E0)")} else {if (self.LINK_FORMAT == "Table Number") {self.ECRLD = $1 >> 16, self.LINKADDR = (($1 & 0x0000FFFF) - 0x0630) / 24, self.RLD_LNK_VALUE = ($1 & 0xFFFF000) | ((self.LINKADDR * 24) + 0x0630), "ok"} else {self.RLD_LNK_VALUE = ($1 & 0xFFFF0000), self.ECRLD = $1 >> 16, self.LINKADDR = (($1 & 0x0000FFFF) - 0x0630) / 24, "ok"}}})
    }
}

type hEdma {
    isa ObjectMgr
    prop name :: "hEdma"
    prop Label :: "EDMA Resource Manager"
    prop JSName :: "HEDMA"
    prop SortChildHierView :: 0
    prop IsContainedIn :: EDMAFOLDER
    prop GlobalIcon :: 165
    prop InstanceIcon :: 166
    prop GlobalHelpTopic :: 1032
    prop InstanceHelpTopic :: 1033
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop maxObjs :: 64
    prop NoGen :: 1
    prop cGen :: CSL.EDMA_SUPPORT
    prop cHandle :: self.cOpenGen
    prop cHeaderName :: ($a = "", scan ($b; hEdma) {if ($b.EDMA_HANDLE_ENABLE) {$a = "csl_edma.h"} }, $a)
    prop cHandleType :: "EDMA_Handle"
    prop cOpenName :: "EDMA_open"
    prop cConfigName :: "EDMA_config"
    prop cHandleName :: self.HandleName
    prop cStructQual :: "far"
    prop localCanCreate :: (self.error("New EDMA handle objects cannot be created"))
    prop localCanDelete :: (self.error("EDMA handle objects cannot be deleted"))
    prop cGenFxnPostInst :: (if ((self.CHA_ENABLE == 1) && (self.HandleName != "")) {"%5tEDMA_enableChannel(%1s);%0t\n\0, cHandleName"} else {""})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 64 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenGen :: = ((self.EDMA_HANDLE_ENABLE != 0) && (CSL.EDMA_SUPPORT != 0) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Handle"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst cOpenArg0 :: "EDMA_CHA_ANY" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 0"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "EDMA_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 1"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
    }
    inst DEVICE :: "EDMA_none" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "device"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
    }
    inst EDMA_HANDLE_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open EDMA Channel"
        prop JSName :: "edmaHandleEnable"
        prop Visible :: 1
        prop Writable :: if (((CSL.EDMA_SUPPORT && CSL.C64_SUPPORT) || (!CSL.C64_SUPPORT && (self.DEVICE == "EDMA_CHA_DSPINT" || self.DEVICE == "EDMA_CHA_TINT0" || self.DEVICE == "EDMA_CHA_TINT1" || self.DEVICE == "EDMA_CHA_SDINT" || self.DEVICE == "EDMA_CHA_EXTINT4" || self.DEVICE == "EDMA_CHA_EXTINT5" || self.DEVICE == "EDMA_CHA_EXTINT6" || self.DEVICE == "EDMA_CHA_EXTINT7" || self.DEVICE == "EDMA_CHA_TCC8" || self.DEVICE == "EDMA_CHA_TCC9" || self.DEVICE == "EDMA_CHA_TCC10" || self.DEVICE == "EDMA_CHA_TCC11" || self.DEVICE == "EDMA_CHA_XEVT0" || self.DEVICE == "EDMA_CHA_REVT0" || self.DEVICE == "EDMA_CHA_XEVT1" || self.DEVICE == "EDMA_CHA_REVT1"))) && CSL.EDMA_SUPPORT) {1} else {0}
        prop NoGen :: 1
        prop Set :: (self.EDMA_HANDLE_ENABLE = $1, if ($1 == 0) {self.EDMA_HANDLE_ENABLE = $1, self.PINIT_ENABLE = $1, self.cOpenArg0 = "EDMA_None", self.PINIT = EDMA_NOTHING, "ok"} else {if (CSL.C64_SUPPORT && self.DEVICE == "EDMA_CHA_TCC8") {self.cOpenArg0 = "EDMA_CHA_GPINT0", "ok"} else {if (CSL.C64_SUPPORT && self.DEVICE == "EDMA_CHA_TCC9") {self.cOpenArg0 = "EDMA_CHA_GPINT1", "ok"} else {if (CSL.C64_SUPPORT && self.DEVICE == "EDMA_CHA_TCC10") {self.cOpenArg0 = "EDMA_CHA_GPINT2", "ok"} else {if (CSL.C64_SUPPORT && self.DEVICE == "EDMA_CHA_TCC11") {self.cOpenArg0 = "EDMA_CHA_GPINT3", "ok"} else {self.cOpenArg0 = self.DEVICE, "ok"}}}}})
    }
    inst HandleName :: = self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Handle"
        prop JSName :: "edmaHandleName"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT & self.EDMA_HANDLE_ENABLE
    }
    inst PINIT_ENABLE :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "edmaEnablePreInit"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.EDMA_HANDLE_ENABLE == 1)) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; edmaCfg) {$a += 1}, if ($a == 1) {self.PINIT_ENABLE = 0, "You must create a EDMA configuration object first"} else {self.PINIT_ENABLE = $1, if ($1 == 0) {self.PINIT = EDMA_NOTHING, self.CHA_ENABLE = 0} , "ok"})
    }
    inst PINIT :: EDMA_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: edmaCfg
        prop Label :: "Pre-Initialize with"
        prop JSName :: "edmaPreInit"
        prop Visible :: 1
        prop Writable :: if ((self.PINIT_ENABLE == 1) && (CSL.EDMA_SUPPORT != 0) && (self.EDMA_HANDLE_ENABLE == 1)) {1} else {0}
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((self.PINIT_ENABLE == 1) && (CSL.EDMA_SUPPORT != 0) && (self.EDMA_HANDLE_ENABLE == 1) && (self.PINIT != EDMA_NOTHING) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Configuration"
        prop Visible :: 0
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) & (self.cConfigGen == 1)) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst cConfigArg0 :: = self.cHandleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) & (self.cConfigGen == 1)) {1} else {0}
        prop Set :: (self.cConfigArg0 = self.HandleName, "ok")
    }
    inst cConfigArg1 :: = self.PINIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 1"
        prop Visible :: 0
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) & (self.cConfigGen == 1)) {1} else {0}
        prop cPreVal :: "&"
    }
    inst CHA_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Selected Channel"
        prop JSName :: "edmaEnableChannel"
        prop Visible :: 1
        prop Writable :: (if (CSL.EDMA_SUPPORT != 0) && (self.PINIT_ENABLE == 1) && (self.PINIT != EDMA_NOTHING) && (CSL.C64_SUPPORT || (!CSL.C64_SUPPORT && (self.cOpenArg0 != "EDMA_CHA_TCC8" && self.cOpenArg0 != "EDMA_CHA_TCC9" && self.cOpenArg0 != "EDMA_CHA_TCC10" && self.cOpenArg0 != "EDMA_CHA_TCC11"))) {1} else {0})
        prop NoGen :: 1
    }
}

object EDMA_Channel0_DSPINT :: hEdma {
    param iComment :: "Host to DSP Interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_DSPINT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha0"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel1_TINT0 :: hEdma {
    param iComment :: "Timer 0 Interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_None"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TINT0"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha1"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel2_TINT1 :: hEdma {
    param iComment :: "Timer 1 Interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TINT1"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha2"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel3_SDINT :: hEdma {
    param iComment :: "EMIF Timer Interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_SDINT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha3"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel4_EXTINT4_GPINT4 :: hEdma {
    param iComment :: "External Interrupt Pin 4/ GPIO Evt 4 (64x only)"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_None"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_EXTINT4"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha4"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel5_EXTINT5_GPINT5 :: hEdma {
    param iComment :: "External Interrupt Pin 5/GPIO Evt 5 (64x only)"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_EXTINT5"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_EXTINT5"
    param EDMA_HANDLE_ENABLE :: 1
    param HandleName :: "hEdmaCha5"
    param PINIT_ENABLE :: 1
    param PINIT :: edmaCfg_FingerVein
    param CHA_ENABLE :: 1
}

object EDMA_Channel6_EXTINT6_GPINT6 :: hEdma {
    param iComment :: "External Interrupt Pin 6/GPIO Evt 6 (64x only)"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_None"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_EXTINT6"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha6"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel7_EXTINT7_GPINT7 :: hEdma {
    param iComment :: "External Interrupt Pin 7/GPIO Evt 7 (64x only)"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_EXTINT7"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_EXTINT7"
    param EDMA_HANDLE_ENABLE :: 1
    param HandleName :: "hEdmaCha7"
    param PINIT_ENABLE :: 1
    param PINIT :: edmaCfg_FingerPrint
    param CHA_ENABLE :: 1
}

object EDMA_Channel8_TCC8_GPINT0 :: hEdma {
    param iComment :: "C621x/C671x EDMA_TCC 1000b Interrupt, C64x GPIO Evt 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TCC8"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha8"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel9_TCC9_GPINT1 :: hEdma {
    param iComment :: "C621x/C671x EDMA_TCC 1001b Interrupt, C64x GPIO Evt 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TCC9"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha9"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel10_TCC10_GPINT2 :: hEdma {
    param iComment :: "C621x/C67x EDMA_TCC 1010b Interrupt, C64x GPIO Evt 2"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TCC10"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha10"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel11_TCC11_GPINT3 :: hEdma {
    param iComment :: "C621x/C671x EDMA_TCC 1011b Interrupt, C64x GPIO Evt 3"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TCC11"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha11"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel12_XEVT0 :: hEdma {
    param iComment :: "McBSP 0 Transmit Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_XEVT0"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha12"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel13_REVT0 :: hEdma {
    param iComment :: "McBSP 0 Receive Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_REVT0"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha13"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel14_XEVT1 :: hEdma {
    param iComment :: "McBSP 1 Transmit Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_XEVT1"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha14"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel15_REVT1 :: hEdma {
    param iComment :: "McBSP 1 Receive Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_REVT1"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha15"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel16 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "16"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha16"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel17_XEVT2 :: hEdma {
    param iComment :: "C64x only! McBSP 2 Transmit Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_XEVT2"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha17"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel18_REVT2 :: hEdma {
    param iComment :: "C64x only! McBSP 2 Receive Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_REVT2"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha18"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel19_TINT2 :: hEdma {
    param iComment :: "C64x only! TIMER 2 Interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TINT2"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha19"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel20_SDINTB :: hEdma {
    param iComment :: "C64x only! EMIFB SDRAM timer interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_SDINTB"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha20"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel21_PCI :: hEdma {
    param iComment :: "C64x only! PCI Wakeup Interrupt"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_PCI"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha21"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel22 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "22"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha22"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel23 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "23"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha23"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel24 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "24"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha24"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel25 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "25"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha25"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel26 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "26"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha26"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel27 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "27"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha27"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel28_VCPREVT :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_VCPREVT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha28"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel29_VCPXEVT :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_VCPXEVT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha29"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel30_TCPREVT :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TCPREVT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha30"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel31_TCPXEVT :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_TCPXEVT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha31"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel32_UREVT :: hEdma {
    param iComment :: "C64x only! Utopia Receive Event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_UREVT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha32"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel33 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "33"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha33"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel34 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "34"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha34"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel35 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "35"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha35"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel36 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "36"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha36"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel37 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "37"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha37"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel38 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "38"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha38"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel39 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "39"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha39"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel40_UXEVT :: hEdma {
    param iComment :: "C64x only! UTOPIA transmit event"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_UXEVT"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha40"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel41 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "41"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha41"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel42 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "42"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha42"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel43 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "43"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha43"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel44 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "44"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha44"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel45 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "45"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha45"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel46 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "46"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha46"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel47 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "47"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha47"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel48_GPINT8 :: hEdma {
    param iComment :: "C64x only! GPIO event 8"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT8"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha48"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel49_GPINT9 :: hEdma {
    param iComment :: "C64x only! GPIO event 9"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT9"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha49"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel50_GPINT10 :: hEdma {
    param iComment :: "C64x only! GPIO event 10"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT10"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha50"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel51_GPINT11 :: hEdma {
    param iComment :: "C64x only! GPIO event 11"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT11"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha51"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel52_GPINT12 :: hEdma {
    param iComment :: "C64x only! GPIO event 12"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT12"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha52"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel53_GPINT13 :: hEdma {
    param iComment :: "C64x only! GPIO event 13"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT13"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha53"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel54_GPINT14 :: hEdma {
    param iComment :: "C64x only! GPIO event 14"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT14"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha54"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel55_GPINT15 :: hEdma {
    param iComment :: "C64x only! GPIO event 15"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "EDMA_CHA_GPINT15"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha55"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel56 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "56"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha56"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel57 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "57"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha57"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel58 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "58"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha58"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel59 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "59"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha59"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel60 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "60"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha60"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel61 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "61"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha61"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel62 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "62"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha62"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

object EDMA_Channel63 :: hEdma {
    param iComment :: "None"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEdma"
    param iDelMsg :: "This EDMA Handle object cannot be deleted"
    param cOpenArg0 :: "EDMA_CHA_ANY"
    param cOpenArg1 :: "EDMA_OPEN_RESET"
    param DEVICE :: "63"
    param EDMA_HANDLE_ENABLE :: 0
    param HandleName :: "hEdmaCha63"
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param CHA_ENABLE :: 0
}

type hEdmaTbl {
    isa ObjectMgr
    prop name :: "hEdma Table"
    prop Label :: "Parameter RAM Table Entry"
    prop JSName :: "EdmaTable"
    prop IsContainedIn :: EDMAFOLDER
    prop GlobalIcon :: 165
    prop InstanceIcon :: 166
    prop GlobalHelpTopic :: 1034
    prop InstanceHelpTopic :: 1035
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop maxObjs :: 69
    prop NoGen :: 1
    prop cGen :: CSL.EDMA_SUPPORT
    prop cHandle :: self.cOpenGen
    prop cHeaderName :: if self.gNumOf > 0 {"csl_edma.h"} else {""}
    prop cHandleType :: "EDMA_Handle"
    prop cOpenName :: "EDMA_allocTable"
    prop cConfigName :: "EDMA_config"
    prop cHandleName :: self
    prop cStructQual :: "far"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenGen :: = ((self.EDMA_PRAMTABLE_ALLOC != 0) && (CSL.EDMA_SUPPORT != 0)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Table Allocation"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst cOpenArg0 :: = self.TBL_NUM { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "Open Arg 0"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
    }
    inst EDMA_PRAMTABLE_ALLOC :: = (if (self == PARAMTBL_NOTHING) {0} else {1}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Parameter RAM Table"
        prop JSName :: "edmaAllocPramTable"
        prop Visible :: 1
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop Set :: (if ($1 == 0) {self.EDMA_PRAMTABLE_ALLOC = 0, self.PINIT_ENABLE = $1, self.cOpenArg0 = 0, self.PINIT = EDMA_NOTHING} else {self.EDMA_PRAMTABLE_ALLOC = $1}, "ok")
    }
    inst TBL_NUM :: = -1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "Allocate Table Number"
        prop JSName :: "edmaTableNumber"
        prop Visible :: 1
        prop Writable :: ((self.EDMA_PRAMTABLE_ALLOC == 1) && (CSL.EDMA_SUPPORT != 0))
        prop NoGen :: 1
        prop Set :: (if (($1 < -1) || ($1 > 66) && CSL.C11_SUPPORT) {self.error("Invalid Table Number,  table number range [0..66] and -1 for any available table")} else {if (($1 < -1) || ($1 > 18) && CSL.C64_SUPPORT) {self.error("Invalid Table Number,  table number range [0..18] and -1 for any available table")} else {self.TBL_NUM = $1, "ok"}})
    }
    inst PINIT_ENABLE :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "edmaEnablePreInit"
        prop Visible :: 1
        prop Writable :: if ((self.EDMA_PRAMTABLE_ALLOC == 1) && (CSL.EDMA_SUPPORT != 0)) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; edmaCfg) {$a += 1}, if ($a == 1) {self.PINIT_ENABLE = 0, self.error("You must create a EDMA configuration object first")} else {self.PINIT_ENABLE = $1, if ($1 == 0) {self.PINIT = EDMA_NOTHING} , "ok"})
    }
    inst PINIT :: EDMA_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: edmaCfg
        prop Label :: "Pre-Initialize with"
        prop JSName :: "edmaPreInit"
        prop Visible :: 1
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.PINIT_ENABLE == 1)) {1} else {0}
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((self.PINIT_ENABLE == 1) && (self.PINIT != EDMA_NOTHING) && (CSL.EDMA_SUPPORT != 0)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Configuration"
        prop Visible :: 0
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.cConfigGen == 1)) {1} else {0}
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst cConfigArg0 :: self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.cConfigGen == 1)) {1} else {0}
    }
    inst cConfigArg1 :: = self.PINIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 1"
        prop Visible :: 0
        prop Writable :: if ((CSL.EDMA_SUPPORT != 0) && (self.cConfigGen == 1)) {1} else {0}
        prop cPreVal :: "&"
    }
}

object EDMA_NOTHING :: edmaCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param FSYNC_SETUP :: "None"
    param TDS_SETUP :: "Disable"
    param TDD_SETUP :: "Disable"
    param DUM_SETUP :: "None"
    param SUM_SETUP :: "None"
    param PDTS_SETUP :: "Disable"
    param ESIZE_SETUP :: "32-bit"
    param PRI_SETUP :: "Urgent(64x)"
    param TCINT_SETUP :: "Disable"
    param TCC_SETUP :: "Host to DSP Interrupt"
    param TCC_SETUP_NEW :: 0
    param TCCM_SETUP :: 0
    param ATCINT_SETUP :: "Disable"
    param ATCC_SETUP :: 0
    param SRCADDR :: 0
    param SRCADDR_FORMAT :: "Numeric"
    param SRCADDR_NUM :: 0
    param SRCADDR_SYM :: "NULL"
    param SRCADDR_HEADER :: "NULL"
    param SRCADDR_HANDLE :: "NULL"
    param PDTD_SETUP :: "Disable"
    param DSTADDR :: 0
    param DSTADDR_FORMAT :: "Numeric"
    param DSTADDR_NUM :: 0
    param DSTADDR_SYM :: "NULL"
    param DSTADDR_HEADER :: "NULL"
    param DSTADDR_HANDLE :: "NULL"
    param FRAMECNT :: 0
    param XFRCNT_FORMAT :: "Numeric"
    param FRAMECNT_NUM :: 0
    param ELMCNT :: 1
    param ELMCNT_NUM :: 0
    param ELMCNT_HEADER :: "NULL"
    param XFRIDX_FORMAT :: "Numeric"
    param FRAMEIDX :: 0
    param FRAMEIDX_NUM :: 0
    param ELMIDX :: 0
    param ELMIDX_NUM :: 0
    param ELMIDX_HEADER :: "NULL"
    param ECRLD :: 0
    param LINK_SETUP :: "Disable"
    param LINK_TBLHANDLE :: PARAMTBL_NOTHING
    param LINKADDR :: 0
    param OPTION_VALUE :: 0
    param SRCADDR_FORMAT_ADV :: "Numeric"
    param SRCADDR_HEADER_VALUE :: "NULL"
    param XFRCNT_VALUE :: 1
    param XFRCNT_FORMAT_ADV :: "Numeric"
    param DSTADDR_FORMAT_ADV :: "Numeric"
    param DSTADDR_HEADER_VALUE :: "NULL"
    param XFRIDX_FORMAT_ADV :: "Numeric"
}

object PARAMTBL_NOTHING :: hEdmaTbl {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param EDMA_PRAMTABLE_ALLOC :: 0
    param PINIT_ENABLE :: 0
    param PINIT :: EDMA_NOTHING
    param cConfigArg0 :: PARAMTBL_NOTHING
}

type EMIFFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL
    prop name :: "EMIF"
    prop Label :: "EMIF - External Memory Interface"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6524-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6525-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1040)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type emifCfg {
    isa ObjectMgr
    prop Name :: "emifCfg"
    prop Label :: "EMIF Configuration Manager"
    prop JSName :: "EMIF"
    prop IsContainedIn :: EMIFFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6522-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6523-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1041)
    prop InstanceHelpTopic :: (1041)
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "EMIF_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_emif.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "EMIF_config"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; emifCfg) {$a = $a + 1}, if ($a == 2) {hEmif.EMIF_INIT_ENABLE = 0} , "ok")
    prop NOHOLD_GBLCTL :: (if (self.NOHOLD_SETUP == "Disable Hold") {0x00000080} else {0x00000000})
    prop RBTR8_GBLCTL :: (if (self.RBTR8_SETUP == "until High-Priority") {0x00000000} else {0x00000002})
    prop SSCRT_GBLCTL :: (if (self.SSCRT_SETUP == "1/2 CPU clock") {0x00000000} else {0x00000004})
    prop CLK2EN_GBLCTL :: (if (self.CLK2EN_SETUP == "Held high") {0x00000000} else {0x00000008})
    prop CLK1EN_GBLCTL :: (if (self.CLK1EN_SETUP == "Held high") {0x00000000} else {0x00000010})
    prop SSCEN_GBLCTL :: (if (self.SSCEN_SETUP == "Held high") {0x00000000} else {0x00000020})
    prop SDCEN_GBLCTL :: (if (self.SDCEN_SETUP == "Held high") {0x00000000} else {0x00000040})
    prop MTYPE0_CECTL0 :: (if (self.MTYPE0_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE0_SETUP == "32-bit SDRAM") {0x00000030} else {if ((!CSL.C11_SUPPORT)) {0x00000040} else {if (self.MTYPE0_SETUP == "32-bit SBSRAM") {0x00000040} else {if (self.MTYPE0_SETUP == " 8-bit async. interf.") {0x00000000} else {if (self.MTYPE0_SETUP == " 8-bit SDRAM") {0x00000080} else {if (self.MTYPE0_SETUP == " 8-bit SBSRAM") {0x000000a0} else {if (self.MTYPE0_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE0_SETUP == "16-bit SDRAM") {0x00000090} else {0x000000b0}}}}}}}}})
    prop RDSTRB0_CECTL0 :: (((self.RDSTRB0_SETUP) << 8))
    prop RDSETUP0_CECTL0 :: (((self.RDSETUP0_SETUP) << 16))
    prop RDHLD0_CECTL0 :: ((self.RDHLD0_SETUP))
    prop WRSTRB0_CECTL0 :: (((self.WRSTRB0_SETUP) << 22))
    prop WRSETUP0_CECTL0 :: (((self.WRSETUP0_SETUP) << 28))
    prop WRHLD0_CECTL0 :: (if (self.WRHLD0_SETUP > 3) {((self.WRHLD0_SETUP - 4) << 20)} else {((self.WRHLD0_SETUP << 20))})
    prop TA0_CECTL0 :: ((self.TA0_SETUP << 14))
    prop MTYPE1_CECTL1 :: (if (self.MTYPE1_SETUP == " 8-bit ROM") {0x00000000} else {if (self.MTYPE1_SETUP == "16-bit ROM") {0x00000010} else {if (self.MTYPE1_SETUP == "32-bit async. interf.") {0x00000020} else {if ((!CSL.C11_SUPPORT)) {0x00000040} else {if (self.MTYPE1_SETUP == "32-bit SDRAM") {0x00000030} else {if (self.MTYPE1_SETUP == "32-bit SBSRAM") {0x00000040} else {if (self.MTYPE1_SETUP == " 8-bit async. interf.") {0x00000000} else {if (self.MTYPE1_SETUP == " 8-bit SDRAM") {0x00000080} else {if (self.MTYPE1_SETUP == " 8-bit SBSRAM") {0x000000a0} else {if (self.MTYPE1_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE1_SETUP == "16-bit SDRAM") {0x00000090} else {0x000000b0}}}}}}}}}}})
    prop RDSTRB1_CECTL1 :: (((self.RDSTRB1_SETUP) << 8))
    prop RDSETUP1_CECTL1 :: (((self.RDSETUP1_SETUP) << 16))
    prop RDHLD1_CECTL1 :: ((self.RDHLD1_SETUP))
    prop WRSTRB1_CECTL1 :: (((self.WRSTRB1_SETUP) << 22))
    prop WRSETUP1_CECTL1 :: (((self.WRSETUP1_SETUP) << 28))
    prop WRHLD1_CECTL1 :: (if (self.WRHLD1_SETUP > 3) {((self.WRHLD1_SETUP - 4) << 20)} else {((self.WRHLD1_SETUP << 20))})
    prop TA1_CECTL1 :: ((self.TA1_SETUP << 14))
    prop MTYPE2_CECTL2 :: (if (self.MTYPE2_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE2_SETUP == "32-bit SDRAM") {0x00000030} else {if ((!CSL.C11_SUPPORT)) {0x00000040} else {if (self.MTYPE2_SETUP == "32-bit SBSRAM") {0x00000040} else {if (self.MTYPE2_SETUP == " 8-bit async. interf.") {0x00000000} else {if (self.MTYPE2_SETUP == " 8-bit SDRAM") {0x00000080} else {if (self.MTYPE2_SETUP == " 8-bit SBSRAM") {0x000000a0} else {if (self.MTYPE2_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE2_SETUP == "16-bit SDRAM") {0x00000090} else {0x000000b0}}}}}}}}})
    prop RDSTRB2_CECTL2 :: (((self.RDSTRB2_SETUP) << 8))
    prop RDSETUP2_CECTL2 :: (((self.RDSETUP2_SETUP) << 16))
    prop RDHLD2_CECTL2 :: ((self.RDHLD2_SETUP))
    prop WRSTRB2_CECTL2 :: (((self.WRSTRB2_SETUP) << 22))
    prop WRSETUP2_CECTL2 :: (((self.WRSETUP2_SETUP) << 28))
    prop WRHLD2_CECTL2 :: (if (self.WRHLD2_SETUP > 3) {((self.WRHLD2_SETUP - 4) << 20)} else {((self.WRHLD2_SETUP << 20))})
    prop TA2_CECTL2 :: ((self.TA2_SETUP << 14))
    prop MTYPE3_CECTL3 :: (if (self.MTYPE3_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE3_SETUP == "32-bit SDRAM") {0x00000030} else {if ((!CSL.C11_SUPPORT)) {0x00000040} else {if (self.MTYPE3_SETUP == "32-bit SBSRAM") {0x00000040} else {if (self.MTYPE3_SETUP == " 8-bit async. interf.") {0x00000000} else {if (self.MTYPE3_SETUP == " 8-bit SDRAM") {0x00000080} else {if (self.MTYPE3_SETUP == " 8-bit SBSRAM") {0x000000a0} else {if (self.MTYPE3_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE3_SETUP == "16-bit SDRAM") {0x00000090} else {0x000000b0}}}}}}}}})
    prop RDSTRB3_CECTL3 :: (((self.RDSTRB3_SETUP) << 8))
    prop RDSETUP3_CECTL3 :: (((self.RDSETUP3_SETUP) << 16))
    prop RDHLD3_CECTL3 :: ((self.RDHLD3_SETUP))
    prop WRSTRB3_CECTL3 :: (((self.WRSTRB3_SETUP) << 22))
    prop WRSETUP3_CECTL3 :: (((self.WRSETUP3_SETUP) << 28))
    prop WRHLD3_CECTL3 :: (if (self.WRHLD3_SETUP > 3) {((self.WRHLD3_SETUP - 4) << 20)} else {((self.WRHLD3_SETUP << 20))})
    prop TA3_CECTL3 :: ((self.TA3_SETUP << 14))
    prop TRC_SDCTL :: ((self.TRC_SETUP << 12))
    prop TRP_SDCTL :: ((self.TRP_SETUP << 16))
    prop TRCD_Init :: (if ((CSL.C11_SUPPORT)) {4} else {8})
    prop TRCD_SDCTL :: ((self.TRCD_SETUP << 20))
    prop INIT_SDCTL :: (if (self.INIT_SETUP == "Initialize") {0x01000000} else {0x00000000})
    prop RFEN_SDCTL :: (if (self.RFEN_SETUP == "Enable") {0x02000000} else {0x00000000})
    prop SDWID_SDCTL :: (if (self.SDWID_SETUP == "Two 16-bit SDRAMs") {0x04000000} else {0x00000000})
    prop PERIOD_SDTIM1 :: ((self.PERIOD_SETUP1))
    prop SDCSZ_SDCTL :: (if (self.SDCSZ_SETUP == " 8 addresses") {0x04000000} else {if (self.SDCSZ_SETUP == "10 addresses") {0x08000000} else {0x00000000}})
    prop SDRSZ_SDCTL :: (if (self.SDRSZ_SETUP == "12 addresses") {0x10000000} else {if (self.SDRSZ_SETUP == "13 addresses") {0x20000000} else {0x00000000}})
    prop SDBSZ_SDCTL :: (if (self.SDBSZ_SETUP == "Four banks") {0x40000000} else {0x00000000})
    prop PERIOD_SDTIM2 :: ((self.PERIOD_SETUP2))
    prop XRFR_SDTIM :: (((self.XRFR_SETUP - 1) << 24))
    prop TCL_SDEXT :: ((self.TCL_SETUP - 2))
    prop TRAS_SDEXT :: (((self.TRAS_SETUP - 1) << 1))
    prop TRRD_SDEXT :: ((self.TRRD_SETUP - 2) << 4)
    prop TWR_SDEXT :: (((self.TWR_SETUP - 1) << 5))
    prop THZP_SDEXT :: (((self.THZP_SETUP - 1) << 7))
    prop RD2RD_SDEXT :: (((self.RD2RD_SETUP - 1) << 9))
    prop RD2DEAC_SDEXT :: (((self.RD2DEAC_SETUP - 1) << 10))
    prop RD2WR_SDEXT :: (((self.RD2WR_SETUP - 1) << 12))
    prop R2WDQM_SDEXT :: (((self.R2WDQM_SETUP - 1) << 15))
    prop WR2WR_SDEXT :: (((self.WR2WR_SETUP - 1) << 17))
    prop WR2DEAC_SDEXT :: (((self.WR2DEAC_SETUP - 1) << 18))
    prop WR2RD_SDEXT :: (((self.WR2RD_SETUP - 1) << 20))
    prop GBLCTL_VALUE_update :: (0x00003000 | self.RBTR8_GBLCTL() | self.SSCRT_GBLCTL() | self.CLK2EN_GBLCTL() | self.CLK1EN_GBLCTL() | self.SSCEN_GBLCTL() | self.SDCEN_GBLCTL() | self.NOHOLD_GBLCTL())
    prop GBLCTL_SETUP_update :: (self.RBTR8_SETUP = if ($1 & 0x00000002) {"8 accesses Minimum"} else {"until High-Priority"}, self.SSCRT_SETUP = if ($1 & 0x00000004) {"1 CPU clock"} else {"1/2 CPU clock"}, self.CLK2EN_SETUP = if ($1 & 0x00000008) {"Enabled to clock"} else {"Held high"}, self.CLK1EN_SETUP = if ($1 & 0x00000010) {"Enabled to clock"} else {"Held high"}, self.SSCEN_SETUP = if ($1 & 0x00000020) {"Enabled to clock"} else {"Held high"}, self.SDCEN_SETUP = if ($1 & 0x00000040) {"Enabled to clock"} else {"Held high"}, self.NOHOLD_SETUP = if ($1 & 0x00000080) {"Disable Hold"} else {"Enable Hold"})
    prop CECTL0_VALUE_update :: (self.MTYPE0_CECTL0() | self.RDHLD0_CECTL0() | self.RDSTRB0_CECTL0() | self.RDSETUP0_CECTL0() | self.WRHLD0_CECTL0() | self.WRSETUP0_CECTL0() | self.WRSTRB0_CECTL0() | (if ((!CSL.C11_SUPPORT)) {0} else {self.TA0_CECTL0()}))
    prop CECTL0_SETUP_update :: (if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit SBSRAM"} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}}}}})} else {if (CSL.CHIP_6712) {self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}})} else {self.MTYPE0_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {"32-bit SBSRAM"}})}}, if (CSL.C11_SUPPORT) {self.RDHLD0_SETUP = ($1 & 0x00000007)} else {self.RDHLD0_SETUP = ($1 & 0x00000003)}, self.RDSTRB0_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP0_SETUP = (($1 & 0x000F0000) >> 16), if (CSL.C11_SUPPORT) {self.WRHLD0_SETUP = ($1 & 0x00300000) >> 20} else {self.WRHLD0_SETUP = ($1 & 0x00300000) >> 20}, self.WRSTRB0_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP0_SETUP = (($1 >> 28) & 0xF), if (CSL.C11_SUPPORT) {self.TA0_SETUP = ($1 & 0x0000c000) >> 14} )
    prop CECTL1_VALUE_update :: (self.MTYPE1_CECTL1() | self.RDHLD1_CECTL1() | self.RDSTRB1_CECTL1() | self.RDSETUP1_CECTL1() | self.WRHLD1_CECTL1() | self.WRSETUP1_CECTL1() | self.WRSTRB1_CECTL1() | (if ((!CSL.C11_SUPPORT)) {0} else {self.TA1_CECTL1()}))
    prop CECTL1_SETUP_update :: (if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {self.MTYPE1_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit SBSRAM"} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}}}}})} else {if (CSL.CHIP_6712) {self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}})} else {self.MTYPE1_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000000) {" 8-bit ROM"} else {if ($a == 0x00000010) {"16-bit ROM"} else {if ($a == 0x00000020) {"32-bit async. interf."} else {"32-bit SBSRAM"}}})}}, if (CSL.C11_SUPPORT) {self.RDHLD1_SETUP = ($1 & 0x00000007)} else {self.RDHLD1_SETUP = ($1 & 0x00000003)}, self.RDSTRB1_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP1_SETUP = (($1 & 0x000F0000) >> 16), if (CSL.C11_SUPPORT) {self.WRHLD1_SETUP = ($1 & 0x00300000) >> 20} else {self.WRHLD1_SETUP = ($1 & 0x00300000) >> 20}, self.WRSTRB1_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP1_SETUP = (($1 >> 28) & 0xF), if (CSL.C11_SUPPORT) {self.TA1_SETUP = ($1 & 0x0000c000) >> 14} )
    prop CECTL2_VALUE_update :: (self.MTYPE2_CECTL2() | self.RDHLD2_CECTL2() | self.RDSTRB2_CECTL2() | self.RDSETUP2_CECTL2() | self.WRHLD2_CECTL2() | self.WRSETUP2_CECTL2() | self.WRSTRB2_CECTL2() | (if ((!CSL.C11_SUPPORT)) {0} else {self.TA2_CECTL2()}))
    prop CECTL2_SETUP_update :: (if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {self.MTYPE2_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit SBSRAM"} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}}}}})} else {if (CSL.CHIP_6712) {self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}})} else {self.MTYPE2_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {"32-bit SBSRAM"}})}}, if (CSL.C11_SUPPORT) {self.RDHLD2_SETUP = ($1 & 0x00000007)} else {self.RDHLD2_SETUP = ($1 & 0x00000003)}, self.RDSTRB2_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP2_SETUP = (($1 & 0x000F0000) >> 16), if (CSL.C11_SUPPORT) {self.WRHLD2_SETUP = ($1 & 0x00300000) >> 20} else {self.WRHLD2_SETUP = ($1 & 0x00300000) >> 20}, self.WRSTRB2_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP2_SETUP = (($1 >> 28) & 0xF), if (CSL.C11_SUPPORT) {self.TA2_SETUP = ($1 & 0x0000c000) >> 14} )
    prop CECTL3_VALUE_update :: (self.MTYPE3_CECTL3() | self.RDHLD3_CECTL3() | self.RDSTRB3_CECTL3() | self.RDSETUP3_CECTL3() | self.WRHLD3_CECTL3() | self.WRSETUP3_CECTL3() | self.WRSTRB3_CECTL3() | (if ((!CSL.C11_SUPPORT)) {0} else {self.TA3_CECTL3()}))
    prop CECTL3_SETUP_update :: (if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {self.MTYPE3_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit SBSRAM"} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}}}}})} else {if (CSL.CHIP_6712) {self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {" 8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {" 8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {" 8-bit SBSRAM"} else {"16-bit SBSRAM"}}}}})} else {self.MTYPE3_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {"32-bit SBSRAM"}})}}, if (CSL.C11_SUPPORT) {self.RDHLD3_SETUP = ($1 & 0x00000007)} else {self.RDHLD3_SETUP = ($1 & 0x00000003)}, self.RDSTRB3_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP3_SETUP = (($1 & 0x000F0000) >> 16), if (CSL.C11_SUPPORT) {self.WRHLD3_SETUP = ($1 & 0x00300000) >> 20} else {self.WRHLD3_SETUP = ($1 & 0x00300000) >> 20}, self.WRSTRB3_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP3_SETUP = (($1 >> 28) & 0xF), if (CSL.C11_SUPPORT) {self.TA3_SETUP = ($1 & 0x0000c000) >> 14} )
    prop SDCTL_VALUE_update :: (self.TRC_SDCTL() | self.TRP_SDCTL() | self.TRCD_SDCTL() | self.INIT_SDCTL() | self.RFEN_SDCTL() | (if ((!CSL.C11_SUPPORT)) {self.SDWID_SDCTL()} else {self.SDCSZ_SDCTL()}) | (if ((!CSL.C11_SUPPORT)) {0} else {self.SDRSZ_SDCTL()}) | (if ((!CSL.C11_SUPPORT)) {0} else {self.SDBSZ_SDCTL()}))
    prop SDCTL_SETUP_update :: (self.TRC_SETUP = ($1 & 0x0000F000) >> 12, self.TRP_SETUP = ($1 & 0x000F0000) >> 16, self.TRCD_SETUP = ($1 & 0x00F00000) >> 20, self.INIT_SETUP = ($a = ($1 & 0x01000000), if ($a == 0x01000000) {"Initialize"} else {"No effect"}), self.RFEN_SETUP = ($a = ($1 & 0x02000000), if ($a == 0x02000000) {"Enable"} else {"Disable"}), if ((!CSL.C11_SUPPORT)) {self.SDWID_SETUP = ($a = ($1 & 0x04000000), if ($a == 0x04000000) {"Two 16-bit SDRAMs"} else {"Four 8-bit SDRAMs"})} , if (CSL.C11_SUPPORT) {self.SDCSZ_SETUP = ($a = ($1 & 0x0c000000), if ($a == 0x04000000) {" 8 addresses"} else {if ($a == 0x08000000) {"10 addresses"} else {" 9 addresses"}}), self.SDRSZ_SETUP = ($a = ($1 & 0x30000000), if ($a == 0x10000000) {"12 addresses"} else {if ($a == 0x20000000) {"13 addresses"} else {"11 addresses"}}), self.SDBSZ_SETUP = ($a = ($1 & 0x40000000), if ($a == 0x40000000) {"Four banks"} else {"Two banks"})} )
    prop SDTIM_VALUE_update :: ((if ((!CSL.C11_SUPPORT)) {self.PERIOD_SDTIM1()} else {self.PERIOD_SDTIM2()}) | (if ((!CSL.C11_SUPPORT)) {0} else {self.XRFR_SDTIM()}))
    prop SDTIM_SETUP_update :: (if (CSL.C11_SUPPORT) {self.PERIOD_SETUP2 = ($1 & 0x00000FFF)} , if ((!CSL.C11_SUPPORT)) {self.PERIOD_SETUP1 = ($1 & 0x00000FFF)} , if (CSL.C11_SUPPORT) {self.XRFR_SETUP = (($1 & 0x03000000) >> 24) + 1} )
    prop SDEXT_VALUE_update :: (self.TCL_SDEXT() | self.TRAS_SDEXT() | self.TRRD_SDEXT() | self.TWR_SDEXT() | self.THZP_SDEXT() | self.RD2RD_SDEXT() | self.RD2DEAC_SDEXT() | self.RD2WR_SDEXT() | self.R2WDQM_SDEXT() | self.WR2WR_SDEXT() | self.WR2DEAC_SDEXT() | self.WR2RD_SDEXT())
    prop SDEXT_SETUP_update :: (self.TCL_SETUP = ($1 & 0x00000001) + 2, self.TRAS_SETUP = (($1 & 0x0000000E) >> 1) + 1, self.TRRD_SETUP = (($1 & 0x00000010) >> 4) + 2, self.TWR_SETUP = (($1 & 0x00000060) >> 5) + 1, self.THZP_SETUP = (($1 & 0x00000180) >> 7) + 1, self.RD2RD_SETUP = (($1 & 0x00000200) >> 9) + 1, self.RD2DEAC_SETUP = (($1 & 0x00000c00) >> 10) + 1, self.RD2WR_SETUP = (($1 & 0x00007000) >> 12) + 1, self.R2WDQM_SETUP = (($1 & 0x00018000) >> 15) + 1, self.WR2WR_SETUP = (($1 & 0x00020000) >> 17) + 1, self.WR2DEAC_SETUP = (($1 & 0x000c0000) >> 18) + 1, self.WR2RD_SETUP = (($1 & 0x00100000) >> 20) + 1)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((hEmif.EMIF_INIT_ENABLE == 1) && (hEmif.EMIF_INIT == self) && (hEmif.EMIF_INIT != EMIF_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hEmif.EMIF_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: emifCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst NOHOLD_SETUP :: "Enable Hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable Hold,Disable Hold"
        prop Label :: "External HOLD disable (NOHOLD)"
        prop JSName :: "emifGblctlNoHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.NOHOLD_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst RBTR8_SETUP :: "until High-Priority" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "until High-Priority,8 accesses Minimum"
        prop Label :: "Requester Arbitration (RBTR8)"
        prop JSName :: "emifGblctlRbtr8"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (if (CSL.C11_SUPPORT) {0} else {1})
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.RBTR8_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst SSCRT_SETUP :: "1/2 CPU clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1/2 CPU clock,1 CPU clock"
        prop Label :: "SBSRAM Clock Rate (SSCRT)"
        prop JSName :: "emifGblctlSscrt"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (CSL.CHIP_6201 || CSL.CHIP_6701)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.SSCRT_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst CLK2EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT2 Enable (CLK2EN)"
        prop JSName :: "emifGblctlClk2En"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (CSL.CHIP_6201 || CSL.CHIP_6701 || CSL.C11_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.CLK2EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst CLK1EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT1 Enable (CLK1EN)"
        prop JSName :: "emifGblctlClk1En"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.CLK1EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst SSCEN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "SBSRAM CLK Enable (SSCEN)"
        prop JSName :: "emifGblctlSscen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (!CSL.C11_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.SSCEN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst SDCEN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "SDRAM CLK Enable (SDCEN)"
        prop JSName :: "emifGblctlSdcen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (!CSL.C11_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.SDCEN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst MTYPE0_SETUP :: = (if (!CSL.CHIP_6712) {"32-bit async. interf."} else {" 8-bit async. interf."}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifCectl0Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {self.error("Memory type available for 6211/671x only")} else {self.MTYPE0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}}}} else {if (CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {self.error(" 6712 supports 16-bit EMIF only")} else {self.MTYPE0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}})
    }
    inst RDSTRB0_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst RDSETUP0_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst RDHLD0_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}})
    }
    inst WRSTRB0_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0WriteStobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst WRSETUP0_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0WriterSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst WRHLD0_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}})
    }
    inst TA0_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl0Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (if (CSL.C11_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.TA0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst MTYPE1_SETUP :: = (if (!CSL.CHIP_6712) {"32-bit async. interf."} else {" 8-bit async. interf."}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 8-bit ROM,16-bit ROM, 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifCectl1Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {self.error("Memory type available for 6211/671x only")} else {if ($1 == "32-bit SDRAM") {self.error("Memory type not available for CE1 Space")} else {self.MTYPE1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}}}}} else {if (CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {self.error(" 6712 supports 16-bit EMIF only")} else {if ($1 == " 8-bit ROM" || $1 == "16-bit ROM") {self.error("Memory type not available for 6211/671x only")} else {self.MTYPE1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}}})
    }
    inst RDSTRB1_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst RDSETUP1_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst RDHLD1_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}})
    }
    inst WRSTRB1_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst WRSETUP1_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst WRHLD1_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}})
    }
    inst TA1_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl1Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (if (CSL.C11_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.TA1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst MTYPE2_SETUP :: = (if (!CSL.CHIP_6712) {"32-bit async. interf."} else {" 8-bit async. interf."}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifCectl2Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {self.error("Memory type available for 6211/671x only")} else {self.MTYPE2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}}}} else {if (CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {self.error(" 6712 supports 16-bit EMIF only")} else {self.MTYPE2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}})
    }
    inst RDSTRB2_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst RDSETUP2_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst RDHLD2_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}})
    }
    inst WRSTRB2_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst WRSETUP2_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst WRHLD2_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}})
    }
    inst TA2_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl2Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (if (CSL.C11_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.TA2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst MTYPE3_SETUP :: = (if (!CSL.CHIP_6712) {"32-bit async. interf."} else {" 8-bit async. interf."}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifCectl3Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {self.error("Memory type available for 6211/671x only")} else {if ($1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {self.error("Memory type available for 6211/671x only")} else {self.MTYPE3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}}}} else {if (CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {self.error(" 6712 supports 16-bit EMIF only")} else {self.MTYPE3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}})
    }
    inst RDSTRB3_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst RDSETUP3_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst RDHLD3_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}})
    }
    inst WRSTRB3_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst WRSETUP3_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst WRHLD3_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}})
    }
    inst TA3_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifCectl3Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (if (CSL.C11_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.TA3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst TRC_SETUP :: 15 { 
        prop Label :: "TRC = trc/(clk period-1) (TRC) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdctlTrc"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRC = 0 - Maximum TRC = 15 ")} else {self.TRC_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst TRP_SETUP :: 8 { 
        prop Label :: "TRP = trp/(clk period-1) (TRP) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdctlTrp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRP = 0 - Maximum TRP= 15 ")} else {self.TRP_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst TRCD_SETUP :: self.TRCD_Init { 
        prop Label :: "TRCD = trcd/(clk period-1) (TRCD) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdctlTrcd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRCD = 0 - Maximum TRCD= 15 ")} else {self.TRCD_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst INIT_SETUP :: "Initialize" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Initialize,No effect"
        prop Label :: "Initialization of all SDRAMs (INIT)"
        prop JSName :: "emifSdctlInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.INIT_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst RFEN_SETUP :: "Enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
        prop Label :: "SDRAM Refresh Enable (RFEN)"
        prop JSName :: "emifSdctlRfen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.RFEN_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDWID_SETUP :: "Four 8-bit SDRAMs" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Four 8-bit SDRAMs,Two 16-bit SDRAMs"
        prop Label :: "Width Select (SDWID)"
        prop JSName :: "emifSdctlSdwid"
        prop Visible :: if ((!CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((!CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDWID_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst PERIOD_SETUP1 :: 64 { 
        prop Label :: "Refresh Period (CLKOUT2 cycles)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdtimClk2Period"
        prop Visible :: if ((!CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((!CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4095) {self.error("Refresh Period range [1..4095] clk. cycl.")} else {self.PERIOD_SETUP1 = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst SDCSZ_SETUP :: " 9 addresses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 9 addresses, 8 addresses,10 addresses"
        prop Label :: "Column Size (SDCSZ)"
        prop JSName :: "emifSdctlSdcsz"
        prop Visible :: if ((CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDCSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDRSZ_SETUP :: "11 addresses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "11 addresses,12 addresses,13 addresses"
        prop Label :: "Row Size (SDRSZ)"
        prop JSName :: "emifSdctlSdrsz"
        prop Visible :: if ((CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDRSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDBSZ_SETUP :: "Two banks" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Two banks,Four banks"
        prop Label :: "Bank Size (SDBSZ)"
        prop JSName :: "emifSdctlSdbsz"
        prop Visible :: if ((CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDBSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst PERIOD_SETUP2 :: 1500 { 
        prop Label :: "Refresh Period (ECLKOUT cycles)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdtimEclkPeriod"
        prop Visible :: if ((CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4096) {self.error("1 cyc. < PERIOD < 4096 cyc. ")} else {self.PERIOD_SETUP2 = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst XRFR_SETUP :: 1 { 
        prop Label :: "Extra Refreshes Ctrl. (XRFR)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdctlXrfr"
        prop Visible :: if ((CSL.C11_SUPPORT)) {1} else {0}
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < Extra refreshes < 4 ")} else {self.XRFR_SETUP = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst TCL_SETUP :: 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CAS Latency (TCL)"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextTcl"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 2 || $1 > 3) {self.error("TCL : 2 or 3 ECLKOUT cycles ")} else {self.TCL_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TRAS_SETUP :: 8 { 
        prop Label :: "tras = TRAS + 1 (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextTras"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 8) {self.error("1 ECLKOUT cycle < tras < 8 ECLKOUT cycles ")} else {self.TRAS_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TRRD_SETUP :: 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "trrd = TRRD (2 or 3 ECLKOUT cyc.)"
        prop JSName :: "emifSdextTrrd"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 2 || $1 > 3) {self.error("TRRD : 2 or 3 ECLKOUT cycles ")} else {self.TRRD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TWR_SETUP :: 2 { 
        prop Label :: "twr  = TWR + 1 (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextTwr"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 ECLKOUT cycle < twr < 4 ECLKOUT cycles ")} else {self.TWR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst THZP_SETUP :: 3 { 
        prop Label :: "thzp = THZP + 1 (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextThzp"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 ECLKOUT cycle < thzp < 4 ECLKOUT cycles ")} else {self.THZP_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2RD_SETUP :: 2 { 
        prop Label :: "READ-To-READ (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextRd2rd"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOUT cycles < 2  ")} else {self.RD2RD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2DEAC_SETUP :: 4 { 
        prop Label :: "READ-To-DEAC/DEAB (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextRd2deac"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of ECLKOUT cycles < 4  ")} else {self.RD2DEAC_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2WR_SETUP :: 6 { 
        prop Label :: "READ-To-WRITE (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextRd2wr"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 8) {self.error("1 < # of ECLKOUT cycles < 8  ")} else {self.RD2WR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst R2WDQM_SETUP :: 4 { 
        prop Label :: "READ-To-WRITE with Interrupt (BEx cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextR2wdqm"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of Bex cycles < 4  ")} else {self.R2WDQM_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2WR_SETUP :: 2 { 
        prop Label :: "WRITE-To-WRITE (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextWr2wr"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOUT cycles < 2  ")} else {self.WR2WR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2DEAC_SETUP :: 2 { 
        prop Label :: "WRITE-To-DEAC/DEAB (ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextWr2deac"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of ECLKOUT cycles < 4  ")} else {self.WR2DEAC_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2RD_SETUP :: 2 { 
        prop Label :: "WRITE-To-READ (# of ECLKOUT cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifSdextWr2rd"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && ((CSL.C11_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOUT cycles < 2  ")} else {self.WR2RD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst GBLCTL_VALUE :: self.GBLCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Control Reg. (GBLCTL) "
        prop Format :: "0x%08X"
        prop JSName :: "emifGblctl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (if (CSL.C11_SUPPORT) {$a = $1 & 0xFFFFC000, if ($a != 0) {self.error("Bit field(bit[14..31]) is reserved")} else {$b = $1 & 0x00000007, if ($b != 0) {self.error("Bit field(bit[0..2]) is reserved")} else {self.GBLCTL_VALUE = $1 | 0x0003000 | 0x00000060, self.GBLCTL_SETUP_update($1 | 0x0003000 | 0x00000060), "ok"}}} else {if (CSL.CHIP_6202 || CSL.CHIP_6203 || CSL.CHIP_6204 || CSL.CHIP_6205) {$c = $1 & 0xFFFFC000, if ($c != 0) {self.error("Bit field(bit[14..31]) is reserved")} else {$d = $1 & 0x00000800, if ($d != 0) {self.error("Bit field 11 is reserved")} else {$e = $1 & 0x00000004, if ($e != 0) {self.error("Bit field 2 is reserved")} else {self.GBLCTL_VALUE = $1 | 0x0003000, self.GBLCTL_SETUP_update($1 | 0x0003000), "ok"}}}} else {if (CSL.CHIP_6201 || CSL.CHIP_6701) {$f = $1 & 0xFFFFC000, if ($f != 0) {self.error("Bit field(bit[14..31]) is reserved")} else {$g = $1 & 0x00000800, if ($g != 0) {self.error("Bit field 11 is reserved")} else {self.GBLCTL_VALUE = $1 | 0x0003000, self.GBLCTL_SETUP_update($1 | 0x0003000), "ok"}}} }})
    }
    inst CECTL0_VALUE :: self.CECTL0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Control Reg. (CECTL0) "
        prop Format :: "0x%08X"
        prop JSName :: "emifCectl0"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, if ($a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if (CSL.C11_SUPPORT) {$b = $1 & 0x000000F0, if ($b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {self.error("Undefined Memory type for CEx Spaces - See CEx Space Pages")} else {$g = $1 & 0x00000008, if ($g != 0) {self.error("Bit field 3 is reserved")} else {self.CECTL0_VALUE = $1, self.CECTL0_SETUP_update($1), "ok"}}} else {$c = $1 & 0x00000070, if ($c == 0x00000000 || $c == 0x00000010) {self.error("Undefined Memory type for CE0 Space - See CE0 Space Page")} else {$d = $1 & 0x0000C000, if ($d != 0) {self.error("Bit field(bit[14..15]) is reserved")} else {$e = $1 & 0x00000080, if ($e != 0) {self.error("Bit field 7 is reserved")} else {$f = $1 & 0x0000000C, if ($f != 0) {self.error("Bit field(bit[2..3]) is reserved")} else {self.CECTL0_VALUE = $1, self.CECTL0_SETUP_update($1), "ok"}}}}}})
    }
    inst CECTL1_VALUE :: self.CECTL1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Control Reg. (CECTL1) "
        prop Format :: "0x%08X"
        prop JSName :: "emifCectl1"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, if ($a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if (CSL.C11_SUPPORT) {$b = $1 & 0x000000F0, if ($b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {self.error("Undefined Memory type for CEx Spaces - See CEx Space Pages")} else {$g = $1 & 0x00000008, if ($g != 0) {self.error("Bit field 3 is reserved")} else {self.CECTL1_VALUE = $1, self.CECTL1_SETUP_update($1), "ok"}}} else {$c = $1 & 0x00000070, if ($c == 0x00000030) {self.error("Undefined Memory type for CE1 Space - See CE1 Space Page")} else {$d = $1 & 0x0000C000, if ($d != 0) {self.error("Bit field(bit[14..15]) is reserved")} else {$e = $1 & 0x00000080, if ($e != 0) {self.error("Bit field 7 is reserved")} else {$f = $1 & 0x0000000C, if ($f != 0) {self.error("Bit field(bit[2..3]) is reserved")} else {self.CECTL1_VALUE = $1, self.CECTL1_SETUP_update($1), "ok"}}}}}})
    }
    inst CECTL2_VALUE :: self.CECTL2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Control Reg. (CECTL2) "
        prop Format :: "0x%08X"
        prop JSName :: "emifCectl2"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, if ($a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if (CSL.C11_SUPPORT) {$b = $1 & 0x000000F0, if ($b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {self.error("Undefined Memory type for CEx Spaces - See CEx Space Pages")} else {$g = $1 & 0x00000008, if ($g != 0) {self.error("Bit field 3 is reserved")} else {self.CECTL2_VALUE = $1, self.CECTL2_SETUP_update($1), "ok"}}} else {$c = $1 & 0x00000070, if ($c == 0x00000000 || $c == 0x00000010) {self.error("Undefined Memory type for CE2 Space - See CE2 Space Page")} else {$d = $1 & 0x0000C000, if ($d != 0) {self.error("Bit field(bit[14..15]) is reserved")} else {$e = $1 & 0x00000080, if ($e != 0) {self.error("Bit field 7 is reserved")} else {$f = $1 & 0x0000000C, if ($f != 0) {self.error("Bit field(bit[2..3]) is reserved")} else {self.CECTL2_VALUE = $1, self.CECTL2_SETUP_update($1), "ok"}}}}}})
    }
    inst CECTL3_VALUE :: self.CECTL3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Control Reg. (CECTL3) "
        prop Format :: "0x%08X"
        prop JSName :: "emifCectl3"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, if ($a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if (CSL.C11_SUPPORT) {$b = $1 & 0x000000F0, if ($b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {self.error("Undefined Memory type for CEx Spaces - See CEx Space Pages")} else {$g = $1 & 0x00000008, if ($g != 0) {self.error("Bit field 3 is reserved")} else {self.CECTL3_VALUE = $1, self.CECTL3_SETUP_update($1), "ok"}}} else {$c = $1 & 0x00000070, if ($c == 0x00000000 || $c == 0x00000010) {self.error("Undefined Memory type for CE3 Space - See CE3 Space Page")} else {$d = $1 & 0x0000C000, if ($d != 0) {self.error("Bit field(bit[14..15]) is reserved")} else {$e = $1 & 0x00000080, if ($e != 0) {self.error("Bit field 7 is reserved")} else {$f = $1 & 0x0000000C, if ($f != 0) {self.error("Bit field(bit[2..3]) is reserved")} else {self.CECTL3_VALUE = $1, self.CECTL3_SETUP_update($1), "ok"}}}}}})
    }
    inst SDCTL_VALUE :: self.SDCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Control Reg.(SDCTL) "
        prop Format :: "0x%08X"
        prop JSName :: "emifSdctl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x0c000000, if ($a == 0x0c000000) {self.error("Undefined Value for Colum Size field SDCSZ")} else {$b = $1 & 0x30000000, if ($b == 0x30000000) {self.error("Undefined Value for Row Size field SDRSZ")} else {self.SDCTL_VALUE = $1, self.SDCTL_SETUP_update($1), "ok"}})
    }
    inst SDTIM_VALUE :: self.SDTIM_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Timing Reg.(SDTIM) "
        prop Format :: "0x%08X"
        prop JSName :: "emifSdtim"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SDTIM_VALUE = $1, self.SDTIM_SETUP_update($1), "ok")
    }
    inst SDEXT_VALUE :: self.SDEXT_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Extended Reg.(SDEXT) "
        prop Format :: "0x%08X"
        prop JSName :: "emifSdext"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && (CSL.C11_SUPPORT) {1} else {0}
        prop NoGen :: 0
        prop cGen :: if (CSL.C11_SUPPORT) {1} else {0}
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SDEXT_VALUE = $1, self.SDEXT_SETUP_update($1), "ok")
    }
}

type hEmif {
    prop IsContainedIn :: EMIFFOLDER
    prop name :: "hEmif"
    prop Label :: "EMIF Resource Manager"
    prop JSName :: "HEMIF"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6520-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6521-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1042)
    prop cGen :: 1
    global EMIF_INIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "emifEnablePreInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && 1
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; emifCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.EMIF_INIT == EMIF_NOTHING) {" You must create a new configuration object"} else {self.EMIF_INIT_ENABLE = $1, if ($1 == 0) {self.EMIF_INIT = EMIF_NOTHING} , "ok"})
    }
    global EMIF_INIT :: EMIF_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: emifCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "emifPreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIF_SUPPORT) && (self.EMIF_INIT_ENABLE == 1) {1} else {0}
    }
}

object EMIF_NOTHING :: emifCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param NOHOLD_SETUP :: "Enable Hold"
    param RBTR8_SETUP :: "until High-Priority"
    param SSCRT_SETUP :: "1/2 CPU clock"
    param CLK2EN_SETUP :: "Enabled to clock"
    param CLK1EN_SETUP :: "Enabled to clock"
    param SSCEN_SETUP :: "Enabled to clock"
    param SDCEN_SETUP :: "Enabled to clock"
    param RDSTRB0_SETUP :: 63
    param RDSETUP0_SETUP :: 15
    param RDHLD0_SETUP :: 3
    param WRSTRB0_SETUP :: 63
    param WRSETUP0_SETUP :: 15
    param WRHLD0_SETUP :: 3
    param TA0_SETUP :: 3
    param RDSTRB1_SETUP :: 63
    param RDSETUP1_SETUP :: 15
    param RDHLD1_SETUP :: 3
    param WRSTRB1_SETUP :: 63
    param WRSETUP1_SETUP :: 15
    param WRHLD1_SETUP :: 3
    param TA1_SETUP :: 3
    param RDSTRB2_SETUP :: 63
    param RDSETUP2_SETUP :: 15
    param RDHLD2_SETUP :: 3
    param WRSTRB2_SETUP :: 63
    param WRSETUP2_SETUP :: 15
    param WRHLD2_SETUP :: 3
    param TA2_SETUP :: 3
    param RDSTRB3_SETUP :: 63
    param RDSETUP3_SETUP :: 15
    param RDHLD3_SETUP :: 3
    param WRSTRB3_SETUP :: 63
    param WRSETUP3_SETUP :: 15
    param WRHLD3_SETUP :: 3
    param TA3_SETUP :: 3
    param TRC_SETUP :: 15
    param TRP_SETUP :: 8
    param TRCD_SETUP :: 8
    param INIT_SETUP :: "Initialize"
    param RFEN_SETUP :: "Enable"
    param SDWID_SETUP :: "Four 8-bit SDRAMs"
    param PERIOD_SETUP1 :: 64
    param SDCSZ_SETUP :: " 9 addresses"
    param SDRSZ_SETUP :: "11 addresses"
    param SDBSZ_SETUP :: "Two banks"
    param PERIOD_SETUP2 :: 1500
    param XRFR_SETUP :: 1
    param TCL_SETUP :: 3
    param TRAS_SETUP :: 8
    param TRRD_SETUP :: 3
    param TWR_SETUP :: 2
    param THZP_SETUP :: 3
    param RD2RD_SETUP :: 2
    param RD2DEAC_SETUP :: 4
    param RD2WR_SETUP :: 6
    param R2WDQM_SETUP :: 4
    param WR2WR_SETUP :: 2
    param WR2DEAC_SETUP :: 2
    param WR2RD_SETUP :: 2
    param GBLCTL_VALUE :: 12408
    param CECTL0_VALUE :: -49373
    param CECTL1_VALUE :: -49373
    param CECTL2_VALUE :: -49373
    param CECTL3_VALUE :: -49373
    param SDCTL_VALUE :: 59305984
    param SDTIM_VALUE :: 64
    param SDEXT_VALUE :: 1564479
}

type EMIFAFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL
    prop name :: "EMIFA"
    prop Label :: "EMIFA - External Memory Interface A (64x devices only)"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6530-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6531-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1043)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type emifaCfg {
    isa ObjectMgr
    prop Name :: "emifaCfg"
    prop Label :: "EMIFA Configuration Manager"
    prop JSName :: "EMIFA"
    prop IsContainedIn :: EMIFAFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6532-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6533-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1044)
    prop InstanceHelpTopic :: (1044)
    prop cGen :: CSL.EMIFA_SUPPORT
    prop cStruct :: 1
    prop cStructType :: "EMIFA_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_emifa.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "EMIFA_config"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; emifaCfg) {$a = $a + 1}, if ($a == 2) {hEmifa.EMIFA_INIT_ENABLE = 0} , "ok")
    prop NOHOLD_GBLCTL :: (if (self.NOHOLD_SETUP == "Disable Hold") {0x00000080} else {0x00000000})
    prop CLK4EN_GBLCTL :: (if (self.CLK4EN_SETUP == "Held high") {0x00000000} else {0x00000010})
    prop CLK6EN_GBLCTL :: (if (self.CLK6EN_SETUP == "Held high") {0x00000000} else {0x00000008})
    prop EK1EN_GBLCTL :: (if (self.EK1EN_SETUP == "Held low") {0x00000000} else {0x00000020})
    prop EK2EN_GBLCTL :: (if (self.EK2EN_SETUP == "Held low") {0x00000000} else {0x00010000})
    prop EK1HZ_GBLCTL :: (if (self.EK1HZ_SETUP == "Clock during hold") {0x00000000} else {0x00000040})
    prop EK2HZ_GBLCTL :: (if (self.EK2HZ_SETUP == "Clock during hold") {0x00000000} else {0x00020000})
    prop EK2RATE_GBLCTL :: (if (self.EK2RATE_SETUP == "1x EMIF input clock") {0x00000000} else {if (self.EK2RATE_SETUP == "1/2x EMIF input clock") {0x00040000} else {if (self.EK2RATE_SETUP == "1/4x EMIF input clock") {0x00080000} }})
    prop BRMODE_GBLCTL :: (if (self.BRMODE_SETUP == "access pending or in progress") {0x00000000} else {if (self.BRMODE_SETUP == "access/refresh pending or in progress") {0x00002000} })
    prop MTYPE0_CECTL0 :: (if (self.MTYPE0_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE0_SETUP == "32-bit SDRAM") {0x00000030} else {if (self.MTYPE0_SETUP == "32-bit prog. sync. mem") {0x00000040} else {if (self.MTYPE0_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE0_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE0_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE0_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE0_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE0_SETUP == "16-bit prog. sync. mem") {0x000000b0} else {if (self.MTYPE0_SETUP == "64-bit async. interf.") {0x000000c0} else {if (self.MTYPE0_SETUP == "64-bit SDRAM") {0x000000d0} else {if (self.MTYPE0_SETUP == "64-bit prog. sync. mem") {0x000000e0} }}}}}}}}}}})
    prop RDSTRB0_CECTL0 :: (((self.RDSTRB0_SETUP) << 8))
    prop RDSETUP0_CECTL0 :: (((self.RDSETUP0_SETUP) << 16))
    prop RDHLD0_CECTL0 :: ((self.RDHLD0_SETUP))
    prop WRSTRB0_CECTL0 :: (((self.WRSTRB0_SETUP) << 22))
    prop WRSETUP0_CECTL0 :: (((self.WRSETUP0_SETUP) << 28))
    prop WRHLD0_CECTL0 :: (if (self.WRHLD0_SETUP > 3) {((self.WRHLD0_SETUP - 4) << 20)} else {((self.WRHLD0_SETUP << 20))})
    prop WRHLDMSB0_CECTL0 :: (if (self.WRHLD0_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA0_CECTL0 :: ((self.TA0_SETUP << 14))
    prop MTYPE1_CECTL1 :: (if (self.MTYPE1_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE1_SETUP == "32-bit SDRAM") {0x00000030} else {if (self.MTYPE1_SETUP == "32-bit prog. sync. mem") {0x00000040} else {if (self.MTYPE1_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE1_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE1_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE1_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE1_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE1_SETUP == "16-bit prog. sync. mem") {0x000000b0} else {if (self.MTYPE1_SETUP == "64-bit async. interf.") {0x000000c0} else {if (self.MTYPE1_SETUP == "64-bit SDRAM") {0x000000d0} else {if (self.MTYPE1_SETUP == "64-bit prog. sync. mem") {0x000000e0} }}}}}}}}}}})
    prop RDSTRB1_CECTL1 :: (((self.RDSTRB1_SETUP) << 8))
    prop RDSETUP1_CECTL1 :: (((self.RDSETUP1_SETUP) << 16))
    prop RDHLD1_CECTL1 :: ((self.RDHLD1_SETUP))
    prop WRSTRB1_CECTL1 :: (((self.WRSTRB1_SETUP) << 22))
    prop WRSETUP1_CECTL1 :: (((self.WRSETUP1_SETUP) << 28))
    prop WRHLD1_CECTL1 :: (if (self.WRHLD1_SETUP > 3) {((self.WRHLD1_SETUP - 4) << 20)} else {((self.WRHLD1_SETUP << 20))})
    prop WRHLDMSB1_CECTL1 :: (if (self.WRHLD1_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA1_CECTL1 :: ((self.TA1_SETUP << 14))
    prop MTYPE2_CECTL2 :: (if (self.MTYPE2_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE2_SETUP == "32-bit SDRAM") {0x00000030} else {if (self.MTYPE2_SETUP == "32-bit prog. sync. mem") {0x00000040} else {if (self.MTYPE2_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE2_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE2_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE2_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE2_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE2_SETUP == "16-bit prog. sync. mem") {0x000000b0} else {if (self.MTYPE2_SETUP == "64-bit async. interf.") {0x000000c0} else {if (self.MTYPE2_SETUP == "64-bit SDRAM") {0x000000d0} else {if (self.MTYPE2_SETUP == "64-bit prog. sync. mem") {0x000000e0} }}}}}}}}}}})
    prop RDSTRB2_CECTL2 :: (((self.RDSTRB2_SETUP) << 8))
    prop RDSETUP2_CECTL2 :: (((self.RDSETUP2_SETUP) << 16))
    prop RDHLD2_CECTL2 :: ((self.RDHLD2_SETUP))
    prop WRSTRB2_CECTL2 :: (((self.WRSTRB2_SETUP) << 22))
    prop WRSETUP2_CECTL2 :: (((self.WRSETUP2_SETUP) << 28))
    prop WRHLD2_CECTL2 :: (if (self.WRHLD2_SETUP > 3) {((self.WRHLD2_SETUP - 4) << 20)} else {((self.WRHLD2_SETUP << 20))})
    prop WRHLDMSB2_CECTL2 :: (if (self.WRHLD2_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA2_CECTL2 :: ((self.TA2_SETUP << 14))
    prop MTYPE3_CECTL3 :: (if (self.MTYPE3_SETUP == "32-bit async. interf.") {0x00000020} else {if (self.MTYPE3_SETUP == "32-bit SDRAM") {0x00000030} else {if (self.MTYPE3_SETUP == "32-bit prog. sync. mem") {0x00000040} else {if (self.MTYPE3_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE3_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE3_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE3_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE3_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE3_SETUP == "16-bit prog. sync. mem") {0x000000b0} else {if (self.MTYPE3_SETUP == "64-bit async. interf.") {0x000000c0} else {if (self.MTYPE3_SETUP == "64-bit SDRAM") {0x000000d0} else {if (self.MTYPE3_SETUP == "64-bit prog. sync. mem") {0x000000e0} }}}}}}}}}}})
    prop RDSTRB3_CECTL3 :: (((self.RDSTRB3_SETUP) << 8))
    prop RDSETUP3_CECTL3 :: (((self.RDSETUP3_SETUP) << 16))
    prop RDHLD3_CECTL3 :: ((self.RDHLD3_SETUP))
    prop WRSTRB3_CECTL3 :: (((self.WRSTRB3_SETUP) << 22))
    prop WRSETUP3_CECTL3 :: (((self.WRSETUP3_SETUP) << 28))
    prop WRHLD3_CECTL3 :: (if (self.WRHLD3_SETUP > 3) {((self.WRHLD3_SETUP - 4) << 20)} else {((self.WRHLD3_SETUP << 20))})
    prop WRHLDMSB3_CECTL3 :: (if (self.WRHLD3_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA3_CECTL3 :: ((self.TA3_SETUP << 14))
    prop SYNCRL0_CESEC0 :: (if (self.SYNCRL0_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL0_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL0_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL0_CESEC0 :: (if (self.SYNCWL0_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL0_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL0_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT0_CESEC0 :: (if (self.CEEXT0_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN0_CESEC0 :: (if (self.RENEN0_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK0_CESEC0 :: (if (self.SNCCLK0_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop SYNCRL1_CESEC1 :: (if (self.SYNCRL1_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL1_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL1_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL1_CESEC1 :: (if (self.SYNCWL1_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL1_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL1_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT1_CESEC1 :: (if (self.CEEXT1_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN1_CESEC1 :: (if (self.RENEN1_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK1_CESEC1 :: (if (self.SNCCLK1_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop SYNCRL2_CESEC2 :: (if (self.SYNCRL2_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL2_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL2_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL2_CESEC2 :: (if (self.SYNCWL2_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL2_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL2_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT2_CESEC2 :: (if (self.CEEXT2_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN2_CESEC2 :: (if (self.RENEN2_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK2_CESEC2 :: (if (self.SNCCLK2_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop SYNCRL3_CESEC3 :: (if (self.SYNCRL3_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL3_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL3_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL3_CESEC3 :: (if (self.SYNCWL3_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL3_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL3_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT3_CESEC3 :: (if (self.CEEXT3_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN3_CESEC3 :: (if (self.RENEN3_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK3_CESEC3 :: (if (self.SNCCLK3_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop TRC_SDCTL :: ((self.TRC_SETUP << 12))
    prop TRP_SDCTL :: ((self.TRP_SETUP << 16))
    prop TRCD_SDCTL :: ((self.TRCD_SETUP << 20))
    prop INIT_SDCTL :: (if (self.INIT_SETUP == "Initialize") {0x01000000} else {0x00000000})
    prop RFEN_SDCTL :: (if (self.RFEN_SETUP == "Enable") {0x02000000} else {0x00000000})
    prop SDCSZ_SDCTL :: (if (self.SDCSZ_SETUP == " 8 addresses") {0x04000000} else {if (self.SDCSZ_SETUP == "10 addresses") {0x08000000} else {0x00000000}})
    prop SDRSZ_SDCTL :: (if (self.SDRSZ_SETUP == "12 addresses") {0x10000000} else {if (self.SDRSZ_SETUP == "13 addresses") {0x20000000} else {0x00000000}})
    prop SDBSZ_SDCTL :: (if (self.SDBSZ_SETUP == "Four banks") {0x40000000} else {0x00000000})
    prop SLFRFR_SDCTL :: (if (self.SLFRFR_SETUP == "Enable") {0x00000001} else {0x00000000})
    prop PERIOD_SDTIM2 :: ((self.PERIOD_SETUP2))
    prop XRFR_SDTIM :: (((self.XRFR_SETUP - 1) << 24))
    prop TCL_SDEXT :: ((self.TCL_SETUP - 2))
    prop TRAS_SDEXT :: (((self.TRAS_SETUP - 1) << 1))
    prop TRRD_SDEXT :: ((self.TRRD_SETUP - 2) << 4)
    prop TWR_SDEXT :: (((self.TWR_SETUP - 1) << 5))
    prop THZP_SDEXT :: (((self.THZP_SETUP - 1) << 7))
    prop RD2RD_SDEXT :: (((self.RD2RD_SETUP - 1) << 9))
    prop RD2DEAC_SDEXT :: (((self.RD2DEAC_SETUP - 1) << 10))
    prop RD2WR_SDEXT :: (((self.RD2WR_SETUP - 1) << 12))
    prop R2WDQM_SDEXT :: (((self.R2WDQM_SETUP - 1) << 15))
    prop WR2WR_SDEXT :: (((self.WR2WR_SETUP - 1) << 17))
    prop WR2DEAC_SDEXT :: (((self.WR2DEAC_SETUP - 1) << 18))
    prop WR2RD_SDEXT :: (((self.WR2RD_SETUP - 1) << 20))
    prop GBLCTL_VALUE_update :: (0x00000004 | self.NOHOLD_GBLCTL() | self.CLK4EN_GBLCTL() | self.CLK6EN_GBLCTL() | self.EK1EN_GBLCTL() | self.EK2EN_GBLCTL() | self.EK1HZ_GBLCTL() | self.EK2HZ_GBLCTL() | self.EK2RATE_GBLCTL() | self.BRMODE_GBLCTL())
    prop GBLCTL_SETUP_update :: (self.NOHOLD_SETUP = if ($1 & 0x00000080) {"Disable Hold"} else {"Enable Hold"}, self.CLK4EN_SETUP = if ($1 & 0x00000010) {"Enabled to clock"} else {"Held high"}, self.CLK6EN_SETUP = if ($1 & 0x00000008) {"Enabled to clock"} else {"Held high"}, self.EK1EN_SETUP = if ($1 & 0x00000020) {"Enabled to clock"} else {"Held low"}, self.EK2EN_SETUP = if ($1 & 0x00010000) {"Enabled to clock"} else {"Held low"}, self.EK1HZ_SETUP = if ($1 & 0x00000040) {"High-Z during hold"} else {"Clock during hold"}, self.EK2HZ_SETUP = if ($1 & 0x00020000) {"High-Z during hold"} else {"Clock during hold"}, self.BRMODE_SETUP = if ($1 & 0x00002000) {"access/refresh pending or in progress"} else {"access pending or in progress"}, $a = $1 & 0x000C0000, if ($a == 0x00080000) {self.EK2RATE_SETUP = "1/4x EMIF input clock"} else {self.EK2RATE_SETUP = if ($1 & 0x00040000) {"1/2x EMIF input clock"} else {"1x EMIF input clock"}})
    prop CECTL0_VALUE_update :: (self.MTYPE0_CECTL0() | self.RDHLD0_CECTL0() | self.RDSTRB0_CECTL0() | self.RDSETUP0_CECTL0() | self.WRHLD0_CECTL0() | self.WRHLDMSB0_CECTL0() | self.WRSETUP0_CECTL0() | self.WRSTRB0_CECTL0() | self.TA0_CECTL0())
    prop CECTL0_SETUP_update :: (self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit prog. sync. mem"} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {if ($a == 0x000000b0) {"16-bit prog. sync. mem"} else {if ($a == 0x000000c0) {"64-bit async. interf."} else {if ($a == 0x000000d0) {"64-bit SDRAM"} else {"64-bit prog. sync. mem"}}}}}}}}}}}), self.RDHLD0_SETUP = ($1 & 0x00000007), self.RDSTRB0_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP0_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD0_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB0_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP0_SETUP = (($1 >> 28) & 0xF), self.TA0_SETUP = ($1 & 0x0000c000) >> 14)
    prop CECTL1_VALUE_update :: (self.MTYPE1_CECTL1() | self.RDHLD1_CECTL1() | self.RDSTRB1_CECTL1() | self.RDSETUP1_CECTL1() | self.WRHLD1_CECTL1() | self.WRHLDMSB1_CECTL1() | self.WRSETUP1_CECTL1() | self.WRSTRB1_CECTL1() | self.TA1_CECTL1())
    prop CECTL1_SETUP_update :: (self.MTYPE1_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit prog. sync. mem"} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {if ($a == 0x000000b0) {"16-bit prog. sync. mem"} else {if ($a == 0x000000c0) {"64-bit async. interf."} else {if ($a == 0x000000d0) {"64-bit SDRAM"} else {"64-bit prog. sync. mem"}}}}}}}}}}}), self.RDHLD1_SETUP = ($1 & 0x00000007), self.RDSTRB1_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP1_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD1_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB1_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP1_SETUP = (($1 >> 28) & 0xF), self.TA1_SETUP = ($1 & 0x0000c000) >> 14)
    prop CECTL2_VALUE_update :: (self.MTYPE2_CECTL2() | self.RDHLD2_CECTL2() | self.RDSTRB2_CECTL2() | self.RDSETUP2_CECTL2() | self.WRHLD2_CECTL2() | self.WRHLDMSB2_CECTL2() | self.WRSETUP2_CECTL2() | self.WRSTRB2_CECTL2() | self.TA2_CECTL2())
    prop CECTL2_SETUP_update :: (self.MTYPE2_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit prog. sync. mem"} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {if ($a == 0x000000b0) {"16-bit prog. sync. mem"} else {if ($a == 0x000000c0) {"64-bit async. interf."} else {if ($a == 0x000000d0) {"64-bit SDRAM"} else {"64-bit prog. sync. mem"}}}}}}}}}}}), self.RDHLD2_SETUP = ($1 & 0x00000007), self.RDSTRB2_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP2_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD2_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB2_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP2_SETUP = (($1 >> 28) & 0xF), self.TA2_SETUP = ($1 & 0x0000c000) >> 14)
    prop CECTL3_VALUE_update :: (self.MTYPE3_CECTL3() | self.RDHLD3_CECTL3() | self.RDSTRB3_CECTL3() | self.RDSETUP3_CECTL3() | self.WRHLD3_CECTL3() | self.WRHLDMSB3_CECTL3() | self.WRSETUP3_CECTL3() | self.WRSTRB3_CECTL3() | self.TA3_CECTL3())
    prop CECTL3_SETUP_update :: (self.MTYPE3_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000020) {"32-bit async. interf."} else {if ($a == 0x00000030) {"32-bit SDRAM"} else {if ($a == 0x00000040) {"32-bit prog. sync. mem"} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {if ($a == 0x000000b0) {"16-bit prog. sync. mem"} else {if ($a == 0x000000c0) {"64-bit async. interf."} else {if ($a == 0x000000d0) {"64-bit SDRAM"} else {"64-bit prog. sync. mem"}}}}}}}}}}}), self.RDHLD3_SETUP = ($1 & 0x00000007), self.RDSTRB3_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP3_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD3_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB3_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP3_SETUP = (($1 >> 28) & 0xF), self.TA3_SETUP = ($1 & 0x0000c000) >> 14)
    prop SDCTL_VALUE_update :: (self.TRC_SDCTL() | self.TRP_SDCTL() | self.SLFRFR_SDCTL() | self.TRCD_SDCTL() | self.INIT_SDCTL() | self.RFEN_SDCTL() | self.SDCSZ_SDCTL() | self.SDRSZ_SDCTL() | self.SDBSZ_SDCTL())
    prop SDCTL_SETUP_update :: (self.TRC_SETUP = ($1 & 0x0000F000) >> 12, self.TRP_SETUP = ($1 & 0x000F0000) >> 16, self.TRCD_SETUP = ($1 & 0x00F00000) >> 20, self.INIT_SETUP = ($a = ($1 & 0x01000000), if ($a == 0x01000000) {"Initialize"} else {"No effect"}), self.RFEN_SETUP = ($a = ($1 & 0x02000000), if ($a == 0x02000000) {"Enable"} else {"Disable"}), self.SDCSZ_SETUP = ($a = ($1 & 0x0c000000), if ($a == 0x04000000) {" 8 addresses"} else {if ($a == 0x08000000) {"10 addresses"} else {" 9 addresses"}}), self.SDRSZ_SETUP = ($a = ($1 & 0x30000000), if ($a == 0x10000000) {"12 addresses"} else {if ($a == 0x20000000) {"13 addresses"} else {"11 addresses"}}), self.SDBSZ_SETUP = ($a = ($1 & 0x40000000), if ($a == 0x40000000) {"Four banks"} else {"Two banks"}), self.SLFRFR_SETUP = ($a = ($1 & 0x00000001), if ($a == 0x00000001) {"Enable"} else {"Disable"}))
    prop SDTIM_VALUE_update :: (self.PERIOD_SDTIM2() | self.XRFR_SDTIM() | 0x005dc000)
    prop SDTIM_SETUP_update :: (self.PERIOD_SETUP2 = ($1 & 0x00000FFF), self.XRFR_SETUP = (($1 & 0x03000000) >> 24) + 1)
    prop SDEXT_VALUE_update :: (self.TCL_SDEXT() | self.TRAS_SDEXT() | self.TRRD_SDEXT() | self.TWR_SDEXT() | self.THZP_SDEXT() | self.RD2RD_SDEXT() | self.RD2DEAC_SDEXT() | self.RD2WR_SDEXT() | self.R2WDQM_SDEXT() | self.WR2WR_SDEXT() | self.WR2DEAC_SDEXT() | self.WR2RD_SDEXT())
    prop SDEXT_SETUP_update :: (self.TCL_SETUP = ($1 & 0x00000001) + 2, self.TRAS_SETUP = (($1 & 0x0000000E) >> 1) + 1, self.TRRD_SETUP = (($1 & 0x00000010) >> 4) + 2, self.TWR_SETUP = (($1 & 0x00000060) >> 5) + 1, self.THZP_SETUP = (($1 & 0x00000180) >> 7) + 1, self.RD2RD_SETUP = (($1 & 0x00000200) >> 9) + 1, self.RD2DEAC_SETUP = (($1 & 0x00000c00) >> 10) + 1, self.RD2WR_SETUP = (($1 & 0x00007000) >> 12) + 1, self.R2WDQM_SETUP = (($1 & 0x00018000) >> 15) + 1, self.WR2WR_SETUP = (($1 & 0x00020000) >> 17) + 1, self.WR2DEAC_SETUP = (($1 & 0x000c0000) >> 18) + 1, self.WR2RD_SETUP = (($1 & 0x00100000) >> 20) + 1)
    prop CESEC0_VALUE_update :: (self.SYNCRL0_CESEC0() | self.SYNCWL0_CESEC0() | self.CEEXT0_CESEC0() | self.RENEN0_CESEC0() | self.SNCCLK0_CESEC0())
    prop CESEC0_SETUP_update :: (self.SYNCRL0_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL0_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT0_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN0_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK0_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    prop CESEC1_VALUE_update :: (self.SYNCRL1_CESEC1() | self.SYNCWL1_CESEC1() | self.CEEXT1_CESEC1() | self.RENEN1_CESEC1() | self.SNCCLK1_CESEC1())
    prop CESEC1_SETUP_update :: (self.SYNCRL1_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL1_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT1_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN1_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK1_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    prop CESEC2_VALUE_update :: (self.SYNCRL2_CESEC2() | self.SYNCWL2_CESEC2() | self.CEEXT2_CESEC2() | self.RENEN2_CESEC2() | self.SNCCLK2_CESEC2())
    prop CESEC2_SETUP_update :: (self.SYNCRL2_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL2_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT2_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN2_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK2_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    prop CESEC3_VALUE_update :: (self.SYNCRL3_CESEC3() | self.SYNCWL3_CESEC3() | self.CEEXT3_CESEC3() | self.RENEN3_CESEC3() | self.SNCCLK3_CESEC3())
    prop CESEC3_SETUP_update :: (self.SYNCRL3_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL3_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT3_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN3_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK3_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((hEmifa.EMIFA_INIT_ENABLE == 1) && (hEmifa.EMIFA_INIT == self) && (hEmifa.EMIFA_INIT != EMIFA_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hEmifa.EMIFA_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: emifaCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst NOHOLD_SETUP :: "Enable Hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable Hold,Disable Hold"
        prop Label :: "External HOLD disable (NOHOLD)"
        prop JSName :: "emifaGblctlNoHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.NOHOLD_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst CLK4EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT4 Enable (CLK4EN)"
        prop JSName :: "emifaGblctlClk4en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.CLK4EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst CLK6EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT6 Enable (CLK6EN)"
        prop JSName :: "emifaGblctlClk6en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.CLK6EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK1EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT1 Enable (EK1EN)"
        prop JSName :: "emifaGblctlEk1en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK1EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK2EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT2 Enable (EK2EN)"
        prop JSName :: "emifaGblctlEk2en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK2EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK1HZ_SETUP :: "High-Z during hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT1 High-Z Control (EK1HZ)"
        prop JSName :: "emifaGblctlEk1hz"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK1HZ_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK2HZ_SETUP :: "Clock during hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT2 High-Z Control (EK2HZ)"
        prop JSName :: "emifaGblctlEk2hz"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK2HZ_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK2RATE_SETUP :: "1/4x EMIF input clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1x EMIF input clock,1/2x EMIF input clock,1/4x EMIF input clock"
        prop Label :: "ECLKOUT2 Rate (EK2RATE)"
        prop JSName :: "emifaGblctlEk2rate"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK2RATE_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst BRMODE_SETUP :: "access/refresh pending or in progress" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "access/refresh pending or in progress,access pending or in progress"
        prop Label :: "Bus Request Mode"
        prop JSName :: "emifaGblctlBrmode"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.BRMODE_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst MTYPE0_SETUP :: "32-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl0Mtype"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.MTYPE0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok")
    }
    inst RDSTRB0_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst RDSETUP0_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst RDHLD0_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}})
    }
    inst WRSTRB0_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst WRSETUP0_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst WRHLD0_SETUP :: 3 { 
        prop Label :: "Write Hold Width (WRHLD-WRHLDMSB) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst TA0_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl0Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst MTYPE1_SETUP :: "32-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl1Mtype"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.MTYPE1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok")
    }
    inst RDSTRB1_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst RDSETUP1_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst RDHLD1_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}})
    }
    inst WRSTRB1_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst WRSETUP1_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst WRHLD1_SETUP :: 3 { 
        prop Label :: "Write Hold Width (WRHLD - WHLDMSB) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst TA1_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl1Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst MTYPE2_SETUP :: "32-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl2Mtype"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.MTYPE2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok")
    }
    inst RDSTRB2_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst RDSETUP2_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst RDHLD2_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}})
    }
    inst WRSTRB2_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst WRSETUP2_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst WRHLD2_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst TA2_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl2Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst MTYPE3_SETUP :: "32-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl3Mtype"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.MTYPE3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok")
    }
    inst RDSTRB3_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst RDSETUP3_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst RDHLD3_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}})
    }
    inst WRSTRB3_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst WRSETUP3_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst WRHLD3_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst TA3_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaCectl3Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst SYNCRL0_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec0Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.SYNCRL0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst SYNCWL0_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop Visible :: 1
        prop JSName :: "emifaCesec0Syncwl"
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.SYNCWL0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst CEEXT0_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec0Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.CEEXT0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst RENEN0_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec0Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.RENEN0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst SNCCLK0_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec0Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.SNCCLK0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst SYNCRL1_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec1Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.SYNCRL1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst SYNCWL1_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifaCesec1Syncwl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.SYNCWL1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst CEEXT1_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec1Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.CEEXT1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst RENEN1_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec1Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.RENEN1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst SNCCLK1_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec1Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.SNCCLK1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst SYNCRL2_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec2Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.SYNCRL2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst SYNCWL2_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifaCesec2Syncwl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.SYNCWL2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst CEEXT2_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec2Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.CEEXT2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst RENEN2_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec2Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.RENEN2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst SNCCLK2_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec2Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.SNCCLK2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst SYNCRL3_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec3Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.SYNCRL3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst SYNCWL3_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifaCesec3Syncwl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.SYNCWL3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst CEEXT3_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec3Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.CEEXT3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst RENEN3_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec3Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.RENEN3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst SNCCLK3_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec3Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFA_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.SNCCLK3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst TRC_SETUP :: 15 { 
        prop Label :: "TRC = trc/(eclkout1 period-1) (TRC) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdctlTrc"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRC = 0 - Maximum TRC = 15 ")} else {self.TRC_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst TRP_SETUP :: 8 { 
        prop Label :: "TRP = trp/(eclkout1 period-1) (TRP) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdctlTrp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRP = 0 - Maximum TRP= 15 ")} else {self.TRP_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst TRCD_SETUP :: 4 { 
        prop Label :: "TRCD = trcd/(eclkout1 period-1) (TRCD) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdctlTrcd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRCD = 0 - Maximum TRCD= 15 ")} else {self.TRCD_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst INIT_SETUP :: "Initialize" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Initialize,No effect"
        prop Label :: "Initialization of all SDRAMs (INIT)"
        prop JSName :: "emifaSdctlInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.INIT_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst RFEN_SETUP :: "Enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
        prop Label :: "SDRAM Refresh Enable (RFEN)"
        prop JSName :: "emifaSdctlRfen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.RFEN_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDCSZ_SETUP :: " 9 addresses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 9 addresses, 8 addresses,10 addresses"
        prop Label :: "Column Size (SDCSZ)"
        prop JSName :: "emifaSdctlSdcsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDCSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDRSZ_SETUP :: "11 addresses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "11 addresses,12 addresses,13 addresses"
        prop Label :: "Row Size (SDRSZ)"
        prop JSName :: "emifaSdctlSdrsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDRSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDBSZ_SETUP :: "Two banks" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Two banks,Four banks"
        prop Label :: "Bank Size (SDBSZ)"
        prop JSName :: "emifaSdctlSdbsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDBSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SLFRFR_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Self-refresh mode(SLFRFR)"
        prop JSName :: "emifaSdctlSlfrfr"
        prop Visible :: 1
        prop Writable :: if ((CSL.EMIFA_SUPPORT)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SLFRFR_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst PERIOD_SETUP2 :: 1500 { 
        prop Label :: "Refresh Period (ECLKOU1 cycles)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdtimEclkPeriod"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4096) {self.error("1 cyc. < PERIOD < 4096 cyc. ")} else {self.PERIOD_SETUP2 = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst XRFR_SETUP :: 1 { 
        prop Label :: "Extra Refreshes Ctrl. (XRFR)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdctlXrfr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < Extra refreshes < 4 ")} else {self.XRFR_SETUP = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst TCL_SETUP :: 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CAS Latency (TCL)"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextTcl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 2 || $1 > 3) {self.error("TCL : 2 or 3 ECLKOU1 cycles ")} else {self.TCL_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TRAS_SETUP :: 8 { 
        prop Label :: "tras = TRAS + 1 (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextTras"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 8) {self.error("1 ECLKOU1 cycle < tras < 8 ECLKOU1 cycles ")} else {self.TRAS_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TRRD_SETUP :: 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "trrd = TRRD (2 or 3 ECLKOU1 cyc.)"
        prop JSName :: "emifaSdextTrrd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 2 || $1 > 3) {self.error("TRRD : 2 or 3 ECLKOU1 cycles ")} else {self.TRRD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TWR_SETUP :: 2 { 
        prop Label :: "twr  = TWR + 1 (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextTwr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 ECLKOU1 cycle < twr < 4 ECLKOU1 cycles ")} else {self.TWR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst THZP_SETUP :: 3 { 
        prop Label :: "thzp = THZP + 1 (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextThzp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 ECLKOU1 cycle < thzp < 4 ECLKOU1 cycles ")} else {self.THZP_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2RD_SETUP :: 2 { 
        prop Label :: "READ-To-READ (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextRd2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOU1 cycles < 2  ")} else {self.RD2RD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2DEAC_SETUP :: 4 { 
        prop Label :: "READ-To-DEAC/DEAB (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextRd2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of ECLKOU1 cycles < 4  ")} else {self.RD2DEAC_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2WR_SETUP :: 6 { 
        prop Label :: "READ-To-WRITE (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextRd2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 8) {self.error("1 < # of ECLKOU1 cycles < 8  ")} else {self.RD2WR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst R2WDQM_SETUP :: 3 { 
        prop Label :: "READ-To-WRITE with Interrupt (BEx cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextR2wdqm"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of Bex cycles < 4  ")} else {self.R2WDQM_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2WR_SETUP :: 2 { 
        prop Label :: "WRITE-To-WRITE (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextWr2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOU1 cycles < 2  ")} else {self.WR2WR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2DEAC_SETUP :: 2 { 
        prop Label :: "WRITE-To-DEAC/DEAB (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextWr2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of ECLKOU1 cycles < 4  ")} else {self.WR2DEAC_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2RD_SETUP :: 2 { 
        prop Label :: "WRITE-To-READ (# of ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifaSdextWr2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOU1 cycles < 2  ")} else {self.WR2RD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst GBLCTL_VALUE :: self.GBLCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Control Reg. (GBLCTL) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaGblctl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFF00000, $b = $1 & 0x0000C000, $c = $1 & 0x00001000, $d = $1 & 0x00000003, $e = $1 & 0x000C0000, if ($a != 0) {self.error("Bit field (31..20) is reserved")} else {if ($b != 0) {self.error("Bit field (15..14) is reserved")} else {if ($c != 0) {self.error("Bit field 12 is reserved")} else {if ($d != 0) {self.error("Bit field (1..0) is reserved")} else {if ($e == 0x000C0000) {self.error("Invalid input for EK2RATE bit[19:18]")} else {self.GBLCTL_VALUE = $1 | 0x0000004, self.GBLCTL_SETUP_update($1 | 0x0000004), "ok"}}}}})
    }
    inst CECTL0_VALUE :: self.CECTL0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Control Reg. (CECTL0) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaCectl0"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.CECTL0_VALUE = $1, self.CECTL0_SETUP_update($1), "ok"}})
    }
    inst CECTL1_VALUE :: self.CECTL1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Control Reg. (CECTL1) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaCectl1"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.CECTL1_VALUE = $1, self.CECTL1_SETUP_update($1), "ok"}})
    }
    inst CECTL2_VALUE :: self.CECTL2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Control Reg. (CECTL2) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaCectl2"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.CECTL2_VALUE = $1, self.CECTL2_SETUP_update($1), "ok"}})
    }
    inst CECTL3_VALUE :: self.CECTL3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Control Reg. (CECTL3) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaCectl3"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")} else {self.CECTL3_VALUE = $1, self.CECTL3_SETUP_update($1), "ok"}})
    }
    inst SDCTL_VALUE :: self.SDCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Control Reg.(SDCTL) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaSdctl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x0c000000, if ($a == 0x0c000000) {self.error("Undefined Value for Column Size field SDCSZ")} else {$b = $1 & 0x30000000, if ($b == 0x30000000) {self.error("Undefined Value for Row Size field SDRSZ")} else {$c = $1 & 0x80000000, if ($c == 0x80000000) {self.error("Bit field 31 is reserved")} else {$d = $1 & 0x00000FFE, if ($d != 0) {self.error("Bit field(bit[1..11]) is reserved")} else {self.SDCTL_VALUE = $1, self.SDCTL_SETUP_update($1), "ok"}}}})
    }
    inst SDTIM_VALUE :: self.SDTIM_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Timing Reg.(SDTIM) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaSdtim"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x0000FFF, if ($a == 0x00000000) {self.error("1 cyc. < PERIOD < 4096 cyc. ")} else {$b = $1 & 0xFC000000, if ($b != 0) {self.error("Bit field(bit[26..31]) is reserved")} else {self.SDTIM_VALUE = $1 | 0x005dc000, self.SDTIM_SETUP_update($1 | 0x005dc000), "ok"}})
    }
    inst SDEXT_VALUE :: self.SDEXT_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Extended Reg.(SDEXT) "
        prop Format :: "0x%08X"
        prop JSName :: "emifaSdext"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFE00000, if ($a != 0) {self.error("Bit field(bit[21..31]) is reserved")} else {self.SDEXT_VALUE = $1, self.SDEXT_SETUP_update($1), "ok"})
    }
    inst CESEC0_VALUE :: self.CESEC0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Secondary Control Reg. (CESEC0)"
        prop Format :: "0x%08X"
        prop JSName :: "emifaCesec0"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC0_VALUE = $1, self.CESEC0_SETUP_update($1), "ok"})
    }
    inst CESEC1_VALUE :: self.CESEC1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Secondary Control Reg. (CESEC1)"
        prop Format :: "0x%08X"
        prop JSName :: "emifaCesec1"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC1_VALUE = $1, self.CESEC1_SETUP_update($1), "ok"})
    }
    inst CESEC2_VALUE :: self.CESEC2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Secondary Control Reg. (CESEC2)"
        prop Format :: "0x%08X"
        prop JSName :: "emifaCesec2"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC2_VALUE = $1, self.CESEC2_SETUP_update($1), "ok"})
    }
    inst CESEC3_VALUE :: self.CESEC3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Secondary Control Reg. (CESEC3)"
        prop Format :: "0x%08X"
        prop JSName :: "emifaCesec3"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC3_VALUE = $1, self.CESEC3_SETUP_update($1), "ok"})
    }
}

type hEmifa {
    prop IsContainedIn :: EMIFAFOLDER
    prop name :: "hEmifa"
    prop Label :: "EMIF Resource Manager"
    prop JSName :: "HEMIFA"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6534-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6535-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1045)
    prop cGen :: 1
    global EMIFA_INIT_ENABLE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "emifaEnablePreInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; emifaCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.EMIFA_INIT == EMIFA_NOTHING) {" You must create a new configuration object"} else {self.EMIFA_INIT_ENABLE = $1, if ($1 == 0) {self.EMIFA_INIT = EMIFA_NOTHING} , "ok"})
    }
    global EMIFA_INIT :: MyEmifaConfig { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: emifaCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "emifaPreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFA_SUPPORT) && (self.EMIFA_INIT_ENABLE == 1) {1} else {0}
    }
}

object EMIFA_NOTHING :: emifaCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param NOHOLD_SETUP :: "Enable Hold"
    param CLK4EN_SETUP :: "Enabled to clock"
    param CLK6EN_SETUP :: "Enabled to clock"
    param EK1EN_SETUP :: "Enabled to clock"
    param EK2EN_SETUP :: "Enabled to clock"
    param EK1HZ_SETUP :: "High-Z during hold"
    param EK2HZ_SETUP :: "Clock during hold"
    param EK2RATE_SETUP :: "1/4x EMIF input clock"
    param BRMODE_SETUP :: "access/refresh pending or in progress"
    param MTYPE0_SETUP :: "32-bit async. interf."
    param RDSTRB0_SETUP :: 63
    param RDSETUP0_SETUP :: 15
    param RDHLD0_SETUP :: 3
    param WRSTRB0_SETUP :: 63
    param WRSETUP0_SETUP :: 15
    param WRHLD0_SETUP :: 3
    param TA0_SETUP :: 3
    param MTYPE1_SETUP :: "32-bit async. interf."
    param RDSTRB1_SETUP :: 63
    param RDSETUP1_SETUP :: 15
    param RDHLD1_SETUP :: 3
    param WRSTRB1_SETUP :: 63
    param WRSETUP1_SETUP :: 15
    param WRHLD1_SETUP :: 3
    param TA1_SETUP :: 3
    param MTYPE2_SETUP :: "32-bit async. interf."
    param RDSTRB2_SETUP :: 63
    param RDSETUP2_SETUP :: 15
    param RDHLD2_SETUP :: 3
    param WRSTRB2_SETUP :: 63
    param WRSETUP2_SETUP :: 15
    param WRHLD2_SETUP :: 3
    param TA2_SETUP :: 3
    param MTYPE3_SETUP :: "32-bit async. interf."
    param RDSTRB3_SETUP :: 63
    param RDSETUP3_SETUP :: 15
    param RDHLD3_SETUP :: 3
    param WRSTRB3_SETUP :: 63
    param WRSETUP3_SETUP :: 15
    param WRHLD3_SETUP :: 3
    param TA3_SETUP :: 3
    param SYNCRL0_SETUP :: "2 cycles"
    param SYNCWL0_SETUP :: "0 cycle"
    param CEEXT0_SETUP :: "Inactive"
    param RENEN0_SETUP :: "ADS Mode"
    param SNCCLK0_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL1_SETUP :: "2 cycles"
    param SYNCWL1_SETUP :: "0 cycle"
    param CEEXT1_SETUP :: "Inactive"
    param RENEN1_SETUP :: "ADS Mode"
    param SNCCLK1_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL2_SETUP :: "2 cycles"
    param SYNCWL2_SETUP :: "0 cycle"
    param CEEXT2_SETUP :: "Inactive"
    param RENEN2_SETUP :: "ADS Mode"
    param SNCCLK2_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL3_SETUP :: "2 cycles"
    param SYNCWL3_SETUP :: "0 cycle"
    param CEEXT3_SETUP :: "Inactive"
    param RENEN3_SETUP :: "ADS Mode"
    param SNCCLK3_SETUP :: "Sync. to ECLKOUT1"
    param TRC_SETUP :: 15
    param TRP_SETUP :: 8
    param TRCD_SETUP :: 4
    param INIT_SETUP :: "Initialize"
    param RFEN_SETUP :: "Enable"
    param SDCSZ_SETUP :: " 9 addresses"
    param SDRSZ_SETUP :: "11 addresses"
    param SDBSZ_SETUP :: "Two banks"
    param SLFRFR_SETUP :: "Disable"
    param PERIOD_SETUP2 :: 1500
    param XRFR_SETUP :: 1
    param TCL_SETUP :: 3
    param TRAS_SETUP :: 8
    param TRRD_SETUP :: 3
    param TWR_SETUP :: 2
    param THZP_SETUP :: 3
    param RD2RD_SETUP :: 2
    param RD2DEAC_SETUP :: 4
    param RD2WR_SETUP :: 6
    param R2WDQM_SETUP :: 3
    param WR2WR_SETUP :: 2
    param WR2DEAC_SETUP :: 2
    param WR2RD_SETUP :: 2
    param GBLCTL_VALUE :: 598140
    param CECTL0_VALUE :: -221
    param CECTL1_VALUE :: -221
    param CECTL2_VALUE :: -221
    param CECTL3_VALUE :: -221
    param SDCTL_VALUE :: 55111680
    param SDTIM_VALUE :: 6145500
    param SDEXT_VALUE :: 1531711
    param CESEC0_VALUE :: 2
    param CESEC1_VALUE :: 2
    param CESEC2_VALUE :: 2
    param CESEC3_VALUE :: 2
}

type EMIFBFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL
    prop name :: "EMIFB"
    prop Label :: "EMIFB - External Memory Interface B (64x devices only)"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6530-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6531-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1043)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type emifbCfg {
    isa ObjectMgr
    prop Name :: "emifbCfg"
    prop Label :: "EMIFB Configuration Manager"
    prop JSName :: "EMIFB"
    prop IsContainedIn :: EMIFBFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6532-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6533-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1044)
    prop InstanceHelpTopic :: (1044)
    prop cGen :: CSL.EMIFB_SUPPORT
    prop cStruct :: 1
    prop cStructType :: "EMIFB_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_emifb.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "EMIFB_config"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; emifbCfg) {$a = $a + 1}, if ($a == 2) {hEmifb.EMIFB_INIT_ENABLE = 0} , "ok")
    prop NOHOLD_GBLCTL :: (if (self.NOHOLD_SETUP == "Disable Hold") {0x00000080} else {0x00000000})
    prop CLK4EN_GBLCTL :: (if (self.CLK4EN_SETUP == "Held high") {0x00000000} else {0x00000010})
    prop CLK6EN_GBLCTL :: (if (self.CLK6EN_SETUP == "Held high") {0x00000000} else {0x00000008})
    prop EK1EN_GBLCTL :: (if (self.EK1EN_SETUP == "Held low") {0x00000000} else {0x00000020})
    prop EK2EN_GBLCTL :: (if (self.EK2EN_SETUP == "Held low") {0x00000000} else {0x00010000})
    prop EK1HZ_GBLCTL :: (if (self.EK1HZ_SETUP == "Clock during hold") {0x00000000} else {0x00000040})
    prop EK2HZ_GBLCTL :: (if (self.EK2HZ_SETUP == "Clock during hold") {0x00000000} else {0x00020000})
    prop EK2RATE_GBLCTL :: (if (self.EK2RATE_SETUP == "1x EMIF input clock") {0x00000000} else {if (self.EK2RATE_SETUP == "1/2x EMIF input clock") {0x00040000} else {if (self.EK2RATE_SETUP == "1/4x EMIF input clock") {0x00080000} }})
    prop BRMODE_GBLCTL :: (if (self.BRMODE_SETUP == "access pending or in progress") {0x00000000} else {if (self.BRMODE_SETUP == "access/refresh pending or in progress") {0x00002000} })
    prop MTYPE0_CECTL0 :: (if (self.MTYPE0_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE0_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE0_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE0_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE0_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE0_SETUP == "16-bit prog. sync. mem") {0x000000b0} }}}}})
    prop RDSTRB0_CECTL0 :: (((self.RDSTRB0_SETUP) << 8))
    prop RDSETUP0_CECTL0 :: (((self.RDSETUP0_SETUP) << 16))
    prop RDHLD0_CECTL0 :: ((self.RDHLD0_SETUP))
    prop WRSTRB0_CECTL0 :: (((self.WRSTRB0_SETUP) << 22))
    prop WRSETUP0_CECTL0 :: (((self.WRSETUP0_SETUP) << 28))
    prop WRHLD0_CECTL0 :: (if (self.WRHLD0_SETUP > 3) {((self.WRHLD0_SETUP - 4) << 20)} else {((self.WRHLD0_SETUP << 20))})
    prop WRHLDMSB0_CECTL0 :: (if (self.WRHLD0_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA0_CECTL0 :: ((self.TA0_SETUP << 14))
    prop MTYPE1_CECTL1 :: (if (self.MTYPE1_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE1_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE1_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE1_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE1_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE1_SETUP == "16-bit prog. sync. mem") {0x000000b0} }}}}})
    prop RDSTRB1_CECTL1 :: (((self.RDSTRB1_SETUP) << 8))
    prop RDSETUP1_CECTL1 :: (((self.RDSETUP1_SETUP) << 16))
    prop RDHLD1_CECTL1 :: ((self.RDHLD1_SETUP))
    prop WRSTRB1_CECTL1 :: (((self.WRSTRB1_SETUP) << 22))
    prop WRSETUP1_CECTL1 :: (((self.WRSETUP1_SETUP) << 28))
    prop WRHLD1_CECTL1 :: (if (self.WRHLD1_SETUP > 3) {((self.WRHLD1_SETUP - 4) << 20)} else {((self.WRHLD1_SETUP << 20))})
    prop WRHLDMSB1_CECTL1 :: (if (self.WRHLD1_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA1_CECTL1 :: ((self.TA1_SETUP << 14))
    prop MTYPE2_CECTL2 :: (if (self.MTYPE2_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE2_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE2_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE2_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE2_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE2_SETUP == "16-bit prog. sync. mem") {0x000000b0} }}}}})
    prop RDSTRB2_CECTL2 :: (((self.RDSTRB2_SETUP) << 8))
    prop RDSETUP2_CECTL2 :: (((self.RDSETUP2_SETUP) << 16))
    prop RDHLD2_CECTL2 :: ((self.RDHLD2_SETUP))
    prop WRSTRB2_CECTL2 :: (((self.WRSTRB2_SETUP) << 22))
    prop WRSETUP2_CECTL2 :: (((self.WRSETUP2_SETUP) << 28))
    prop WRHLD2_CECTL2 :: (if (self.WRHLD2_SETUP > 3) {((self.WRHLD2_SETUP - 4) << 20)} else {((self.WRHLD2_SETUP << 20))})
    prop WRHLDMSB2_CECTL2 :: (if (self.WRHLD2_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA2_CECTL2 :: ((self.TA2_SETUP << 14))
    prop MTYPE3_CECTL3 :: (if (self.MTYPE3_SETUP == "  8-bit async. interf.") {0x00000000} else {if (self.MTYPE3_SETUP == "  8-bit SDRAM") {0x00000080} else {if (self.MTYPE3_SETUP == "  8-bit prog. sync. mem") {0x000000a0} else {if (self.MTYPE3_SETUP == "16-bit async. interf.") {0x00000010} else {if (self.MTYPE3_SETUP == "16-bit SDRAM") {0x00000090} else {if (self.MTYPE3_SETUP == "16-bit prog. sync. mem") {0x000000b0} }}}}})
    prop RDSTRB3_CECTL3 :: (((self.RDSTRB3_SETUP) << 8))
    prop RDSETUP3_CECTL3 :: (((self.RDSETUP3_SETUP) << 16))
    prop RDHLD3_CECTL3 :: ((self.RDHLD3_SETUP))
    prop WRSTRB3_CECTL3 :: (((self.WRSTRB3_SETUP) << 22))
    prop WRSETUP3_CECTL3 :: (((self.WRSETUP3_SETUP) << 28))
    prop WRHLD3_CECTL3 :: (if (self.WRHLD3_SETUP > 3) {((self.WRHLD3_SETUP - 4) << 20)} else {((self.WRHLD3_SETUP << 20))})
    prop WRHLDMSB3_CECTL3 :: (if (self.WRHLD3_SETUP > 3) {0x00000008} else {0x00000000})
    prop TA3_CECTL3 :: ((self.TA3_SETUP << 14))
    prop SYNCRL0_CESEC0 :: (if (self.SYNCRL0_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL0_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL0_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL0_CESEC0 :: (if (self.SYNCWL0_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL0_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL0_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT0_CESEC0 :: (if (self.CEEXT0_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN0_CESEC0 :: (if (self.RENEN0_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK0_CESEC0 :: (if (self.SNCCLK0_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop SYNCRL1_CESEC1 :: (if (self.SYNCRL1_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL1_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL1_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL1_CESEC1 :: (if (self.SYNCWL1_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL1_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL1_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT1_CESEC1 :: (if (self.CEEXT1_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN1_CESEC1 :: (if (self.RENEN1_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK1_CESEC1 :: (if (self.SNCCLK1_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop SYNCRL2_CESEC2 :: (if (self.SYNCRL2_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL2_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL2_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL2_CESEC2 :: (if (self.SYNCWL2_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL2_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL2_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT2_CESEC2 :: (if (self.CEEXT2_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN2_CESEC2 :: (if (self.RENEN2_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK2_CESEC2 :: (if (self.SNCCLK2_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop SYNCRL3_CESEC3 :: (if (self.SYNCRL3_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCRL3_SETUP == "1 cycle") {0x00000001} else {if (self.SYNCRL3_SETUP == "2 cycles") {0x00000002} else {0x00000003}}})
    prop SYNCWL3_CESEC3 :: (if (self.SYNCWL3_SETUP == "0 cycle") {0x00000000} else {if (self.SYNCWL3_SETUP == "1 cycle") {0x00000004} else {if (self.SYNCWL3_SETUP == "2 cycles") {0x00000008} else {0x0000000c}}})
    prop CEEXT3_CESEC3 :: (if (self.CEEXT3_SETUP == "Inactive") {0x00000000} else {0x0000010})
    prop RENEN3_CESEC3 :: (if (self.RENEN3_SETUP == "ADS Mode") {0x00000000} else {0x0000020})
    prop SNCCLK3_CESEC3 :: (if (self.SNCCLK3_SETUP == "Sync. to ECLKOUT1") {0x00000000} else {0x0000040})
    prop TRC_SDCTL :: ((self.TRC_SETUP << 12))
    prop TRP_SDCTL :: ((self.TRP_SETUP << 16))
    prop TRCD_SDCTL :: ((self.TRCD_SETUP << 20))
    prop INIT_SDCTL :: (if (self.INIT_SETUP == "Initialize") {0x01000000} else {0x00000000})
    prop RFEN_SDCTL :: (if (self.RFEN_SETUP == "Enable") {0x02000000} else {0x00000000})
    prop SDCSZ_SDCTL :: (if (self.SDCSZ_SETUP == " 8 addresses") {0x04000000} else {if (self.SDCSZ_SETUP == "10 addresses") {0x08000000} else {0x00000000}})
    prop SDRSZ_SDCTL :: (if (self.SDRSZ_SETUP == "12 addresses") {0x10000000} else {if (self.SDRSZ_SETUP == "13 addresses") {0x20000000} else {0x00000000}})
    prop SDBSZ_SDCTL :: (if (self.SDBSZ_SETUP == "Four banks") {0x40000000} else {0x00000000})
    prop PERIOD_SDTIM2 :: ((self.PERIOD_SETUP2))
    prop XRFR_SDTIM :: (((self.XRFR_SETUP - 1) << 24))
    prop TCL_SDEXT :: ((self.TCL_SETUP - 2))
    prop TRAS_SDEXT :: (((self.TRAS_SETUP - 1) << 1))
    prop TRRD_SDEXT :: ((self.TRRD_SETUP - 2) << 4)
    prop TWR_SDEXT :: (((self.TWR_SETUP - 1) << 5))
    prop THZP_SDEXT :: (((self.THZP_SETUP - 1) << 7))
    prop RD2RD_SDEXT :: (((self.RD2RD_SETUP - 1) << 9))
    prop RD2DEAC_SDEXT :: (((self.RD2DEAC_SETUP - 1) << 10))
    prop RD2WR_SDEXT :: (((self.RD2WR_SETUP - 1) << 12))
    prop R2WDQM_SDEXT :: (((self.R2WDQM_SETUP - 1) << 15))
    prop WR2WR_SDEXT :: (((self.WR2WR_SETUP - 1) << 17))
    prop WR2DEAC_SDEXT :: (((self.WR2DEAC_SETUP - 1) << 18))
    prop WR2RD_SDEXT :: (((self.WR2RD_SETUP - 1) << 20))
    prop GBLCTL_VALUE_update :: (0x00000004 | self.NOHOLD_GBLCTL() | self.CLK4EN_GBLCTL() | self.CLK6EN_GBLCTL() | self.EK1EN_GBLCTL() | self.EK2EN_GBLCTL() | self.EK1HZ_GBLCTL() | self.EK2HZ_GBLCTL() | self.EK2RATE_GBLCTL() | self.BRMODE_GBLCTL())
    prop GBLCTL_SETUP_update :: (self.NOHOLD_SETUP = if ($1 & 0x00000080) {"Disable Hold"} else {"Enable Hold"}, self.CLK4EN_SETUP = if ($1 & 0x00000010) {"Enabled to clock"} else {"Held high"}, self.CLK6EN_SETUP = if ($1 & 0x00000008) {"Enabled to clock"} else {"Held high"}, self.EK1EN_SETUP = if ($1 & 0x00000020) {"Enabled to clock"} else {"Held low"}, self.EK2EN_SETUP = if ($1 & 0x00010000) {"Enabled to clock"} else {"Held low"}, self.EK1HZ_SETUP = if ($1 & 0x00000040) {"High-Z during hold"} else {"Clock during hold"}, self.EK2HZ_SETUP = if ($1 & 0x00020000) {"High-Z during hold"} else {"Clock during hold"}, self.BRMODE_SETUP = if ($1 & 0x00002000) {"access/refresh pending or in progress"} else {"access pending or in progress"}, $a = $1 & 0x000C0000, if ($a == 0x00080000) {self.EK2RATE_SETUP = "1/4x EMIF input clock"} else {self.EK2RATE_SETUP = if ($1 & 0x00040000) {"1/2x EMIF input clock"} else {"1x EMIF input clock"}})
    prop CECTL0_VALUE_update :: (self.MTYPE0_CECTL0() | self.RDHLD0_CECTL0() | self.RDSTRB0_CECTL0() | self.RDSETUP0_CECTL0() | self.WRHLD0_CECTL0() | self.WRHLDMSB0_CECTL0() | self.WRSETUP0_CECTL0() | self.WRSTRB0_CECTL0() | self.TA0_CECTL0())
    prop CECTL0_SETUP_update :: (self.MTYPE0_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {"16-bit prog. sync. mem"}}}}}), self.RDHLD0_SETUP = ($1 & 0x00000007), self.RDSTRB0_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP0_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD0_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB0_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP0_SETUP = (($1 >> 28) & 0xF), self.TA0_SETUP = ($1 & 0x0000c000) >> 14)
    prop CECTL1_VALUE_update :: (self.MTYPE1_CECTL1() | self.RDHLD1_CECTL1() | self.RDSTRB1_CECTL1() | self.RDSETUP1_CECTL1() | self.WRHLD1_CECTL1() | self.WRHLDMSB1_CECTL1() | self.WRSETUP1_CECTL1() | self.WRSTRB1_CECTL1() | self.TA1_CECTL1())
    prop CECTL1_SETUP_update :: (self.MTYPE1_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {"16-bit prog. sync. mem"}}}}}), self.RDHLD1_SETUP = ($1 & 0x00000007), self.RDSTRB1_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP1_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD1_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB1_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP1_SETUP = (($1 >> 28) & 0xF), self.TA1_SETUP = ($1 & 0x0000c000) >> 14)
    prop CECTL2_VALUE_update :: (self.MTYPE2_CECTL2() | self.RDHLD2_CECTL2() | self.RDSTRB2_CECTL2() | self.RDSETUP2_CECTL2() | self.WRHLD2_CECTL2() | self.WRHLDMSB2_CECTL2() | self.WRSETUP2_CECTL2() | self.WRSTRB2_CECTL2() | self.TA2_CECTL2())
    prop CECTL2_SETUP_update :: (self.MTYPE2_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {"16-bit prog. sync. mem"}}}}}), self.RDHLD2_SETUP = ($1 & 0x00000007), self.RDSTRB2_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP2_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD2_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB2_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP2_SETUP = (($1 >> 28) & 0xF), self.TA2_SETUP = ($1 & 0x0000c000) >> 14)
    prop CECTL3_VALUE_update :: (self.MTYPE3_CECTL3() | self.RDHLD3_CECTL3() | self.RDSTRB3_CECTL3() | self.RDSETUP3_CECTL3() | self.WRHLD3_CECTL3() | self.WRHLDMSB3_CECTL3() | self.WRSETUP3_CECTL3() | self.WRSTRB3_CECTL3() | self.TA3_CECTL3())
    prop CECTL3_SETUP_update :: (self.MTYPE3_SETUP = ($a = ($1 & 0x000000f0), if ($a == 0x00000000) {"  8-bit async. interf."} else {if ($a == 0x00000010) {"16-bit async. interf."} else {if ($a == 0x00000080) {"  8-bit SDRAM"} else {if ($a == 0x00000090) {"16-bit SDRAM"} else {if ($a == 0x000000a0) {"  8-bit prog. sync. mem"} else {"16-bit prog. sync. mem"}}}}}), self.RDHLD3_SETUP = ($1 & 0x00000007), self.RDSTRB3_SETUP = (($1 & 0x00003F00) >> 8), self.RDSETUP3_SETUP = (($1 & 0x000F0000) >> 16), self.WRHLD3_SETUP = ((($1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1)), self.WRSTRB3_SETUP = (($1 & 0x0FC00000) >> 22), self.WRSETUP3_SETUP = (($1 >> 28) & 0xF), self.TA3_SETUP = ($1 & 0x0000c000) >> 14)
    prop SDCTL_VALUE_update :: (self.TRC_SDCTL() | self.TRP_SDCTL() | self.TRCD_SDCTL() | self.INIT_SDCTL() | self.RFEN_SDCTL() | self.SDCSZ_SDCTL() | self.SDRSZ_SDCTL() | self.SDBSZ_SDCTL())
    prop SDCTL_SETUP_update :: (self.TRC_SETUP = ($1 & 0x0000F000) >> 12, self.TRP_SETUP = ($1 & 0x000F0000) >> 16, self.TRCD_SETUP = ($1 & 0x00F00000) >> 20, self.INIT_SETUP = ($a = ($1 & 0x01000000), if ($a == 0x01000000) {"Initialize"} else {"No effect"}), self.RFEN_SETUP = ($a = ($1 & 0x02000000), if ($a == 0x02000000) {"Enable"} else {"Disable"}), self.SDCSZ_SETUP = ($a = ($1 & 0x0c000000), if ($a == 0x04000000) {" 8 addresses"} else {if ($a == 0x08000000) {"10 addresses"} else {" 9 addresses"}}), self.SDRSZ_SETUP = ($a = ($1 & 0x30000000), if ($a == 0x10000000) {"12 addresses"} else {if ($a == 0x20000000) {"13 addresses"} else {"11 addresses"}}), self.SDBSZ_SETUP = ($a = ($1 & 0x40000000), if ($a == 0x40000000) {"Four banks"} else {"Two banks"}))
    prop SDTIM_VALUE_update :: (self.PERIOD_SDTIM2() | self.XRFR_SDTIM() | 0x005dc000)
    prop SDTIM_SETUP_update :: (self.PERIOD_SETUP2 = ($1 & 0x00000FFF), self.XRFR_SETUP = (($1 & 0x03000000) >> 24) + 1)
    prop SDEXT_VALUE_update :: (self.TCL_SDEXT() | self.TRAS_SDEXT() | self.TRRD_SDEXT() | self.TWR_SDEXT() | self.THZP_SDEXT() | self.RD2RD_SDEXT() | self.RD2DEAC_SDEXT() | self.RD2WR_SDEXT() | self.R2WDQM_SDEXT() | self.WR2WR_SDEXT() | self.WR2DEAC_SDEXT() | self.WR2RD_SDEXT())
    prop SDEXT_SETUP_update :: (self.TCL_SETUP = ($1 & 0x00000001) + 2, self.TRAS_SETUP = (($1 & 0x0000000E) >> 1) + 1, self.TRRD_SETUP = (($1 & 0x00000010) >> 4) + 2, self.TWR_SETUP = (($1 & 0x00000060) >> 5) + 1, self.THZP_SETUP = (($1 & 0x00000180) >> 7) + 1, self.RD2RD_SETUP = (($1 & 0x00000200) >> 9) + 1, self.RD2DEAC_SETUP = (($1 & 0x00000c00) >> 10) + 1, self.RD2WR_SETUP = (($1 & 0x00007000) >> 12) + 1, self.R2WDQM_SETUP = (($1 & 0x00018000) >> 15) + 1, self.WR2WR_SETUP = (($1 & 0x00020000) >> 17) + 1, self.WR2DEAC_SETUP = (($1 & 0x000c0000) >> 18) + 1, self.WR2RD_SETUP = (($1 & 0x00100000) >> 20) + 1)
    prop CESEC0_VALUE_update :: (self.SYNCRL0_CESEC0() | self.SYNCWL0_CESEC0() | self.CEEXT0_CESEC0() | self.RENEN0_CESEC0() | self.SNCCLK0_CESEC0())
    prop CESEC0_SETUP_update :: (self.SYNCRL0_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL0_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT0_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN0_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK0_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    prop CESEC1_VALUE_update :: (self.SYNCRL1_CESEC1() | self.SYNCWL1_CESEC1() | self.CEEXT1_CESEC1() | self.RENEN1_CESEC1() | self.SNCCLK1_CESEC1())
    prop CESEC1_SETUP_update :: (self.SYNCRL1_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL1_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT1_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN1_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK1_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    prop CESEC2_VALUE_update :: (self.SYNCRL2_CESEC2() | self.SYNCWL2_CESEC2() | self.CEEXT2_CESEC2() | self.RENEN2_CESEC2() | self.SNCCLK2_CESEC2())
    prop CESEC2_SETUP_update :: (self.SYNCRL2_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL2_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT2_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN2_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK2_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    prop CESEC3_VALUE_update :: (self.SYNCRL3_CESEC3() | self.SYNCWL3_CESEC3() | self.CEEXT3_CESEC3() | self.RENEN3_CESEC3() | self.SNCCLK3_CESEC3())
    prop CESEC3_SETUP_update :: (self.SYNCRL3_SETUP = ($a = ($1 & 0x00000003), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000001) {"1 cycle"} else {if ($a == 0x00000002) {"2 cycles"} else {"3 cycles"}}}), self.SYNCWL3_SETUP = ($a = ($1 & 0x0000000C), if ($a == 0x00000000) {"0 cycle"} else {if ($a == 0x00000004) {"1 cycle"} else {if ($a == 0x00000008) {"2 cycles"} else {"3 cycles"}}}), self.CEEXT3_SETUP = ($a = ($1 & 0x00000010), if ($a == 0x00000000) {"Inactive"} else {"Active"}), self.RENEN3_SETUP = ($a = ($1 & 0x00000020), if ($a == 0x00000000) {"ADS Mode"} else {"Read Enable Mode"}), self.SNCCLK3_SETUP = ($a = ($1 & 0x00000040), if ($a == 0x00000000) {"Sync. to ECLKOUT1"} else {"Sync. to ECLKOUT2"}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((hEmifb.EMIFB_INIT_ENABLE == 1) && (hEmifb.EMIFB_INIT == self) && (hEmifb.EMIFB_INIT != EMIFB_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hEmifb.EMIFB_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: emifbCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst NOHOLD_SETUP :: "Enable Hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable Hold,Disable Hold"
        prop Label :: "External HOLD disable (NOHOLD)"
        prop JSName :: "emifbGblctlNoHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.NOHOLD_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst CLK4EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT4 Enable (CLK4EN)"
        prop JSName :: "emifbGblctlClk4en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.CLK4EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst CLK6EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT6 Enable (CLK6EN)"
        prop JSName :: "emifbGblctlClk6en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.CLK6EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK1EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT1 Enable (EK1EN)"
        prop JSName :: "emifbGblctlEk1en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK1EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK2EN_SETUP :: "Enabled to clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT2 Enable (EK2EN)"
        prop JSName :: "emifbGblctlEk2en"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK2EN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK1HZ_SETUP :: "High-Z during hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT1 High-Z Control (EK1HZ)"
        prop JSName :: "emifbGblctlEk1hz"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK1HZ_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK2HZ_SETUP :: "Clock during hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT2 High-Z Control (EK2HZ)"
        prop JSName :: "emifbGblctlEk2hz"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK2HZ_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst EK2RATE_SETUP :: "1/4x EMIF input clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1x EMIF input clock,1/2x EMIF input clock,1/4x EMIF input clock"
        prop Label :: "ECLKOUT2 Rate (EK2RATE)"
        prop JSName :: "emifbGblctlEk2rate"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.EK2RATE_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst BRMODE_SETUP :: "access/refresh pending or in progress" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "access/refresh pending or in progress,access pending or in progress"
        prop Label :: "Bus Request Mode"
        prop JSName :: "emifbGblctlBrmode"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.BRMODE_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst MTYPE0_SETUP :: "  8-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifbCectl0Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.MTYPE0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok")
    }
    inst RDSTRB0_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst RDSETUP0_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst RDHLD0_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"}})
    }
    inst WRSTRB0_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst WRSETUP0_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst WRHLD0_SETUP :: 3 { 
        prop Label :: "Write Hold Width (WRHLD-WRHLDMSB) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst TA0_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl0Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA0_SETUP = $1, self.CECTL0_VALUE = self.CECTL0_VALUE_update(), "ok"})
    }
    inst MTYPE1_SETUP :: "  8-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifbCectl1Mtype"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.MTYPE1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok")
    }
    inst RDSTRB1_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst RDSETUP1_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst RDHLD1_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"}})
    }
    inst WRSTRB1_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst WRSETUP1_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst WRHLD1_SETUP :: 3 { 
        prop Label :: "Write Hold Width (WRHLD - WHLDMSB) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst TA1_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl1Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA1_SETUP = $1, self.CECTL1_VALUE = self.CECTL1_VALUE_update(), "ok"})
    }
    inst MTYPE2_SETUP :: "  8-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifbCectl2Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.MTYPE2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok")
    }
    inst RDSTRB2_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst RDSETUP2_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst RDHLD2_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"}})
    }
    inst WRSTRB2_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst WRSETUP2_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst WRHLD2_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst TA2_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl2Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA2_SETUP = $1, self.CECTL2_VALUE = self.CECTL2_VALUE_update(), "ok"})
    }
    inst MTYPE3_SETUP :: "  8-bit async. interf." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifbCectl3Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.MTYPE3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok")
    }
    inst RDSTRB3_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.RDSTRB3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst RDSETUP3_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst RDHLD3_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ((!CSL.C11_SUPPORT)) {if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")} else {self.RDHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}} else {if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.RDHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"}})
    }
    inst WRSTRB3_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 63) {self.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")} else {self.WRSTRB3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst WRSETUP3_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst WRHLD3_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 0 || $1 > 7) {self.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")} else {self.WRHLD3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst TA3_SETUP :: 3 { 
        prop Label :: "Turn around time (TA) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbCectl3Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (if ($1 < 1 || $1 > 3) {self.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.TA3_SETUP = $1, self.CECTL3_VALUE = self.CECTL3_VALUE_update(), "ok"})
    }
    inst SYNCRL0_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec0Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.SYNCRL0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst SYNCWL0_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop Visible :: 1
        prop JSName :: "emifbCesec0Syncwl"
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.SYNCWL0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst CEEXT0_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec0Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.CEEXT0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst RENEN0_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec0Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.RENEN0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst SNCCLK0_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec0Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
        prop Set :: (self.SNCCLK0_SETUP = $1, self.CESEC0_VALUE = self.CESEC0_VALUE_update(), "ok")
    }
    inst SYNCRL1_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec1Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.SYNCRL1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst SYNCWL1_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifbCesec1Syncwl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.SYNCWL1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst CEEXT1_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec1Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.CEEXT1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst RENEN1_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec1Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.RENEN1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst SNCCLK1_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec1Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
        prop Set :: (self.SNCCLK1_SETUP = $1, self.CESEC1_VALUE = self.CESEC1_VALUE_update(), "ok")
    }
    inst SYNCRL2_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec2Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.SYNCRL2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst SYNCWL2_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifbCesec2Syncwl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.SYNCWL2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst CEEXT2_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec2Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.CEEXT2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst RENEN2_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec2Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.RENEN2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst SNCCLK2_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec2Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
        prop Set :: (self.SNCCLK2_SETUP = $1, self.CESEC2_VALUE = self.CESEC2_VALUE_update(), "ok")
    }
    inst SYNCRL3_SETUP :: "2 cycles" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec3Syncrl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.SYNCRL3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst SYNCWL3_SETUP :: "0 cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifbCesec3Syncwl"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.SYNCWL3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst CEEXT3_SETUP :: "Inactive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec3Ceext"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.CEEXT3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst RENEN3_SETUP :: "ADS Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec3Renen"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.RENEN3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst SNCCLK3_SETUP :: "Sync. to ECLKOUT1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec3Sncclk"
        prop Visible :: 1
        prop Writable :: (if (CSL.EMIFB_SUPPORT) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
        prop Set :: (self.SNCCLK3_SETUP = $1, self.CESEC3_VALUE = self.CESEC3_VALUE_update(), "ok")
    }
    inst TRC_SETUP :: 15 { 
        prop Label :: "TRC = trc/(eclkout1 period-1) (TRC) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdctlTrc"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRC = 0 - Maximum TRC = 15 ")} else {self.TRC_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst TRP_SETUP :: 8 { 
        prop Label :: "TRP = trp/(eclkout1 period-1) (TRP) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdctlTrp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRP = 0 - Maximum TRP= 15 ")} else {self.TRP_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst TRCD_SETUP :: 4 { 
        prop Label :: "TRCD = trcd/(eclkout1 period-1) (TRCD) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdctlTrcd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("Minimum TRCD = 0 - Maximum TRCD= 15 ")} else {self.TRCD_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok"})
    }
    inst INIT_SETUP :: "Initialize" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Initialize,No effect"
        prop Label :: "Initialization of all SDRAMs (INIT)"
        prop JSName :: "emifbSdctlInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.INIT_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst RFEN_SETUP :: "Enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
        prop Label :: "SDRAM Refresh Enable (RFEN)"
        prop JSName :: "emifbSdctlRfen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.RFEN_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDCSZ_SETUP :: " 9 addresses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 9 addresses, 8 addresses,10 addresses"
        prop Label :: "Column Size (SDCSZ)"
        prop JSName :: "emifbSdctlSdcsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDCSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDRSZ_SETUP :: "11 addresses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "11 addresses,12 addresses,13 addresses"
        prop Label :: "Row Size (SDRSZ)"
        prop JSName :: "emifbSdctlSdrsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDRSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst SDBSZ_SETUP :: "Two banks" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Two banks,Four banks"
        prop Label :: "Bank Size (SDBSZ)"
        prop JSName :: "emifbSdctlSdbsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (self.SDBSZ_SETUP = $1, self.SDCTL_VALUE = self.SDCTL_VALUE_update(), "ok")
    }
    inst PERIOD_SETUP2 :: 1500 { 
        prop Label :: "Refresh Period (ECLKOU1 cycles)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdtimEclkPeriod"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4096) {self.error("1 cyc. < PERIOD < 4096 cyc. ")} else {self.PERIOD_SETUP2 = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst XRFR_SETUP :: 1 { 
        prop Label :: "Extra Refreshes Ctrl. (XRFR)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdctlXrfr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < Extra refreshes < 4 ")} else {self.XRFR_SETUP = $1, self.SDTIM_VALUE = self.SDTIM_VALUE_update(), "ok"})
    }
    inst TCL_SETUP :: 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CAS Latency (TCL)"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextTcl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 2 || $1 > 3) {self.error("TCL : 2 or 3 ECLKOU1 cycles ")} else {self.TCL_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TRAS_SETUP :: 8 { 
        prop Label :: "tras = TRAS + 1 (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextTras"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 8) {self.error("1 ECLKOU1 cycle < tras < 8 ECLKOU1 cycles ")} else {self.TRAS_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TRRD_SETUP :: 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "trrd = TRRD (2 or 3 ECLKOU1 cyc.)"
        prop JSName :: "emifbSdextTrrd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 2 || $1 > 3) {self.error("TRRD : 2 or 3 ECLKOU1 cycles ")} else {self.TRRD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst TWR_SETUP :: 2 { 
        prop Label :: "twr  = TWR + 1 (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextTwr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 ECLKOU1 cycle < twr < 4 ECLKOU1 cycles ")} else {self.TWR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst THZP_SETUP :: 3 { 
        prop Label :: "thzp = THZP + 1 (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextThzp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 ECLKOU1 cycle < thzp < 4 ECLKOU1 cycles ")} else {self.THZP_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2RD_SETUP :: 2 { 
        prop Label :: "READ-To-READ (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextRd2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOU1 cycles < 2  ")} else {self.RD2RD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2DEAC_SETUP :: 4 { 
        prop Label :: "READ-To-DEAC/DEAB (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextRd2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of ECLKOU1 cycles < 4  ")} else {self.RD2DEAC_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst RD2WR_SETUP :: 6 { 
        prop Label :: "READ-To-WRITE (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextRd2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 8) {self.error("1 < # of ECLKOU1 cycles < 8  ")} else {self.RD2WR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst R2WDQM_SETUP :: 3 { 
        prop Label :: "READ-To-WRITE with Interrupt (BEx cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextR2wdqm"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of Bex cycles < 4  ")} else {self.R2WDQM_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2WR_SETUP :: 2 { 
        prop Label :: "WRITE-To-WRITE (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextWr2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOU1 cycles < 2  ")} else {self.WR2WR_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2DEAC_SETUP :: 2 { 
        prop Label :: "WRITE-To-DEAC/DEAB (ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextWr2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 4) {self.error("1 < # of ECLKOU1 cycles < 4  ")} else {self.WR2DEAC_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst WR2RD_SETUP :: 2 { 
        prop Label :: "WRITE-To-READ (# of ECLKOU1 cyc.)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "emifbSdextWr2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
        prop Set :: (if ($1 < 1 || $1 > 2) {self.error("1 < # of ECLKOU1 cycles < 2  ")} else {self.WR2RD_SETUP = $1, self.SDEXT_VALUE = self.SDEXT_VALUE_update(), "ok"})
    }
    inst GBLCTL_VALUE :: self.GBLCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Control Reg. (GBLCTL) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbGblctl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFF00000, $b = $1 & 0x0000C000, $c = $1 & 0x00001000, $d = $1 & 0x00000003, $e = $1 & 0x000C0000, if ($a != 0) {self.error("Bit field (31..20) is reserved")} else {if ($b != 0) {self.error("Bit field (15..14) is reserved")} else {if ($c != 0) {self.error("Bit field 12 is reserved")} else {if ($d != 0) {self.error("Bit field (1..0) is reserved")} else {if ($e == 0x000C0000) {self.error("Invalid input for EK2RATE bit[19:18]")} else {self.GBLCTL_VALUE = $1 | 0x0000004, self.GBLCTL_SETUP_update($1 | 0x0000004), "ok"}}}}})
    }
    inst CECTL0_VALUE :: self.CECTL0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Control Reg. (CECTL0) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbCectl0"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.CECTL0_VALUE = $1, self.CECTL0_SETUP_update($1), "ok"}})
    }
    inst CECTL1_VALUE :: self.CECTL1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Control Reg. (CECTL1) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbCectl1"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.CECTL1_VALUE = $1, self.CECTL1_SETUP_update($1), "ok"}})
    }
    inst CECTL2_VALUE :: self.CECTL2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Control Reg. (CECTL2) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbCectl2"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.CECTL2_VALUE = $1, self.CECTL2_SETUP_update($1), "ok"}})
    }
    inst CECTL3_VALUE :: self.CECTL3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Control Reg. (CECTL3) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbCectl3"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000F0, $b = $1 & 0x0000C000, if ($a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0) {self.error("Undefined Memory type for CE Spaces - See CEx Space Pages")} else {if ($b == 0x00000000) {self.error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")} else {self.CECTL3_VALUE = $1, self.CECTL3_SETUP_update($1), "ok"}})
    }
    inst SDCTL_VALUE :: self.SDCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Control Reg.(SDCTL) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbSdctl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x0c000000, if ($a == 0x0c000000) {self.error("Undefined Value for Column Size field SDCSZ")} else {$b = $1 & 0x30000000, if ($b == 0x30000000) {self.error("Undefined Value for Row Size field SDRSZ")} else {$c = $1 & 0x80000000, if ($c == 0x80000000) {self.error("Bit field 31 is reserved")} else {$d = $1 & 0x00000FFE, if ($d != 0) {self.error("Bit field(bit[1..11]) is reserved")} else {self.SDCTL_VALUE = $1, self.SDCTL_SETUP_update($1), "ok"}}}})
    }
    inst SDTIM_VALUE :: self.SDTIM_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Timing Reg.(SDTIM) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbSdtim"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x0000FFF, if ($a == 0x00000000) {self.error("1 cyc. < PERIOD < 4096 cyc. ")} else {$b = $1 & 0xFC000000, if ($b != 0) {self.error("Bit field(bit[26..31]) is reserved")} else {self.SDTIM_VALUE = $1 | 0x005dc000, self.SDTIM_SETUP_update($1 | 0x005dc000), "ok"}})
    }
    inst SDEXT_VALUE :: self.SDEXT_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Extended Reg.(SDEXT) "
        prop Format :: "0x%08X"
        prop JSName :: "emifbSdext"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFE00000, if ($a != 0) {self.error("Bit field(bit[21..31]) is reserved")} else {self.SDEXT_VALUE = $1, self.SDEXT_SETUP_update($1), "ok"})
    }
    inst CESEC0_VALUE :: self.CESEC0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Secondary Control Reg. (CESEC0)"
        prop Format :: "0x%08X"
        prop JSName :: "emifbCesec0"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC0_VALUE = $1, self.CESEC0_SETUP_update($1), "ok"})
    }
    inst CESEC1_VALUE :: self.CESEC1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Secondary Control Reg. (CESEC1)"
        prop Format :: "0x%08X"
        prop JSName :: "emifbCesec1"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC1_VALUE = $1, self.CESEC1_SETUP_update($1), "ok"})
    }
    inst CESEC2_VALUE :: self.CESEC2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Secondary Control Reg. (CESEC2)"
        prop Format :: "0x%08X"
        prop JSName :: "emifbCesec2"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC2_VALUE = $1, self.CESEC2_SETUP_update($1), "ok"})
    }
    inst CESEC3_VALUE :: self.CESEC3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Secondary Control Reg. (CESEC3)"
        prop Format :: "0x%08X"
        prop JSName :: "emifbCesec3"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT != 0) {1} else {0}
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFFFF80, if ($a != 0) {self.error("Bit field(bit[7..31]) is reserved")} else {self.CESEC3_VALUE = $1, self.CESEC3_SETUP_update($1), "ok"})
    }
}

type hEmifb {
    prop IsContainedIn :: EMIFBFOLDER
    prop name :: "hEmifb"
    prop Label :: "EMIF Resource Manager"
    prop JSName :: "HEMIFB"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6534-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6535-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (1045)
    prop cGen :: 1
    global EMIFB_INIT_ENABLE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "emifbEnablePreInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; emifbCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.EMIFB_INIT == EMIFB_NOTHING) {" You must create a new configuration object"} else {self.EMIFB_INIT_ENABLE = $1, if ($1 == 0) {self.EMIFB_INIT = EMIFB_NOTHING} , "ok"})
    }
    global EMIFB_INIT :: MyEmifbConfig { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: emifbCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "emifbPreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.EMIFB_SUPPORT) && (self.EMIFB_INIT_ENABLE == 1) {1} else {0}
    }
}

object EMIFB_NOTHING :: emifbCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param NOHOLD_SETUP :: "Enable Hold"
    param CLK4EN_SETUP :: "Enabled to clock"
    param CLK6EN_SETUP :: "Enabled to clock"
    param EK1EN_SETUP :: "Enabled to clock"
    param EK2EN_SETUP :: "Enabled to clock"
    param EK1HZ_SETUP :: "High-Z during hold"
    param EK2HZ_SETUP :: "Clock during hold"
    param EK2RATE_SETUP :: "1/4x EMIF input clock"
    param BRMODE_SETUP :: "access/refresh pending or in progress"
    param MTYPE0_SETUP :: "  8-bit async. interf."
    param RDSTRB0_SETUP :: 63
    param RDSETUP0_SETUP :: 15
    param RDHLD0_SETUP :: 3
    param WRSTRB0_SETUP :: 63
    param WRSETUP0_SETUP :: 15
    param WRHLD0_SETUP :: 3
    param TA0_SETUP :: 3
    param MTYPE1_SETUP :: "  8-bit async. interf."
    param RDSTRB1_SETUP :: 63
    param RDSETUP1_SETUP :: 15
    param RDHLD1_SETUP :: 3
    param WRSTRB1_SETUP :: 63
    param WRSETUP1_SETUP :: 15
    param WRHLD1_SETUP :: 3
    param TA1_SETUP :: 3
    param MTYPE2_SETUP :: "  8-bit async. interf."
    param RDSTRB2_SETUP :: 63
    param RDSETUP2_SETUP :: 15
    param RDHLD2_SETUP :: 3
    param WRSTRB2_SETUP :: 63
    param WRSETUP2_SETUP :: 15
    param WRHLD2_SETUP :: 3
    param TA2_SETUP :: 3
    param MTYPE3_SETUP :: "  8-bit async. interf."
    param RDSTRB3_SETUP :: 63
    param RDSETUP3_SETUP :: 15
    param RDHLD3_SETUP :: 3
    param WRSTRB3_SETUP :: 63
    param WRSETUP3_SETUP :: 15
    param WRHLD3_SETUP :: 3
    param TA3_SETUP :: 3
    param SYNCRL0_SETUP :: "2 cycles"
    param SYNCWL0_SETUP :: "0 cycle"
    param CEEXT0_SETUP :: "Inactive"
    param RENEN0_SETUP :: "ADS Mode"
    param SNCCLK0_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL1_SETUP :: "2 cycles"
    param SYNCWL1_SETUP :: "0 cycle"
    param CEEXT1_SETUP :: "Inactive"
    param RENEN1_SETUP :: "ADS Mode"
    param SNCCLK1_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL2_SETUP :: "2 cycles"
    param SYNCWL2_SETUP :: "0 cycle"
    param CEEXT2_SETUP :: "Inactive"
    param RENEN2_SETUP :: "ADS Mode"
    param SNCCLK2_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL3_SETUP :: "2 cycles"
    param SYNCWL3_SETUP :: "0 cycle"
    param CEEXT3_SETUP :: "Inactive"
    param RENEN3_SETUP :: "ADS Mode"
    param SNCCLK3_SETUP :: "Sync. to ECLKOUT1"
    param TRC_SETUP :: 15
    param TRP_SETUP :: 8
    param TRCD_SETUP :: 4
    param INIT_SETUP :: "Initialize"
    param RFEN_SETUP :: "Enable"
    param SDCSZ_SETUP :: " 9 addresses"
    param SDRSZ_SETUP :: "11 addresses"
    param SDBSZ_SETUP :: "Two banks"
    param PERIOD_SETUP2 :: 1500
    param XRFR_SETUP :: 1
    param TCL_SETUP :: 3
    param TRAS_SETUP :: 8
    param TRRD_SETUP :: 3
    param TWR_SETUP :: 2
    param THZP_SETUP :: 3
    param RD2RD_SETUP :: 2
    param RD2DEAC_SETUP :: 4
    param RD2WR_SETUP :: 6
    param R2WDQM_SETUP :: 3
    param WR2WR_SETUP :: 2
    param WR2DEAC_SETUP :: 2
    param WR2RD_SETUP :: 2
    param GBLCTL_VALUE :: 598140
    param CECTL0_VALUE :: -253
    param CECTL1_VALUE :: -253
    param CECTL2_VALUE :: -253
    param CECTL3_VALUE :: -253
    param SDCTL_VALUE :: 55111680
    param SDTIM_VALUE :: 6145500
    param SDEXT_VALUE :: 1531711
    param CESEC0_VALUE :: 2
    param CESEC1_VALUE :: 2
    param CESEC2_VALUE :: 2
    param CESEC3_VALUE :: 2
}

type MCBSPFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL
    prop name :: "MCBSP"
    prop Label :: "MCBSP - Multichannel Buffered Serial Port"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{1E62DD14-59A8-11d4-947D-0050048381B7}"
    prop InstancePropertyPage :: "{1E62DD15-59A8-11d4-947D-0050048381B7}"
    prop GlobalIcon :: 159
    prop InstanceIcon :: 160
    prop GlobalHelpTopic :: (1050)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type mcbspCfg {
    isa ObjectMgr
    prop Name :: "mcbspCfg"
    prop Label :: "MCBSP Configuration Manager"
    prop JSName :: "MCBSP"
    prop IsContainedIn :: MCBSPFOLDER
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{1E62DD12-59A8-11d4-947D-0050048381B7}"
    prop InstancePropertyPage :: "{1E62DD13-59A8-11d4-947D-0050048381B7}"
    prop GlobalIcon :: 159
    prop InstanceIcon :: 160
    prop GlobalHelpTopic :: (1051)
    prop InstanceHelpTopic :: (1051)
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "MCBSP_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_mcbsp.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; mcbspCfg) {$a = $a + 1}, if ($a == 2) {scan ($c; hMcbsp) {$c.MCBSP_INIT_ENABLE = 0}} , "ok")
    prop DLB_SPCR :: (if (self.DLB_SETUP == "Enable") {0x00008000} else {0x00000000})
    prop CLKSTP_SPCR :: (if (self.CLKSTP_SETUP == "Disable") {0x00000000} else {if (self.CLKSTP_SETUP == "NoDelay(SPI)") {0x00001000} else {if (self.CLKSTP_SETUP == "Delay(SPI)") {0x00001800} }})
    prop FREE_SPCR :: (if (self.FREE_SETUP == "Free Running") {0x02000000} else {0x00000000})
    prop SOFT_SPCR :: (if (self.SOFT_SETUP == "Transmission Complete") {0x01000000} else {0x00000000})
    prop XINTM_SPCR :: (if (self.XINTM_SETUP == "XRDY") {0x00000000} else {if (self.XINTM_SETUP == "End of Subframe") {0x00100000} else {if (self.XINTM_SETUP == "New Frame") {0x00200000} else {if (self.XINTM_SETUP == "XSYNCERR") {0x00300000} }}})
    prop RINTM_SPCR :: (if (self.RINTM_SETUP == "RRDY") {0x00000000} else {if (self.RINTM_SETUP == "End of Subframe") {0x00000010} else {if (self.RINTM_SETUP == "New Frame") {0x00000020} else {if (self.RINTM_SETUP == "RSYNCERR") {0x00000030} }}})
    prop XCOMPAND_XCR :: (if (self.XCOMPAND_SETUP == "No Companding/MSB") {0x00000000} else {if (self.XCOMPAND_SETUP == "No Compamding/LSB") {0x00080000} else {if (self.XCOMPAND_SETUP == "Companding/u-law") {0x00100000} else {if (self.XCOMPAND_SETUP == "Companding/A-law") {0x00180000} }}})
    prop RCOMPAND_RCR :: (if (self.RCOMPAND_SETUP == "No Companding/MSB") {0x00000000} else {if (self.RCOMPAND_SETUP == "No Compamding/LSB") {0x00080000} else {if (self.RCOMPAND_SETUP == "Companding/u-law") {0x00100000} else {if (self.RCOMPAND_SETUP == "Companding/A-law") {0x00180000} }}})
    prop XRST_SPCR :: (if (self.XRST_SETUP == "Enable") {0x00010000} else {0x00000000})
    prop XSYNCERR_SPCR :: (if (self.XSYNCERR_SETUP == "Set") {0x00080000} else {0x00000000})
    prop CLKXM_PCR :: (if (self.CLKXM_SETUP == "Input/Mcbsp-slave(SPI)") {0x00000000} else {if (self.CLKXM_SETUP == "Output/Mcbsp-master(SPI)") {0x00000200} })
    prop CLKXP_PCR :: (if (self.CLKXP_SETUP == "Rising Edge") {0x00000000} else {0x00000002})
    prop FSXM_PCR :: (if (self.FSXM_SETUP == "External Source") {0x00000000} else {if (self.FSXM_SETUP == "Sample-rate Generator") {0x00000800} })
    prop FSXP_PCR :: (if (self.FSXP_SETUP == "Active High") {0x00000000} else {0x00000008})
    prop DXENA_SPCR :: (if (self.DXENA_SETUP == "Enable") {0x00000080} else {0x00000000})
    prop XFIG_XCR :: (if (self.XFIG_SETUP == "Transfer restarted") {0x00000000} else {0x00040000})
    prop XDATDLY_XCR :: (if (self.XDATDLY_SETUP == "0-bit") {0x0000000} else {if (self.XDATDLY_SETUP == "1-bit") {0x00010000} else {if (self.XDATDLY_SETUP == "2-bits") {0x00020000} }})
    prop XWDREVRS_XCR :: (if (self.XWDREVRS_SETUP == "Enable") {0x00000010} else {0x00000000})
    prop XPHASE_XCR :: (if (self.XPHASE_SETUP == "Single Phase") {0x00000000} else {0x80000000})
    prop XFRLEN1_XCR :: ((self.XFRLEN1_SETUP - 1) << 8)
    prop XWDLEN1_XCR :: (if (self.XWDLEN1_SETUP == "8-bits") {0x00000000} else {if (self.XWDLEN1_SETUP == "12-bits") {0x00000020} else {if (self.XWDLEN1_SETUP == "16-bits") {0x00000040} else {if (self.XWDLEN1_SETUP == "20-bits") {0x00000060} else {if (self.XWDLEN1_SETUP == "24-bits") {0x00000080} else {if (self.XWDLEN1_SETUP == "32-bits") {0x000000A0} }}}}})
    prop XFRLEN2_XCR :: ((self.XFRLEN2_SETUP - 1) << 24)
    prop XWDLEN2_XCR :: (if (self.XWDLEN2_SETUP == "8-bits") {0x00000000} else {if (self.XWDLEN2_SETUP == "12-bits") {0x00200000} else {if (self.XWDLEN2_SETUP == "16-bits") {0x00400000} else {if (self.XWDLEN2_SETUP == "20-bits") {0x00600000} else {if (self.XWDLEN2_SETUP == "24-bits") {0x00800000} else {if (self.XWDLEN2_SETUP == "32-bits") {0x00A00000} }}}}})
    prop RRST_SPCR :: (if (self.RRST_SETUP == "Enable") {0x00000001} else {0x00000000})
    prop RSYNCERR_SPCR :: (if (self.RSYNCERR_SETUP == "Set") {0x00000008} else {0x00000000})
    prop CLKRM_PCR :: (if (self.CLKRM_SETUP == "Input/Hi.Z(DLB)") {0x00000000} else {if (self.CLKRM_SETUP == "Output/Output(DLB)") {0x00000100} })
    prop CLKRP_PCR :: (if (self.CLKRP_SETUP == "Falling Edge") {0x00000000} else {0x00000001})
    prop FSRM_PCR :: (if (self.FSRM_SETUP == "External Source") {0x00000000} else {if (self.FSRM_SETUP == "Sample-rate Generator") {0x00000400} })
    prop FSRP_PCR :: (if (self.FSRP_SETUP == "Active High") {0x00000000} else {0x00000004})
    prop RJUST_SPCR :: (if (self.RJUST_SETUP == "Right/sign-ext.") {0x00002000} else {if (self.RJUST_SETUP == "Left/zero-fill") {0x00004000} else {0x00000000}})
    prop RFIG_RCR :: (if (self.RFIG_SETUP == "Transfer restarted") {0x00000000} else {0x00040000})
    prop RDATDLY_RCR :: (if (self.RDATDLY_SETUP == "0-bit") {0x0000000} else {if (self.RDATDLY_SETUP == "1-bit") {0x00010000} else {if (self.RDATDLY_SETUP == "2-bits") {0x00020000} }})
    prop RWDREVRS_RCR :: (if (self.RWDREVRS_SETUP == "Enable") {0x00000010} else {0x00000000})
    prop RPHASE_RCR :: (if (self.RPHASE_SETUP == "Single Phase") {0x00000000} else {0x80000000})
    prop RFRLEN1_RCR :: ((self.RFRLEN1_SETUP - 1) << 8)
    prop RWDLEN1_RCR :: (if (self.RWDLEN1_SETUP == "8-bits") {0x00000000} else {if (self.RWDLEN1_SETUP == "12-bits") {0x00000020} else {if (self.RWDLEN1_SETUP == "16-bits") {0x00000040} else {if (self.RWDLEN1_SETUP == "20-bits") {0x00000060} else {if (self.RWDLEN1_SETUP == "24-bits") {0x00000080} else {if (self.RWDLEN1_SETUP == "32-bits") {0x000000A0} }}}}})
    prop RFRLEN2_RCR :: ((self.RFRLEN2_SETUP - 1) << 24)
    prop RWDLEN2_RCR :: (if (self.RWDLEN2_SETUP == "8-bits") {0x00000000} else {if (self.RWDLEN2_SETUP == "12-bits") {0x00200000} else {if (self.RWDLEN2_SETUP == "16-bits") {0x00400000} else {if (self.RWDLEN2_SETUP == "20-bits") {0x00600000} else {if (self.RWDLEN2_SETUP == "24-bits") {0x00800000} else {if (self.RWDLEN2_SETUP == "32-bits") {0x00A00000} }}}}})
    prop GRST_SPCR :: (if (self.GRST_SETUP == "Clock Generation") {0x00400000} else {0x00000000})
    prop FRST_SPCR :: (if (self.FRST_SETUP == "Frame Sync.") {0x00800000} else {0x00000000})
    prop CLKSM_SRGR :: (if (self.CLKSM_SETUP == "Internal Clock") {0x20000000} else {0x00000000})
    prop GSYNC_SRGR :: (if (self.GSYNC_SETUP == "External Frame Sync.") {0x80000000} else {0x00000000})
    prop CLKSP_SRGR :: (if (self.CLKSP_SETUP == "Falling Edge") {0x40000000} else {0x00000000})
    prop FSGM_SRGR :: (if (self.FSGM_SETUP == "DXR-to-XSR copy") {0x00000000} else {0x10000000})
    prop FPER_SRGR :: ((self.FPER_SETUP - 1) << 16)
    prop FWID_SRGR :: ((self.FWID_SETUP - 1) << 8)
    prop CLKGDV_SRGR :: ((self.CLKGDV_SETUP - 1))
    prop XMCM_MCR :: (if (self.XMCM_SETUP == "Enable/No-Masking") {0x00000000} else {if (self.XMCM_SETUP == "Disable/XP(A/B)BLK-XCEREx") {0x00010000} else {if (self.XMCM_SETUP == "Enable/Masking") {0x00020000} else {0x00030000}}})
    prop RX_MCME_MCR :: (if (self.RX_MCME_SETUP == "Normal Operation") {0x00000000} else {if (self.RX_MCME_SETUP == "Enhanced Operation") {0x02000200} })
    prop XPABLK_MCR :: (if (self.XPABLK_SETUP == "  0-to-15") {0x00000000} else {if (self.XPABLK_SETUP == " 32-to-47") {0x00200000} else {if (self.XPABLK_SETUP == " 64-to-79") {0x00400000} else {0x00600000}}})
    prop XPBBLK_MCR :: (if (self.XPBBLK_SETUP == " 16-to-31") {0x00000000} else {if (self.XPBBLK_SETUP == " 48-to-63") {0x00800000} else {if (self.XPBBLK_SETUP == " 80-to-95") {0x01000000} else {0x01800000}}})
    prop XCEA_XCER :: ((self.XCEA_SETUP))
    prop XCEB_XCER :: ((self.XCEB_SETUP << 16))
    prop XCE0_XCERE0 :: ((self.XCE0_SETUP))
    prop XCE1_XCERE1 :: ((self.XCE1_SETUP))
    prop XCE2_XCERE2 :: ((self.XCE2_SETUP))
    prop XCE3_XCERE3 :: ((self.XCE3_SETUP))
    prop RMCM_MCR :: (if (self.RMCM_SETUP == "All Enable") {0x00000000} else {0x00000001})
    prop RPABLK_MCR :: (if (self.RPABLK_SETUP == "  0-to-15") {0x00000000} else {if (self.RPABLK_SETUP == " 32-to-47") {0x00000020} else {if (self.RPABLK_SETUP == " 64-to-79") {0x00000040} else {0x00000060}}})
    prop RPBBLK_MCR :: (if (self.RPBBLK_SETUP == " 16-to-31") {0x00000000} else {if (self.RPBBLK_SETUP == " 48-to-63") {0x00000080} else {if (self.RPBBLK_SETUP == " 80-to-95") {0x00000100} else {0x00000180}}})
    prop RCEA_RCER :: ((self.RCEA_SETUP))
    prop RCEB_RCER :: ((self.RCEB_SETUP << 16))
    prop RCE0_RCERE0 :: ((self.RCE0_SETUP))
    prop RCE1_RCERE1 :: ((self.RCE1_SETUP))
    prop RCE2_RCERE2 :: ((self.RCE2_SETUP))
    prop RCE3_RCERE3 :: ((self.RCE3_SETUP))
    prop XIOEN_PCR :: (if (self.XIOEN_SETUP == "Enable") {0x00002000} else {0x00000000})
    prop CLKXP_IO :: ((self.CLKXP_output << 1))
    prop FSXP_IO :: ((self.FSXP_output << 3))
    prop DX_IO :: ((self.DX_output << 5))
    prop RIOEN_PCR :: (if (self.RIOEN_SETUP == "Enable") {0x00001000} else {0x00000000})
    prop CLKRP_IO :: ((self.CLKRP_output))
    prop FSRP_IO :: ((self.FSRP_output << 2))
    prop SPCR_VALUE_update :: (0x033EFFFE & ((if (CSL.C11_SUPPORT || CSL.C64_SUPPORT) {self.FREE_SPCR()} else {0}) | (if (CSL.C11_SUPPORT || CSL.C64_SUPPORT) {self.SOFT_SPCR()} else {0}) | self.XINTM_SPCR() | self.XSYNCERR_SPCR() | self.DLB_SPCR() | self.RJUST_SPCR() | self.CLKSTP_SPCR() | (if (CSL.C11_SUPPORT || CSL.C64_SUPPORT) {self.DXENA_SPCR()} else {0}) | self.RINTM_SPCR() | self.RSYNCERR_SPCR()))
    prop SPCR_SETUP_update :: (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {self.FREE_SETUP = if ($1 & 0x02000000) {"Free Running"} else {"SOFT bit Control"}, self.SOFT_SETUP = if ($1 & 0x01000000) {"Transmission Complete"} else {"Transmission Aborted"}} , self.XINTM_SETUP = ($a = ($1 & 0x00300000), if ($a == 0x00100000) {"End of Subframe"} else {if ($a == 0x00200000) {"New Frame"} else {if ($a == 0x00300000) {"XSYNCERR"} else {"XRDY"}}}), self.XSYNCERR_SETUP = if ($1 & 0x00080000) {"Set"} else {"Clear"}, self.DLB_SETUP = if ($1 & 0x00008000) {"Enable"} else {"Disable"}, self.RJUST_SETUP = ($a = ($1 & 0x00003000), if ($a == 0x00002000) {"Right/sign-ext."} else {if ($a == 0x00004000) {"Left/zero-fill"} else {"Right/zero-fill"}}), self.CLKSTP_SETUP = ($a = ($1 & 0x00001800), if ($a == 0x00001000) {"NoDelay(SPI)"} else {if ($a == 0x00001800) {"Delay(SPI)"} else {"Disable"}}), if ((CSL.C11_SUPPORT) || CSL.C64_SUPPORT) {self.DXENA_SETUP = if ($1 & 0x00000080) {"Enable"} else {"Disable"}} , self.RINTM_SETUP = ($a = ($1 & 0x00000030), if ($a == 0x00000010) {"End of Subframe"} else {if ($a == 0x00000020) {"New Frame"} else {if ($a == 0x00000030) {"RSYNCERR"} else {"RRDY"}}}), self.RSYNCERR_SETUP = if ($1 & 0x00000008) {"Set"} else {"Clear"})
    prop RCR_VALUE_update :: (self.RPHASE_RCR() | self.RFRLEN2_RCR() | self.RWDLEN2_RCR() | self.RCOMPAND_RCR() | self.RFIG_RCR() | self.RDATDLY_RCR() | self.RFRLEN1_RCR() | self.RWDLEN1_RCR() | (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {self.RWDREVRS_RCR()} else {0}))
    prop RCR_SETUP_update :: (self.RPHASE_SETUP = if ($1 & 0x80000000) {"Dual Phase"} else {"Single Phase"}, self.RFRLEN2_SETUP = ((($1 & 0x7f000000) >> 24) + 1), self.RWDLEN2_SETUP = ($a = ($1 & 0x00e00000), if ($a == 0x00200000) {"12-bits"} else {if ($a == 0x00400000) {"16-bits"} else {if ($a == 0x00600000) {"20-bits"} else {if ($a == 0x00800000) {"24-bits"} else {if ($a == 0x00A00000) {"32-bits"} else {"8-bits"}}}}}), self.RCOMPAND_SETUP = ($a = ($1 & 0x00180000), if ($a == 0x00080000) {"No Companding/LSB"} else {if ($a == 0x00100000) {"Companding/u-law"} else {if ($a == 0x00180000) {"Companding/A-law"} else {"No Companding/MSB"}}}), self.RFIG_SETUP = if ($1 & 0x00040000) {"Pulse ignored"} else {"Transfer restarted"}, self.RDATDLY_SETUP = ($a = ($1 & 0x00030000), if ($a == 0x00010000) {"1-bit"} else {if ($a == 0x00020000) {"2-bits"} else {"0-bit"}}), self.RFRLEN1_SETUP = ((($1 & 0x00007f00) >> 8) + 1), self.RWDLEN1_SETUP = ($a = ($1 & 0x000000e0), if ($a == 0x00000020) {"12-bits"} else {if ($a == 0x00000040) {"16-bits"} else {if ($a == 0x00000060) {"20-bits"} else {if ($a == 0x00000080) {"24-bits"} else {if ($a == 0x000000A0) {"32-bits"} else {"8-bits"}}}}}), if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {self.RWDREVRS_SETUP = if ($1 & 0x00000010) {"Enable"} else {"Disable"}} )
    prop XCR_VALUE_update :: (self.XPHASE_XCR() | self.XFRLEN2_XCR() | self.XWDLEN2_XCR() | self.XCOMPAND_XCR() | self.XFIG_XCR() | self.XDATDLY_XCR() | self.XFRLEN1_XCR() | self.XWDLEN1_XCR() | (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {self.XWDREVRS_XCR()} else {0}))
    prop XCR_SETUP_update :: (self.XPHASE_SETUP = if ($1 & 0x80000000) {"Dual Phase"} else {"Single Phase"}, self.XFRLEN2_SETUP = ((($1 & 0x7f000000) >> 24) + 1), self.XWDLEN2_SETUP = ($a = ($1 & 0x00e00000), if ($a == 0x00200000) {"12-bits"} else {if ($a == 0x00400000) {"16-bits"} else {if ($a == 0x00600000) {"20-bits"} else {if ($a == 0x00800000) {"24-bits"} else {if ($a == 0x00a00000) {"32-bits"} else {"8-bits"}}}}}), self.XCOMPAND_SETUP = ($a = ($1 & 0x00180000), if ($a == 0x00080000) {"No Companding/LSB"} else {if ($a == 0x00100000) {"Companding/u-law"} else {if ($a == 0x00180000) {"Companding/A-law"} else {"No Companding/MSB"}}}), self.XFIG_SETUP = if ($1 & 0x00040000) {"Pulse ignored"} else {"Transfer restarted"}, self.XDATDLY_SETUP = ($a = ($1 & 0x00030000), if ($a == 0x00010000) {"1-bit"} else {if ($a == 0x00020000) {"2-bits"} else {"0-bit"}}), self.XFRLEN1_SETUP = ((($1 & 0x00007f00) >> 8) + 1), self.XWDLEN1_SETUP = ($a = ($1 & 0x000000e0), if ($a == 0x00000020) {"12-bits"} else {if ($a == 0x00000040) {"16-bits"} else {if ($a == 0x00000060) {"20-bits"} else {if ($a == 0x00000080) {"24-bits"} else {if ($a == 0x000000A0) {"32-bits"} else {"8-bits"}}}}}), if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {self.XWDREVRS_SETUP = if ($1 & 0x00000010) {"Enable"} else {"Disable"}} )
    prop SRGR_VALUE_update :: (self.GSYNC_SRGR() | self.CLKSP_SRGR() | self.CLKSM_SRGR() | self.FSGM_SRGR() | self.FPER_SRGR() | self.FWID_SRGR() | self.CLKGDV_SRGR())
    prop SRGR_SETUP_update :: (if (self.CLKSM_SRGR() == 0x00000000) {self.GSYNC_SETUP = if ($1 & 0x80000000) {"External Frame Sync."} else {"Free"}, self.CLKSP_SETUP = if ($1 & 0x40000000) {"Falling Edge"} else {"Rising Edge"}} , self.CLKSM_SETUP = if ($1 & 0x20000000) {"Internal Clock"} else {"External Clock (CLKS)"}, if (self.FSXM_SETUP == "Sample-rate Generator") {self.FSGM_SETUP = if ($1 & 0x10000000) {"Frame Sync. Signal"} else {"DXR-to-XSR copy"}} , self.FPER_SETUP = ($1 & 0x0fff0000) >> 16, self.FWID_SETUP = ($1 & 0x0000ff00) >> 8, self.CLKGDV_SETUP = ($1 & 0X000000ff))
    prop MCR_VALUE_update :: (self.XPBBLK_MCR() | self.XPABLK_MCR() | self.XMCM_MCR() | self.RPBBLK_MCR() | self.RPABLK_MCR() | self.RMCM_MCR() | self.RX_MCME_MCR())
    prop MCR_SETUP_update :: (self.XPBBLK_SETUP = ($a = ($1 & 0x01800000), if ($a == 0x00800000) {" 48-to-63"} else {if ($a == 0x01000000) {" 80-to-95"} else {if ($a == 0x01800000) {" 112-to-127"} else {" 16-to-31"}}}), self.XPABLK_SETUP = ($a = ($1 & 0x00600000), if ($a == 0x00200000) {" 32-to-47"} else {if ($a == 0x00400000) {" 64-to-79"} else {if ($a == 0x00600000) {" 96-to-111"} else {"  0-to-15"}}}), self.XMCM_SETUP = ($a = ($1 & 0x00030000), if ($a == 0x00010000) {"Disable/XP(A/B)BLK-XCEREx"} else {if ($a == 0x00020000) {"Enable/Masking"} else {if ($a == 0x000300000) {"Disable/RP(A/B)BLK-RCEREx"} else {"Enable/No-Masking"}}}), self.RPBBLK_SETUP = ($a = ($1 & 0x00000180), if ($a == 0x00000080) {" 48-to-63"} else {if ($a == 0x01000100) {" 80-to-95"} else {if ($a == 0x00000180) {" 112-to-127"} else {" 16-to-31"}}}), self.RPABLK_SETUP = ($a = ($1 & 0x00000060), if ($a == 0x00000020) {" 32-to-47"} else {if ($a == 0x00000040) {" 64-to-79"} else {if ($a == 0x00000060) {" 96-to-111"} else {"  0-to-15"}}}), self.RMCM_SETUP = if ($1 & 0x00000001) {"Disable/RP(A/B)-RCEREx"} else {"All Enable"}, self.RX_MCME_SETUP = if ($1 & 0x02000200) {"Enhanced Operation"} else {"Normal Operation"})
    prop RCER_VALUE_update :: (self.RCEB_RCER() | self.RCEA_RCER())
    prop RCER_SETUP_update :: (self.RCEB_SETUP = ($1 & 0xffff0000) >> 16, self.RCEA_SETUP = ($1 & 0x0000ffff))
    prop RCERE0_VALUE_update :: (self.RCE0_RCERE0())
    prop RCERE0_SETUP_update :: (self.RCE0_SETUP = $1)
    prop RCERE1_VALUE_update :: (self.RCE1_RCERE1())
    prop RCERE1_SETUP_update :: (self.RCE1_SETUP = $1)
    prop RCERE2_VALUE_update :: (self.RCE2_RCERE2())
    prop RCERE2_SETUP_update :: (self.RCE2_SETUP = $1)
    prop RCERE3_VALUE_update :: (self.RCE3_RCERE3())
    prop RCERE3_SETUP_update :: (self.RCE3_SETUP = $1)
    prop XCER_VALUE_update :: (self.XCEB_XCER() | self.XCEA_XCER())
    prop XCER_SETUP_update :: (self.XCEB_SETUP = ($1 & 0xffff0000) >> 16, self.XCEA_SETUP = ($1 & 0x0000ffff))
    prop XCERE0_VALUE_update :: (self.XCE0_XCERE0())
    prop XCERE0_SETUP_update :: (self.XCE0_SETUP = ($1))
    prop XCERE1_VALUE_update :: (self.XCE1_XCERE1())
    prop XCERE1_SETUP_update :: (self.XCE1_SETUP = ($1))
    prop XCERE2_VALUE_update :: (self.XCE2_XCERE2())
    prop XCERE2_SETUP_update :: (self.XCE2_SETUP = ($1))
    prop XCERE3_VALUE_update :: (self.XCE3_XCERE3())
    prop XCERE3_SETUP_update :: (self.XCE3_SETUP = ($1))
    prop PCR_VALUE_update :: (self.XIOEN_PCR() | self.RIOEN_PCR() | self.FSXM_PCR() | self.FSRM_PCR() | self.CLKXM_PCR() | self.CLKRM_PCR() | (if ((self.XIOEN_SETUP == "Enable") && (self.FSXM_SETUP == "Sample-rate Generator")) {self.FSXP_IO()} else {self.FSXP_PCR()}) | (if ((self.RIOEN_SETUP == "Enable") && (self.FSRM_SETUP == "Sample-rate Generator")) {self.FSRP_IO()} else {self.FSRP_PCR()}) | (if (self.XIOEN_SETUP == "Enable") {self.DX_IO()} else {0}) | (if ((self.XIOEN_SETUP == "Enable") && (self.CLKXM_SETUP == "Output/Mcbsp-master(SPI)")) {self.CLKXP_IO()} else {self.CLKXP_PCR()}) | (if ((self.RIOEN_SETUP == "Enable") && (self.CLKRM_SETUP == "Output/Output(DLB)")) {self.CLKRP_IO()} else {self.CLKRP_PCR()}))
    prop PCR_SETUP_update :: (self.XIOEN_SETUP = if ($1 & 0x00002000) {"Enable"} else {"Disable"}, self.RIOEN_SETUP = if ($1 & 0x00001000) {"Enable"} else {"Disable"}, self.FSXM_SETUP = if ($1 & 0x000000800) {"Sample-rate Generator"} else {"External Source"}, self.FSRM_SETUP = if ($1 & 0x000000400) {"Sample-rate Generator"} else {"External Source"}, self.CLKXM_SETUP = if ($1 & 0x000000200) {"Output/Mcbsp-master(SPI)"} else {"Input/Mcbsp-slave(SPI)"}, self.CLKRM_SETUP = if ($1 & 0x000000100) {"Output/Output(DLB)"} else {"Input/Hi.Z(DLB)"}, if (self.XIOEN_SETUP == "Enable") {self.DX_output = if ($1 & 0x00000020) {1} else {0}} else {0x00000000}, if ((self.XIOEN_SETUP == "Enable") && (self.FSXM_SETUP == "Sample-rate Generator")) {self.FSXP_output = if ($1 & 0x00000008) {1} else {0}} else {self.FSXP_SETUP = if ($1 & 0x00000008) {"Active Low"} else {"Active High"}}, if ((self.RIOEN_SETUP == "Enable") && (self.FSRM_SETUP == "Sample-rate Generator")) {self.FSRP_output = if ($1 & 0x00000004) {1} else {0}} else {self.FSRP_SETUP = if ($1 & 0x00000004) {"Active Low"} else {"Active High"}}, if ((self.XIOEN_SETUP == "Enable") && (self.CLKXM_SETUP == "Output/Mcbsp-master(SPI)")) {self.CLKXP_output = if ($1 & 0x00000002) {1} else {0}} else {self.CLKXP_SETUP = if ($1 & 0x00000002) {"Falling Edge"} else {"Rising Edge"}}, if ((self.RIOEN_SETUP == "Enable") && (self.CLKRM_SETUP == "Output/Output(DLB)")) {self.CLKRP_output = if ($1 & 0x00000001) {1} else {0}} else {self.CLKRP_SETUP = if ($1 & 0x00000001) {"Rising Edge"} else {"Falling Edge"}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst DLB_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Digital Loopback Mode (DLB)"
        prop JSName :: "mcbspSpcrDlb"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
        prop Set :: (self.DLB_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst CLKSTP_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,NoDelay(SPI),Delay(SPI)"
        prop Label :: "Clock Stop Mode (CLKSTP)  "
        prop JSName :: "mcbspSpcrClkstp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
        prop Set :: (self.CLKSTP_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst FREE_SETUP :: "SOFT bit Control" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SOFT bit Control,Free Running"
        prop Label :: "Serial Clock Free Running (FREE)"
        prop JSName :: "mcbspSpcrFree"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
        prop Set :: (self.FREE_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst SOFT_SETUP :: "Transmission Aborted" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Transmission Aborted,Transmission Complete"
        prop Label :: "Serial Clock Emulation (SOFT)"
        prop JSName :: "mcbspSpcrSoft"
        prop Visible :: 1
        prop Writable :: if (CSL.MCBSP_SUPPORT) && (((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) && self.FREE_SETUP == "SOFT bit Control") {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
        prop Set :: (self.SOFT_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst XINTM_SETUP :: "XRDY" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "XRDY,End of Subframe,New Frame,XSYNCERR"
        prop Label :: "Interrupt Mode (XINTM)"
        prop JSName :: "mcbspSpcrXintm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XINTM_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst RINTM_SETUP :: "RRDY" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RRDY,End of Subframe,New Frame,RSYNCERR"
        prop Label :: "Interrupt Mode (RINTM)"
        prop JSName :: "mcbspSpcrRintm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RINTM_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst XCOMPAND_SETUP :: "No Companding/MSB" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Companding/MSB,No Companding/LSB,Companding/u-law,Companding/A-law"
        prop Label :: "Companding Mode (XCOMPAND)"
        prop JSName :: "mcbspXcrXcompand"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XCOMPAND_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok")
    }
    inst RCOMPAND_SETUP :: "No Companding/MSB" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Companding/MSB,No Companding/LSB,Companding/u-law,Companding/A-law"
        prop Label :: "Companding Mode (RCOMPAND)"
        prop JSName :: "mcbspRcrRcompand"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RCOMPAND_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok")
    }
    inst XRST_SETUP :: "Disable/Reset" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable/Reset,Enable"
        prop Label :: "Enable/Disable: (XRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XRST_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst XSYNCERR_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,Set"
        prop Label :: "Bit Sync. Error (XSYNCERR)"
        prop JSName :: "mcbspSpcrXsyncerr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XSYNCERR_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst CLKXM_SETUP :: "Input/Mcbsp-slave(SPI)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Input/Mcbsp-slave(SPI),Output/Mcbsp-master(SPI)"
        prop Label :: "Clock Mode (CLKXM)  "
        prop JSName :: "mcbspPcrClkxm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.CLKXM_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKXP_SETUP :: "Rising Edge" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKXP)"
        prop JSName :: "mcbspPcrClkxp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.CLKXP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst FSXM_SETUP :: "External Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External Source,Sample-rate Generator"
        prop Label :: "Frame Sync. Mode (FSXM) "
        prop JSName :: "mcbspPcrFsxm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.FSXM_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst FSXP_SETUP :: "Active High" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame Sync. Polarity (FSXP) "
        prop JSName :: "mcbspPcrFsxp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.FSXP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst DXENA_SETUP :: = "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "DX Enabler (621x/671x/64x only)"
        prop JSName :: "mcbspSpcrDxena"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.DXENA_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst XFIG_SETUP :: "Transfer restarted" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Transfer restarted,Pulse ignored"
        prop Label :: "Unexpected Frame Pulse(XFIG)  "
        prop JSName :: "mcbspXcrXfig"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XFIG_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok")
    }
    inst XDATDLY_SETUP :: "0-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bits"
        prop Label :: "Data Delay (XDATDLY)  "
        prop JSName :: "mcbspXcrXdatdly"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XDATDLY_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok")
    }
    inst XWDREVRS_SETUP :: = "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "32-bit reversal feature (XWDREVRS) (621x/671x/64x only)"
        prop JSName :: "mcbspXcrXwdrevrs"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (self.XWDREVRS_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok")
    }
    inst XPHASE_SETUP :: "Single Phase" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Phase,Dual Phase"
        prop Label :: "Phase(s) (XPHASE)  "
        prop JSName :: "mcbspXcrXphase"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (self.XPHASE_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok")
    }
    inst XFRLEN1_SETUP :: 0x01 { 
        prop Label :: "     Word(s) per phase(1) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspXcrXfrlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (if ($1 < 1 || $1 > 128) {self.error(" Minimum word per frame :1 - Maximum words per Frame :128")} else {self.XFRLEN1_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok"})
    }
    inst XWDLEN1_SETUP :: "8-bits" { 
        prop Label :: "     Element length XWDLEN(1) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop JSName :: "mcbspXcrXwdlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (if (($1 != "8-bits") && (self.XCOMPAND_SETUP != "No Companding/MSB")) {self.XWDLEN1_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "Note: 'No Companding/MSB' (XCOMPAND) is the only mode applicable (default)- See Operating Mode Tab "} else {self.XWDLEN1_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok"})
    }
    inst XFRLEN2_SETUP :: 0x01 { 
        prop Label :: "     Word(s) per phase(2) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspXcrXfrlen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.XPHASE_SETUP == "Dual Phase")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (if ($1 < 1 || $1 > 128) {self.error(" Minimum word per frame :1 - Maximum words per Frame :128")} else {self.XFRLEN2_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok"})
    }
    inst XWDLEN2_SETUP :: "8-bits" { 
        prop Label :: "     Element length XWDLEN(2) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop JSName :: "mcbspXcrXwdLen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.XPHASE_SETUP == "Dual Phase")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (if (($1 != "8-bits") && (self.XCOMPAND_SETUP != "No Companding/MSB")) {self.XWDLEN2_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "Note: 'No Companding/MSB' (XCOMPAND) is the only mode applicable (default) "} else {self.XWDLEN2_SETUP = $1, self.XCR_VALUE = self.XCR_VALUE_update(), "ok"})
    }
    inst RRST_SETUP :: "Disable/Reset" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable/Reset,Enable"
        prop Label :: "Enable/Disable: (RRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RRST_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst RSYNCERR_SETUP :: "Clear" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,Set"
        prop Label :: "Bit Sync. Error (RSYNCERR)"
        prop JSName :: "mcbspSpcrRsyncerr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RSYNCERR_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst CLKRM_SETUP :: "Input/Hi.Z(DLB)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Input/Hi.Z(DLB),Output/Output(DLB)"
        prop Label :: "Clock Mode (CLKRM)"
        prop JSName :: "mcbspPcrClkrm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.CLKRM_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKRP_SETUP :: "Falling Edge" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKRP)"
        prop JSName :: "mcbspPcrClkrp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.CLKRP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst FSRM_SETUP :: "External Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External Source,Sample-rate Generator"
        prop Label :: "Frame Sync. Mode (FSRM)  "
        prop JSName :: "mcbspPcrFsrm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.FSRM_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst FSRP_SETUP :: "Active High" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame Sync. Polarity (FSRP) "
        prop JSName :: "mcbspPcrFsrp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.FSRP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst RJUST_SETUP :: = "Right/zero-fill" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Right/zero-fill,Right/sign-ext.,Left/zero-fill"
        prop Label :: "Data Justification/sign-ext. (RJUST)"
        prop JSName :: "mcbspSpcrRjust"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RJUST_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst RFIG_SETUP :: "Transfer restarted" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Transfer restarted,Pulse ignored"
        prop Label :: "Unexpected Frame Pulse (RFIG)  "
        prop JSName :: "mcbspRcrRfig"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RFIG_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok")
    }
    inst RDATDLY_SETUP :: "0-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bits"
        prop Label :: "Data Delay (RDATDLY)  "
        prop JSName :: "mcbspRcrRdatdly"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RDATDLY_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok")
    }
    inst RWDREVRS_SETUP :: = "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "32-bit reversal feature (RWDREVRS)(621x/671x/64x only)"
        prop JSName :: "mcbspRcrRwdrevrs"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (self.RWDREVRS_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok")
    }
    inst RPHASE_SETUP :: "Single Phase" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Phase,Dual Phase"
        prop Label :: "Phase(s) (RPHASE)  "
        prop JSName :: "mcbspRcrRphase"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (self.RPHASE_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok")
    }
    inst RFRLEN1_SETUP :: 0x01 { 
        prop Label :: "     Word(s) per phase(1) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspRcrRfrlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (if ($1 < 1 || $1 > 128) {self.error(" Minimum word per frame :1 - Maximum words per Frame :128")} else {self.RFRLEN1_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok"})
    }
    inst RWDLEN1_SETUP :: "8-bits" { 
        prop Label :: "     Element length RWDLEN(1) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop JSName :: "mcbspRcrRwdlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (if (($1 != "8-bits") && (self.RCOMPAND_SETUP != "No Companding/MSB")) {"Note: 'No Companding/MSB' (RCOMPAND) is only mode applicable (default) ".RWDLEN1_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok"} else {self.RWDLEN1_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok"})
    }
    inst RFRLEN2_SETUP :: 0x01 { 
        prop Label :: "     Word(s) per phase(2) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspRcrRfrlen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.RPHASE_SETUP == "Dual Phase")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (if ($1 < 1 || $1 > 128) {self.error(" Minimum word per frame :1 - Maximum words per Frame :128")} else {self.RFRLEN2_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok"})
    }
    inst RWDLEN2_SETUP :: "8-bits" { 
        prop Label :: "     Element length RWDLEN(2) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop JSName :: "mcbspRcrRwdlen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if (self.RPHASE_SETUP == "Dual Phase") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (if (($1 != "8-bits") && (self.RCOMPAND_SETUP != "No Companding/MSB")) {self.RWDLEN2_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "Note: 'No Companding/MSB' (RCOMPAND) is the only mode applicable (default)- Operating Mode Tab "} else {self.RWDLEN2_SETUP = $1, self.RCR_VALUE = self.RCR_VALUE_update(), "ok"})
    }
    inst GRST_SETUP :: "Reset" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Reset,Clock Generation"
        prop Label :: "Reset/Clock Generation (GRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (self.GRST_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst FRST_SETUP :: "Reset" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Reset,Frame Sync."
        prop Label :: "Reset/Frame Sync. (FRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (self.FRST_SETUP = $1, self.SPCR_VALUE = self.SPCR_VALUE_update(), "ok")
    }
    inst CLKSM_SETUP :: "Internal Clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External Clock (CLKS),Internal Clock"
        prop Label :: "Sample-Rate Gen.Clock Mode (CLKSM) "
        prop JSName :: "mcbspSrgrClksm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (self.CLKSM_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok")
    }
    inst GSYNC_SETUP :: "Free" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Free,External Frame Sync."
        prop Label :: "Sample-Rate Clock Sync. (GSYNC) "
        prop JSName :: "mcbspSrgrGsync"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if (self.CLKSM_SETUP == "External Clock (CLKS)") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (self.GSYNC_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok")
    }
    inst CLKSP_SETUP :: "Rising Edge" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "External Clock Polarity (CLKSP) "
        prop JSName :: "mcbspSrgrClksp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.CLKSM_SETUP == "External Clock (CLKS)")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (self.CLKSP_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok")
    }
    inst FSGM_SETUP :: "DXR-to-XSR copy" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DXR-to-XSR copy,Frame Sync. Signal"
        prop Label :: "Transmit Frame Sync. Mode (FSGM) "
        prop JSName :: "mcbspSrgrFsgm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.FSXM_SETUP == "Sample-rate Generator")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (self.FSGM_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok")
    }
    inst FPER_SETUP :: 0x01 { 
        prop Label :: "Frame Period (1-4096) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspSrgrFper"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.GSYNC_SETUP == "Free")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (if ($1 < 1 || $1 > 4096) {self.error("Minimum Frame Period :1 - Maximum Frame Period :4096")} else {self.FPER_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok"})
    }
    inst FWID_SETUP :: 0x01 { 
        prop Label :: "Frame Width (1-256) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspSrgrFwid"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (if ($1 < 1 || $1 > 256) {self.error("Minimum Frame Period :1 - Maximum Frame Period :256")} else {self.FWID_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok"})
    }
    inst CLKGDV_SETUP :: 0x02 { 
        prop Label :: "Clock freq.Divider (1-256) "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mcbspSrgrClkgdv"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
        prop Set :: (if ($1 < 1 || $1 > 256) {self.error("Minimum divide-down number :1 - Maximum divide-down number :256")} else {self.CLKGDV_SETUP = $1, self.SRGR_VALUE = self.SRGR_VALUE_update(), "ok"})
    }
    inst XMCM_SETUP :: "Enable/No-Masking" { 
        prop Label :: "Transmit Multichannel (XMCM)"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable/No-Masking,Enable/Masking,Disable/XP(A/B)BLK-XCEREx,Disable/RP(A/B)BLK-RCEREx"
        prop JSName :: "mcbspMcrXmcm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XMCM_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst RX_MCME_SETUP :: "Normal Operation" { 
        prop Label :: "Enhanced Multichannel Enable (XMCME-RMCME)"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Normal Operation,Enhanced Operation"
        prop Visible :: 1
        prop Writable :: (if ((CSL.C64_SUPPORT)) {1} else {0})
        prop JSName :: "mcbspMcrXmcmeRmcme"
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RX_MCME_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst XPABLK_SETUP :: "  0-to-15" { 
        prop Label :: "   Subframe Element part.A (XPABLK) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  0-to-15, 32-to-47, 64-to-79, 96-to-111"
        prop JSName :: "mcbspMcrXpablk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XPABLK_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst XPBBLK_SETUP :: " 16-to-31" { 
        prop Label :: "   Subframe Element part.B (XPBBLK)  "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 16-to-31, 48-to-63, 80-to-95, 112-to-127"
        prop JSName :: "mcbspMcrXpbblk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XPBBLK_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst XCEA_SETUP :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "   Enable Channel Part.A (XCEAn)"
        prop JSName :: "mcbspXcerXcea"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (if ($1 < 0x0000 || $1 > 0xffff) {self.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")} else {self.XCEA_SETUP = $1, self.XCER_VALUE = self.XCER_VALUE_update(), "ok"})
    }
    inst XCEB_SETUP :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02
        prop Label :: "   Enable Channel Part.B (XCEBn)"
        prop JSName :: "mcbspXcerXceb"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (if ($1 < 0x0000 || $1 > 0xffff) {self.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")} else {self.XCEB_SETUP = $1, self.XCER_VALUE = self.XCER_VALUE_update(), "ok"})
    }
    inst XCE0_SETUP :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE0)"
        prop JSName :: "mcbspXcere0Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XCE0_SETUP = $1, self.XCERE0_VALUE = self.XCERE0_VALUE_update(), "ok")
    }
    inst XCE1_SETUP :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE1)"
        prop JSName :: "mcbspXcere1Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XCE1_SETUP = $1, self.XCERE1_VALUE = self.XCERE1_VALUE_update(), "ok")
    }
    inst XCE2_SETUP :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE2)"
        prop JSName :: "mcbspXcere2Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XCE2_SETUP = $1, self.XCERE2_VALUE = self.XCERE2_VALUE_update(), "ok")
    }
    inst XCE3_SETUP :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE3)"
        prop JSName :: "mcbspXcere3Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.XCE3_SETUP = $1, self.XCERE3_VALUE = self.XCERE3_VALUE_update(), "ok")
    }
    inst RMCM_SETUP :: "All Enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "All Enable,Disable/RP(A/B)BLK-RCEREx"
        prop Label :: "Receive Multichannel (RMCM)"
        prop JSName :: "mcbspMcrRmcm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RMCM_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst RPABLK_SETUP :: "  0-to-15" { 
        prop Label :: "   Subframe Element part.A (RPABLK) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "  0-to-15, 32-to-47, 64-to-79, 96-to-111"
        prop JSName :: "mcbspMcrRpablk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RPABLK_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst RPBBLK_SETUP :: " 16-to-31" { 
        prop Label :: "   Subframe Element part.B (RPBBLK) "
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 16-to-31, 48-to-63, 80-to-95, 112-to-127"
        prop JSName :: "mcbspMcrRpbblk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RPBBLK_SETUP = $1, self.MCR_VALUE = self.MCR_VALUE_update(), "ok")
    }
    inst RCEA_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Label :: "   Enable Channel Part.A (RCEAn)"
        prop JSName :: "mcbspRcerRcea"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT && !CSL.C64_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (if ($1 < 0x0000 || $1 > 0xffff) {self.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")} else {self.RCEA_SETUP = $1, self.RCER_VALUE = self.RCER_VALUE_update(), "ok"})
    }
    inst RCEB_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enable Channel Part.B (RCEBn)"
        prop Format :: "0x%04X"
        prop JSName :: "mcbspRcerRceb"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT && !CSL.C64_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (if ($1 < 0x0000 || $1 > 0xffff) {self.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")} else {self.RCEB_SETUP = $1, self.RCER_VALUE = self.RCER_VALUE_update(), "ok"})
    }
    inst RCE0_SETUP :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE0)"
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere0Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RCE0_SETUP = $1, self.RCERE0_VALUE = self.RCERE0_VALUE_update(), "ok")
    }
    inst RCE1_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE1)"
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere1Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RCE1_SETUP = $1, self.RCERE1_VALUE = self.RCERE1_VALUE_update(), "ok")
    }
    inst RCE2_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE2)"
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere2Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RCE2_SETUP = $1, self.RCERE2_VALUE = self.RCERE2_VALUE_update(), "ok")
    }
    inst RCE3_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE3)"
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere3Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (self.RCE3_SETUP = $1, self.RCERE3_VALUE = self.RCERE3_VALUE_update(), "ok")
    }
    inst XIOEN_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "GP I/O Enable (XIOEN)"
        prop JSName :: "mcbspPcrXioen"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if (self.XRST_SETUP == "Disable/Reset") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (self.XIOEN_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKXP_output :: 0x00 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   CLKX Output value"
        prop JSName :: "mcbspClkxOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.XIOEN_SETUP == "Enable") && (self.CLKXM_SETUP == "Output/Mcbsp-master(SPI)")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (if ($1 < 0 || $1 > 1) {self.error("Binary value only: 0 or 1")} else {self.CLKXP_output = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok"})
    }
    inst FSXP_output :: 0x00 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   FSX Output value"
        prop JSName :: "mcbspFsxOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.XIOEN_SETUP == "Enable") && (self.FSXM_SETUP == "Sample-rate Generator")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (if ($1 < 0 || $1 > 1) {self.error("Binary value only: 0 or 1")} else {self.FSXP_output = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok"})
    }
    inst DX_output :: 0x00 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   DX Output (DX_STAT)"
        prop JSName :: "mcbspPcrDxstat"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if (self.XIOEN_SETUP == "Enable") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (if ($1 < 0 || $1 > 1) {self.error("Binary value only: 0 or 1")} else {self.DX_output = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok"})
    }
    inst RIOEN_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "GP I/O Enable (RIOEN)"
        prop JSName :: "mcbspPcrRioen"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if (self.RRST_SETUP == "Disable/Reset") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (self.RIOEN_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKRP_output :: 0x00 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   CLKR Output value"
        prop JSName :: "mcbspClkrOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.RIOEN_SETUP == "Enable") && (self.CLKRM_SETUP == "Output/Output(DLB)")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (if ($1 < 0 || $1 > 1) {self.error("Binary value only: 0 or 1")} else {self.CLKRP_output = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok"})
    }
    inst FSRP_output :: 0x00 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   FSR Output value"
        prop JSName :: "mcbspFsrOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && (if ((self.RIOEN_SETUP == "Enable") && (self.FSRM_SETUP == "Sample-rate Generator")) {1} else {0})
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (if ($1 < 0 || $1 > 1) {self.error("Binary value only: 0 or 1")} else {self.FSRP_output = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok"})
    }
    inst SPCR_VALUE :: self.SPCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Serial Port Control Reg. (SPCR) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspSpcr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)) {$e = $1 & 0x00006000, if ($e == 0x00006000) {self.error("Invalid input for RJUST bit[13..14]")} else {$a = $1 & 0x00000700, if ($a != 0) {self.error("Bit field(bit[8..10]) is reserved")} else {$b = $1 & 0x00000040, if ($b != 0) {self.error("Bit field 6 is reserved")} else {self.SPCR_VALUE = $1 & 0x033EFFFE, self.SPCR_SETUP_update($1 & 0x033EFFFE), "ok"}}}} else {$f = $1 & 0x00006000, if ($f == 0x00006000) {self.error("Invalid input for RJUST bit[13..14]")} else {$c = $1 & 0x00000700, if ($c != 0) {self.error("Bit field(bit[8..10]) is reserved")} else {$d = $1 & 0x00000040, if ($d != 0) {self.error("Bit field 6 is reserved")} else {self.SPCR_VALUE = $1 & 0x003EFFFE, self.SPCR_SETUP_update($1 & 0x003EFFFE), "ok"}}}})
    }
    inst RCR_VALUE :: self.RCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Receiver Control Reg. (RCR) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (if (CSL.C11_SUPPORT || CSL.C64_SUPPORT) {$a = $1 & 0x00008000, $b = $1 & 0x0000000F, $e = $1 & 0x00030000, $g = $1 & 0x00C00000, $h = $1 & 0x000000C0, if ($g == 0x00C00000) {self.error("Invalid input for RWDLEN2 bit[21..23]")} else {if ($h == 0x000000C0) {self.error("Invalid input for RWDLEN1 bit[5..7]")} else {if ($e == 0x00030000) {self.error("Invalid input for RDATDLY bit[16..17]")} else {if ($a != 0) {self.error("Bit field 15 is reserved")} else {if ($b != 0) {self.error("Bit field(bit[0..3]) is reserved")} else {self.RCR_VALUE = $1, self.RCR_SETUP_update($1), "ok"}}}}}} else {$c = $1 & 0x00008000, $d = $1 & 0x0000001F, $f = $1 & 0x00030000, $i = $1 & 0x00C00000, $j = $1 & 0x000000C0, if ($i == 0x00C00000) {self.error("Invalid input for RWDLEN2 bit[21..23]")} else {if ($j == 0x000000C0) {self.error("Invalid input for RWDLEN1 bit[5..7]")} else {if ($f == 0x00030000) {self.error("Invalid input for RDATDLY bit[16..17]")} else {if ($c != 0) {self.error("Bit field 15 is reserved")} else {if ($d != 0) {self.error("Bit field(bit[0..4]) is reserved")} else {self.RCR_VALUE = $1, self.RCR_SETUP_update($1), "ok"}}}}}})
    }
    inst XCR_VALUE :: self.XCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transmitter Control Reg. (XCR) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspXcr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint32"
        prop Set :: (if (CSL.C11_SUPPORT || CSL.C64_SUPPORT) {$a = $1 & 0x00008000, $b = $1 & 0x0000000F, $e = $1 & 0x00030000, $g = $1 & 0x00C00000, $h = $1 & 0x000000C0, if ($g == 0x00C00000) {self.error("Invalid input for XWDLEN2 bit[21..23]")} else {if ($h == 0x000000C0) {self.error("Invalid input for XWDLEN1 bit[5..7]")} else {if ($e == 0x00030000) {self.error("Invalid input for XDATDLY bit[16..17]")} else {if ($a != 0) {self.error("Bit field 15 is reserved")} else {if ($b != 0) {self.error("Bit field(bit[0..3]) is reserved")} else {self.XCR_VALUE = $1, self.XCR_SETUP_update($1), "ok"}}}}}} else {$c = $1 & 0x00008000, $d = $1 & 0x0000001F, $f = $1 & 0x00030000, $i = $1 & 0x00C00000, $j = $1 & 0x000000C0, if ($i == 0x00C00000) {self.error("Invalid input for XWDLEN2 bit[21..23]")} else {if ($j == 0x000000C0) {self.error("Invalid input for XWDLEN1 bit[5..7]")} else {if ($f == 0x00030000) {self.error("Invalid input for XDATDLY bit[16..17]")} else {if ($c != 0) {self.error("Bit field 15 is reserved")} else {if ($d != 0) {self.error("Bit field(bit[0..4]) is reserved")} else {self.XCR_VALUE = $1, self.XCR_SETUP_update($1), "ok"}}}}}})
    }
    inst SRGR_VALUE :: self.SRGR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Sample-Rate Generator Reg. (SRGR) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspSrgr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.SRGR_VALUE = $1, self.SRGR_SETUP_update($1), "ok")
    }
    inst MCR_VALUE :: self.MCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Multichannel Control Reg. (MCR) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspMcr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x02000200, if (CSL.C64_SUPPORT && ($a == 0x00000200 || $a == 0x02000000)) {self.error("XMCME and RMCME have to be identical")} else {self.MCR_VALUE = $1, self.MCR_SETUP_update($1), "ok"})
    }
    inst RCER_VALUE :: self.RCER_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Receiver Channel Enable(RCER) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcer"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: !CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.RCER_VALUE = $1, self.RCER_SETUP_update($1), "ok")
    }
    inst RCERE0_VALUE :: self.RCERE0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE0) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere0"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.RCERE0_VALUE = $1, self.RCERE0_SETUP_update($1), "ok")
    }
    inst RCERE1_VALUE :: self.RCERE1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE1) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.RCERE1_VALUE = $1, self.RCERE1_SETUP_update($1), "ok")
    }
    inst RCERE2_VALUE :: self.RCERE2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE2) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.RCERE2_VALUE = $1, self.RCERE2_SETUP_update($1), "ok")
    }
    inst RCERE3_VALUE :: self.RCERE3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE3) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspRcere3"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.RCERE3_VALUE = $1, self.RCERE3_SETUP_update($1), "ok")
    }
    inst XCER_VALUE :: self.XCER_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transmitter Channel Enable(XCER) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspXcer"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: !CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XCER_VALUE = $1, self.XCER_SETUP_update($1), "ok")
    }
    inst XCERE0_VALUE :: self.XCERE0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE0) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspXcere0"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XCERE0_VALUE = $1, self.XCERE0_SETUP_update($1), "ok")
    }
    inst XCERE1_VALUE :: self.XCERE1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE1) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspXcere1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XCERE1_VALUE = $1, self.XCERE1_SETUP_update($1), "ok")
    }
    inst XCERE2_VALUE :: self.XCERE2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE2) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspXcere2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XCERE2_VALUE = $1, self.XCERE2_SETUP_update($1), "ok")
    }
    inst XCERE3_VALUE :: self.XCERE3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE3) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspXcere3"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT
        prop NoGen :: 0
        prop cGen :: CSL.C64_SUPPORT
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XCERE3_VALUE = $1, self.XCERE3_SETUP_update($1), "ok")
    }
    inst PCR_VALUE :: self.PCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Pin Control Reg. (PCR) "
        prop Format :: "0x%08X"
        prop JSName :: "mcbspPcr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.PCR_VALUE = $1, self.PCR_SETUP_update($1), "ok")
    }
}

type hMcbsp {
    isa ObjectMgr
    prop name :: "hMcbsp"
    prop Label :: "MCBSP Resource Manager"
    prop JSName :: "HMCBSP"
    prop IsContainedIn :: MCBSPFOLDER
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{1E62DD10-59A8-11d4-947D-0050048381B7}"
    prop InstancePropertyPage :: "{1E62DD11-59A8-11d4-947D-0050048381B7}"
    prop GlobalIcon :: 159
    prop InstanceIcon :: 160
    prop GlobalHelpTopic :: (1052)
    prop InstanceHelpTopic :: (1053)
    prop localCanCreate :: (self.error("New Mcbsp handle objects cannot be created"))
    prop localCanDelete :: (self.error("Mcbsp handle objects cannot be deleted"))
    prop chipcall :: (scan ($i; hMcbsp) {if (!CSL.MCBSP2_SUPPORT && $i.PORT == "MCBSP2") {$i.MCBSP_HANDLE_ENABLE = 0, $i.MCBSP_INIT_ENABLE = 0, $i.cOpenArg0 = "MCBSP_None"} }, if (self.CHIPCHAIN != nil) {$e = self.CHIPCHAIN.chipcall()} , "ok")
    prop localInit :: (self.CHIPCHAIN = GBL.CHIPCHAIN, GBL.CHIPCHAIN = hMcbsp)
    prop cGen :: 1
    prop cHandle :: (self.cOpenGen)
    prop cHeaderName :: ($a = "", scan ($b; hMcbsp) {if ($b.MCBSP_HANDLE_ENABLE == 1) {$a = "csl_mcbsp.h"} }, $a)
    prop cHandleType :: "MCBSP_Handle"
    prop cStructQual :: "far"
    prop cOpenName :: "MCBSP_open"
    prop cConfigName :: "MCBSP_config"
    prop cHandleName :: self.HandleName
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil { 
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst MCBSP_HANDLE_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open MCBSP Port"
        prop JSName :: "mcbspHandleEnable"
        prop Visible :: 1
        prop Writable :: if (CSL.MCBSP_SUPPORT) && (CSL.MCBSP2_SUPPORT || (!CSL.MCBSP2_SUPPORT && (self.PORT == "MCBSP0" || self.PORT == "MCBSP1"))) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, if ($1 == 0) {self.MCBSP_HANDLE_ENABLE = $1, self.MCBSP_INIT = MCBSP_NOTHING, self.cOpenArg0 = "MCBSP_None", "ok"} else {self.MCBSP_HANDLE_ENABLE = $1, if (self.PORT == "MCBSP0") {self.cOpenArg0 = "MCBSP_DEV0", "ok"} else {if (self.PORT == "MCBSP1") {self.cOpenArg0 = "MCBSP_DEV1", "ok"} else {self.cOpenArg0 = "MCBSP_DEV2", "ok"}}})
    }
    inst HandleName :: self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Handle  "
        prop JSName :: "mcbspHandleName"
        prop Visible :: 1
        prop Writable :: if (CSL.MCBSP_SUPPORT) && (self.MCBSP_HANDLE_ENABLE == 1) {1} else {0}
    }
    inst PORT :: "MCBSP0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "MCBSP0,MCBSP1,MCBSP2"
        prop Label :: "        Port"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
    }
    inst cOpenGen :: = (CSL.MCBSP_SUPPORT && (self.MCBSP_HANDLE_ENABLE == 1) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
    }
    inst cOpenArg0 :: (if (self.MCBSP_HANDLE_ENABLE == 0) {"MCBSP_None"} ) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "   Arg0 "
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "MCBSP_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-initialize (Default) "
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 0
        prop NoGen :: 1
    }
    inst MCBSP_INIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "mcbspEnablePreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.MCBSP_SUPPORT) && (self.MCBSP_HANDLE_ENABLE == 1) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; mcbspCfg) {$a = $a + 1}, if ($a == 1) {self.MCBSP_INIT_ENABLE = 0, self.error("You must create a new configuration object")} else {self.MCBSP_INIT_ENABLE = $1, if ($1 == 0) {self.MCBSP_INIT = MCBSP_NOTHING} , "ok"})
    }
    inst MCBSP_INIT :: MCBSP_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: mcbspCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "mcbspPreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.MCBSP_SUPPORT) && ((self.MCBSP_INIT_ENABLE == 1) && (self.MCBSP_HANDLE_ENABLE == 1)) {1} else {0}
        prop NoGen :: 0
    }
    inst cConfigGen :: = ((self.MCBSP_HANDLE_ENABLE == 1) && (self.MCBSP_INIT_ENABLE == 1) && (self.MCBSP_INIT != MCBSP_NOTHING) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = self.cHandleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
    }
    inst cConfigArg1 :: = self.MCBSP_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: mcbspCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) && 1
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
}

object Mcbsp_Port0 :: hMcbsp {
    param iComment :: "Mcbsp 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hMcbsp"
    param iDelMsg :: "This MCBSP Handle object cannot be deleted"
    param MCBSP_HANDLE_ENABLE :: 0
    param HandleName :: "hMcbsp0"
    param PORT :: "MCBSP0"
    param cOpenArg0 :: "MCBSP_None"
    param cOpenArg1 :: "MCBSP_OPEN_RESET"
    param MCBSP_INIT_ENABLE :: 0
    param MCBSP_INIT :: MCBSP_NOTHING
}

object Mcbsp_Port1 :: hMcbsp {
    param iComment :: "Mcbsp 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hMcbsp"
    param iDelMsg :: "This MCBSP Handle object cannot be deleted"
    param MCBSP_HANDLE_ENABLE :: 0
    param HandleName :: "hMcbsp1"
    param PORT :: "MCBSP1"
    param cOpenArg0 :: "MCBSP_None"
    param cOpenArg1 :: "MCBSP_OPEN_RESET"
    param MCBSP_INIT_ENABLE :: 0
    param MCBSP_INIT :: MCBSP_NOTHING
}

object Mcbsp_Port2 :: hMcbsp {
    param iComment :: "Mcbsp 2"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hMcbsp"
    param iDelMsg :: "This MCBSP Handle object cannot be deleted"
    param MCBSP_HANDLE_ENABLE :: 0
    param HandleName :: "hMcbsp2"
    param PORT :: "MCBSP2"
    param cOpenArg0 :: "MCBSP_None"
    param cOpenArg1 :: "MCBSP_OPEN_RESET"
    param MCBSP_INIT_ENABLE :: 0
    param MCBSP_INIT :: MCBSP_NOTHING
}

object MCBSP_NOTHING :: mcbspCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param DLB_SETUP :: "Disable"
    param CLKSTP_SETUP :: "Disable"
    param FREE_SETUP :: "SOFT bit Control"
    param SOFT_SETUP :: "Transmission Aborted"
    param XINTM_SETUP :: "XRDY"
    param RINTM_SETUP :: "RRDY"
    param XCOMPAND_SETUP :: "No Companding/MSB"
    param RCOMPAND_SETUP :: "No Companding/MSB"
    param XRST_SETUP :: "Disable/Reset"
    param XSYNCERR_SETUP :: "Clear"
    param CLKXM_SETUP :: "Input/Mcbsp-slave(SPI)"
    param CLKXP_SETUP :: "Rising Edge"
    param FSXM_SETUP :: "External Source"
    param FSXP_SETUP :: "Active High"
    param XFIG_SETUP :: "Transfer restarted"
    param XDATDLY_SETUP :: "0-bit"
    param XPHASE_SETUP :: "Single Phase"
    param XFRLEN1_SETUP :: 1
    param XWDLEN1_SETUP :: "8-bits"
    param XFRLEN2_SETUP :: 1
    param XWDLEN2_SETUP :: "8-bits"
    param RRST_SETUP :: "Disable/Reset"
    param RSYNCERR_SETUP :: "Clear"
    param CLKRM_SETUP :: "Input/Hi.Z(DLB)"
    param CLKRP_SETUP :: "Falling Edge"
    param FSRM_SETUP :: "External Source"
    param FSRP_SETUP :: "Active High"
    param RFIG_SETUP :: "Transfer restarted"
    param RDATDLY_SETUP :: "0-bit"
    param RPHASE_SETUP :: "Single Phase"
    param RFRLEN1_SETUP :: 1
    param RWDLEN1_SETUP :: "8-bits"
    param RFRLEN2_SETUP :: 1
    param RWDLEN2_SETUP :: "8-bits"
    param GRST_SETUP :: "Reset"
    param FRST_SETUP :: "Reset"
    param CLKSM_SETUP :: "Internal Clock"
    param GSYNC_SETUP :: "Free"
    param CLKSP_SETUP :: "Rising Edge"
    param FSGM_SETUP :: "DXR-to-XSR copy"
    param FPER_SETUP :: 1
    param FWID_SETUP :: 1
    param CLKGDV_SETUP :: 2
    param XMCM_SETUP :: "Enable/No-Masking"
    param RX_MCME_SETUP :: "Normal Operation"
    param XPABLK_SETUP :: "  0-to-15"
    param XPBBLK_SETUP :: " 16-to-31"
    param XCEA_SETUP :: 0
    param XCEB_SETUP :: 0
    param XCE0_SETUP :: 0
    param XCE1_SETUP :: 0
    param XCE2_SETUP :: 0
    param XCE3_SETUP :: 0
    param RMCM_SETUP :: "All Enable"
    param RPABLK_SETUP :: "  0-to-15"
    param RPBBLK_SETUP :: " 16-to-31"
    param RCEA_SETUP :: 0
    param RCEB_SETUP :: 0
    param RCE0_SETUP :: 0
    param RCE1_SETUP :: 0
    param RCE2_SETUP :: 0
    param RCE3_SETUP :: 0
    param XIOEN_SETUP :: "Disable"
    param CLKXP_output :: 0
    param FSXP_output :: 0
    param DX_output :: 0
    param RIOEN_SETUP :: "Disable"
    param CLKRP_output :: 0
    param FSRP_output :: 0
    param SPCR_VALUE :: 0
    param RCR_VALUE :: 0
    param XCR_VALUE :: 0
    param SRGR_VALUE :: 536870913
    param MCR_VALUE :: 0
    param RCER_VALUE :: 0
    param RCERE0_VALUE :: 0
    param RCERE1_VALUE :: 0
    param RCERE2_VALUE :: 0
    param RCERE3_VALUE :: 0
    param XCER_VALUE :: 0
    param XCERE0_VALUE :: 0
    param XCERE1_VALUE :: 0
    param XCERE2_VALUE :: 0
    param XCERE3_VALUE :: 0
    param PCR_VALUE :: 0
}

type TCPFOLDER {
    prop Label :: "Turbo Decoder Coprocessor -TCP "
    prop GlobalIcon :: 197
    prop InstanceIcon :: 198
    prop GlobalHelpTopic :: 1080
    prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type tcpBaseParam {
    isa ObjectMgr
    prop name :: "tcpBaseParam"
    prop Label :: "TCP Parameters Manager"
    prop JSName :: "TCPBP"
    prop IsContainedIn :: TCPFOLDER
    prop GlobalIcon :: 197
    prop InstanceIcon :: 198
    prop GlobalHelpTopic :: 1081
    prop InstanceHelpTopic :: 1081
    prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C8}"
    prop InstancePropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop NoGen :: 1
    prop cGen :: CSL.TCP_SUPPORT
    prop cStruct :: CSL.TCP_SUPPORT
    prop cHeaderName :: if self.gNumOf > 0 {"csl_tcp.h"} else {""}
    prop cStructType :: "TCP_BaseParams"
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "TCP_genParams"
    prop ParamConfigType :: if (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") {"TCP_Params "} else {""}
    prop ParamConfigName :: if (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") {hTcp.TCP_PARAMCONFIGNAME} else {""}
    prop ParamEnd :: if (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") {";\n"} else {""}
    prop cGenCEpilogue :: ("%1S%2S%3S\n\0,ParamConfigType,ParamConfigName,ParamEnd")
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; tcpBaseParam) {$a += 1}, if ($a == 2) {hTcp.TCP_INITPARAM_ENABLE = 0} , "ok")
    prop GenParamStr :: if (hTcp.TCP_INITPARAM_ENABLE == 1) {"TCP_genParams(&%3s, &"} else {""}
    prop ParamConfigObj :: if (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") {hTcp.TCP_PARAMCONFIGNAME} else {""}
    prop ConfigEnd :: if (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") {");"} else {""}
    prop cGenFxnPreInst :: ("   %1S%2S%4S\n\0,GenParamStr,ParamConfigObj,cStructName,ConfigEnd")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hTcp.TCP_INITPARAM { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: tcpBaseParam
        prop Label :: "Pre-initialize Params"
        prop Visible :: 0
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst cConfigArg1 :: = hTcp.TCP_PARAMCONFIGNAME { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-initialize Params"
        prop Visible :: 0
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst STANDARD_SETUP :: "3GPP" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3GPP,IS2000"
        prop Label :: "Turbo Decoder Standard"
        prop Visible :: 1
        prop JSName :: "tcpBaseParamStandard"
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 == "IS2000") {self.cStandardGen = "TCP_STANDARD_IS2000"} else {self.cStandardGen = "TCP_STANDARD_3GPP"}, self.STANDARD_SETUP = $1, "ok")
    }
    inst cStandardGen :: = "TCP_STANDARD_3GPP" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Standard"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst RATE_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate (RATE)"
        prop Visible :: 1
        prop JSName :: "tcpBaseParamRate"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (if (self.STANDARD_SETUP == "3GPP" && $1 != "1/3") {self.error("Rate 1/3 is required for 3GPP Standard")} else {if ($1 == "1/2") {self.cRateGen = "TCP_RATE_1_2"} else {if ($1 == "1/3") {self.cRateGen = "TCP_RATE_1_3"} else {if ($1 == "1/4") {self.cRateGen = "TCP_RATE_1_4"} else {self.cRateGen = " 0"}}}, self.RATE_SETUP = $1, "ok"})
    }
    inst cRateGen :: = " 0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Rate"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst FRAMELEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (FL: 40 to 20730) "
        prop Visible :: 1
        prop JSName :: "tcpBaseParamFrameLen"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 < 40 || $1 > 20730) {self.error("Frame Length range [40-20730]")} else {self.FRAMELEN_SETUP = $1, "ok"})
    }
    inst PROLSIZE_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Prolog Size (P: 24 to 48)"
        prop Visible :: 1
        prop JSName :: "tcpBaseParamProlSize"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 < 24 || $1 > 48) {self.error("Prolog Size range [24-48]")} else {self.PROLSIZE_SETUP = $1, "ok"})
    }
    inst MAXIT_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Maximum of Iterations (MAXIT - SA mode only)"
        prop Visible :: 1
        prop JSName :: "tcpBaseParamMaxIt"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 < 0 || $1 > 32) {self.error("Maximum number of Iterations range [0-32]")} else {self.MAXIT_SETUP = $1, "ok"})
    }
    inst SNR_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " SNR Threshold (SNR - SA mode only)"
        prop Visible :: 1
        prop JSName :: "tcpBaseParamSnrTh"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 < 0 || $1 > 100) {self.error("Maximum number of Iterations range [0-100]")} else {self.SNR_SETUP = $1, "ok"})
    }
    inst INTER_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Interleaver Write Flag (INTER)"
        prop Visible :: 1
        prop JSName :: "tcpBaseParamInterFlag"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 == "Enable") {self.cInterGen = " 1"} else {self.cInterGen = " 0"}, self.INTER_SETUP = $1, "ok")
    }
    inst cInterGen :: = " 0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Interleaver Write Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst OUTF_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Output Parameters Read Flag (OUTF) "
        prop Visible :: 1
        prop JSName :: "tcpBaseParamOutFlag"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (if ($1 == "Enable") {self.cOutfGen = " 1"} else {self.cOutfGen = " 0"}, self.OUTF_SETUP = $1, "ok")
    }
    inst cOutfGen :: = " 0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Output Parameters Read Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
}

type tcpCfg {
    isa ObjectMgr
    prop name :: "tcpCfg"
    prop Label :: "TCP Configuration Manager"
    prop JSName :: "TCP"
    prop IsContainedIn :: TCPFOLDER
    prop GlobalIcon :: 197
    prop InstanceIcon :: 198
    prop GlobalHelpTopic :: 1082
    prop InstanceHelpTopic :: 1082
    prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C8}"
    prop InstancePropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop NoGen :: 1
    prop cGen :: CSL.TCP_SUPPORT
    prop cStruct :: CSL.TCP_SUPPORT
    prop cHeaderName :: if self.gNumOf > 0 {"csl_tcp.h"} else {""}
    prop cStructType :: "TCP_ConfigIc"
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "TCP_icConfig"
    prop SetParamStr :: if (hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING) {"TCP_setParams(&"} else {""}
    prop ParamConfigObj :: if (hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING && hTcp.TCP_PARAMCONFIGNAME != "NULL") {hTcp.TCP_PARAMCONFIGNAME} else {""}
    prop IcConfigObj :: if (hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING && hTcp.TCP_PARAMCONFIGNAME != "NULL") {",&%4s"} else {""}
    prop ConfigEnd :: if (hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING && hTcp.TCP_PARAMCONFIGNAME != "NULL") {");"} else {""}
    prop cGenFxnPreInst :: ("   %1S%2S%3S%5S\n\0,SetParamStr,ParamConfigObj,IcConfigObj,cStructName,ConfigEnd")
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; tcpCfg) {$a += 1}, if ($a == 2) {hTcp.TCP_INIT_ENABLE = 0} , "ok")
    prop OPMOD_IC0 :: (if (self.MODE_SETUP == "Standalone(SA)") {0} else {if (self.MAP_SETUP == "MAP1(1st Iter.)") {0x00000008} else {if (self.MAP_SETUP == "MAP1(Any Other Iter.)") {0x0000000A} else {0x0000000E}}})
    prop RATE_IC0 :: (if (self.RATE_SETUP == "None") {0} else {if (self.RATE_SETUP == "1/2") {0x00000100} else {if (self.RATE_SETUP == "1/3") {0x00000200} else {0x00000300}}})
    prop OUTF_IC0 :: (if (self.OUTF_SETUP == "Disable") {0} else {0x00002000})
    prop INTER_IC0 :: (if (self.INTER_SETUP == "Disable") {0x00000000} else {0x00001000})
    prop FRAMELEN_IC0 :: (self.FRAMELEN_SETUP << 16)
    prop RELLEN_IC1 :: (self.RELLEN_SETUP << 16)
    prop SUBFRAMELEN_IC1 :: (self.SUBFRAMELEN_SETUP)
    prop LASTRELLEN_IC1 :: (self.LASTRELLEN_SETUP << 24)
    prop PROLSIZE_IC2 :: (self.PROLSIZE_SETUP)
    prop NUMSUBBLK_IC2 :: (self.NUMSUBBLK_SETUP << 8)
    prop LASTNUMSUBBLK_IC2 :: (self.LASTNUMSUBBLK_SETUP << 12)
    prop MAXIT_IC2 :: (self.MAXIT_SETUP << 16)
    prop SNR_IC2 :: (self.SNR_SETUP << 24)
    prop NWORDINTER_IC3 :: (self.NWORDINTER_SETUP)
    prop NWORDSP_IC3 :: (self.NWORDSP_SETUP << 16)
    prop NWORDAP_IC4 :: (self.NWORDAP_SETUP)
    prop NWORDEXT_IC4 :: (self.NWORDEXT_SETUP << 16)
    prop NWORDHD_IC5 :: (self.NWORDHD_SETUP)
    prop IC0_VALUE_update :: (self.OPMOD_IC0() | self.RATE_IC0() | self.FRAMELEN_IC0() | self.OUTF_IC0() | self.INTER_IC0())
    prop IC0_SETUP_update :: (self.FRAMELEN_SETUP = ($1 & 0xFFFF0000) >> 16, self.OUTF_SETUP = if ($1 & 0x00002000) {"Enable"} else {"Disable"}, self.INTER_SETUP = if ($1 & 0x00001000) {"Enable"} else {"Disable"}, self.RATE_SETUP = ($a = ($1 & 0x00000300), if ($a == 0x00000100) {"1/2"} else {if ($a == 0x00000200) {"1/3"} else {if ($a == 0x00000300) {"1/4"} else {"None"}}}), self.MAP_SETUP = ($a = ($1 & 0x0000000E), if ($a == 0x00000008) {"MAP1(1st Iter.)"} else {if ($a == 0x0000000A) {"MAP1(Any Other Iter.)"} else {if ($a == 0x0000000E) {"MAP2"} else {"MAP1(1st Iter.)"}}}), self.MODE_SETUP = ($a = ($1 & 0x0000000E), if ($a == 0x00000000) {"Standalone(SA)"} else {"Shared(SP)"}))
    prop IC1_VALUE_update :: (self.LASTRELLEN_IC1() | self.RELLEN_IC1() | self.SUBFRAMELEN_IC1())
    prop IC1_SETUP_update :: (self.LASTRELLEN_SETUP = ($1 & 0x7F000000) >> 24, self.RELLEN_SETUP = ($1 & 0x007F0000) >> 16, self.SUBFRAMELEN_SETUP = ($1 & 0x0000FFFF))
    prop IC2_VALUE_update :: (self.SNR_IC2() | self.MAXIT_IC2() | self.LASTNUMSUBBLK_IC2() | self.NUMSUBBLK_IC2() | self.PROLSIZE_IC2())
    prop IC2_SETUP_update :: (self.SNR_SETUP = ($1 & 0xFF000000) >> 24, self.MAXIT_SETUP = ($1 & 0x001F0000) >> 16, self.LASTNUMSUBBLK_SETUP = ($1 & 0x0000F000) >> 12, self.NUMSUBBLK_SETUP = ($1 & 0x00000F00) >> 8, self.PROLSIZE_SETUP = ($1 & 0x0000003F))
    prop IC3_VALUE_update :: (self.NWORDINTER_IC3() | self.NWORDSP_IC3())
    prop IC3_SETUP_update :: (self.NWORDINTER_SETUP = ($1 & 0x0000FFFF), self.NWORDSP_SETUP = ($1 & 0xFFFF0000) >> 16)
    prop IC4_VALUE_update :: (self.NWORDAP_IC4() | self.NWORDEXT_IC4())
    prop IC4_SETUP_update :: (self.NWORDAP_SETUP = ($1 & 0x0000FFFF), self.NWORDEXT_SETUP = ($1 & 0xFFFF0000) >> 16)
    prop IC5_VALUE_update :: (self.NWORDHD_IC5() & 0x000000FF)
    prop IC5_SETUP_update :: (self.NWORDHD_SETUP = ($1 & 0x000000FF))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((hTcp.TCP_INIT_ENABLE == 1) && (hTcp.TCP_INIT == self) && (hTcp.TCP_INIT != TCP_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hTcp.TCP_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: tcpCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst STANDARD_SETUP :: "3GPP" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3GPP,IS2000"
        prop Label :: "Turbo Decoder Standard"
        prop Visible :: 1
        prop JSName :: "tcpDecoderStandard"
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 == "IS2000") {self.cStandardGen = "TCP_STANDARD_IS2000"} else {self.cStandardGen = "TCP_STANDARD_3GPP"}, self.STANDARD_SETUP = $1, "ok")
    }
    inst cStandardGen :: = "TCP_STANDARD_3GPP" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Standard"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst MODE_SETUP :: "Standalone(SA)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Standalone(SA),Shared(SP)"
        prop Label :: "Turbo Decoder Operation Mode"
        prop Visible :: 1
        prop JSName :: "tcpMode"
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 == "Standalone(SA)") {self.cModeGen = "TCP_MODE_SA"} else {self.cModeGen = "TCP_MODE_SP"}, self.MODE_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok")
    }
    inst cModeGen :: = "TCP_MODE_SA" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Mode"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst MAP_SETUP :: "MAP1(1st Iter.)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "MAP1(1st Iter.),MAP1(Any Other Iter.),MAP2"
        prop Label :: " Map (SP Mode only)"
        prop Visible :: 1
        prop JSName :: "tcpMap"
        prop Writable :: if (CSL.TCP_SUPPORT != 0 && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 == "MAP1(1st Iter.)") {self.cMapGen = "TCP_MAP_MAP1A"} else {if ($1 == "MAP1(Any Other Iter.)") {self.cMapGen = "TCP_MAP_MAP1B"} else {self.cMapGen = "TCP_MAP_MAP2"}}, self.MAP_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok")
    }
    inst cMapGen :: = "TCP_MAP_MAP1A" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Operation Map (SP Mode only)"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst RATE_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate (RATE)"
        prop Visible :: 1
        prop JSName :: "tcpIc0Rate"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if (self.STANDARD_SETUP == "3GPP" && $1 != "1/3") {self.error("Rate 1/3 is required for 3GPP Standard")} else {if ($1 == "1/2") {self.cRateGen = "TCP_RATE_1_2"} else {if ($1 == "1/3") {self.cRateGen = "TCP_RATE_1_3"} else {if ($1 == "1/4") {self.cRateGen = "TCP_RATE_1_4"} else {self.cRateGen = " 0"}}}, self.RATE_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok"})
    }
    inst cRateGen :: = "0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Rate"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst OUTF_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Output Parameters Read Flag (OUTF) "
        prop Visible :: 1
        prop JSName :: "tcpIc0OutFlag"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (self.OUTF_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok")
    }
    inst cOutfGen :: = "0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Output Parameters Read Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst INTER_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Interleaver Write Flag (INTER)"
        prop Visible :: 1
        prop JSName :: "tcpIc0InterFlag"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (self.INTER_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok")
    }
    inst cInterGen :: = "0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Interleaver Write Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst FRAMELEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (FL: 40 to 20730) "
        prop Visible :: 1
        prop JSName :: "tcpIc0FrameLen"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 40 || $1 > 20730) {self.error("Frame Length range [40-20730]")} else {self.FRAMELEN_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok"})
    }
    inst RELLEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Reliability Length (R: 39 to 127)"
        prop Visible :: 1
        prop JSName :: "tcpIc0ReliaLen"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 39 || $1 > 127) {self.error("Reliability Length range [39-127]")} else {self.RELLEN_SETUP = $1, self.IC1_VALUE = self.IC1_VALUE_update(), "ok"})
    }
    inst SUBFRAMELEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Sub-Frame Length (SFL: 98 to 5114)"
        prop Visible :: 1
        prop JSName :: "tcpIc1SubFrameLen"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 98 || $1 > 5114) {self.error("Sub-Frame Length range [98-5114]")} else {self.SUBFRAMELEN_SETUP = $1, self.IC1_VALUE = self.IC1_VALUE_update(), "ok"})
    }
    inst LASTRELLEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Last Sub-Frame Reliability Length -1 (LASTR)"
        prop Visible :: 1
        prop JSName :: "tcpIc1LastReliaLen"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 0 || $1 > 127) {self.error("Last sub-frame length from 0 to 127")} else {self.LASTRELLEN_SETUP = $1, self.IC1_VALUE = self.IC1_VALUE_update(), "ok"})
    }
    inst PROLSIZE_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Prolog Size (P: 24 to 48)"
        prop Visible :: 1
        prop JSName :: "tcpIc2ProlSize"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 24 || $1 > 48) {self.error("Prolog Size range [24-48]")} else {self.PROLSIZE_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst NUMSUBBLK_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Number of Sub-blocks (NSB)"
        prop Visible :: 1
        prop JSName :: "tcpIc2NumSubBlk"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 0 || $1 > 16) {self.error("Number of sub-blocks range [0-16]")} else {self.NUMSUBBLK_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst LASTNUMSUBBLK_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Last Number of Sub-blocks (LASTNSB :SP mode only)"
        prop Visible :: 1
        prop JSName :: "tcpIc2LastNumSubBlk"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 0 || $1 > 16) {self.error("Number of sub-blocks range [0-16]")} else {self.LASTNUMSUBBLK_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst MAXIT_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Maximum of Iterations (MAXIT - SA mode only)"
        prop Visible :: 1
        prop JSName :: "tcpIc2Maxit"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Standalone(SA)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 0 || $1 > 32) {self.error("Maximum number of Iterations range [0-32]")} else {self.MAXIT_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst SNR_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " SNR Threshold (SNR - SA mode only)"
        prop Visible :: 1
        prop JSName :: "tcpIc2SnrTh"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Standalone(SA)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (if ($1 < 0 || $1 > 100) {self.error("Maximum number of Iterations range [0-100]")} else {self.SNR_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst NWORDINTER_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Interleaver words/XEVT (NWORDINTER) "
        prop Visible :: 1
        prop JSName :: "tcpIc3NwordInter"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Standalone(SA)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 65535 || $1 < 0) {self.error("Number of Interleaver Words range [0-65535]")} else {self.NWORDINTER_SETUP = $1, self.IC3_VALUE = self.IC3_VALUE_update(), "ok"})
    }
    inst NWORDSP_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Systematic and Parity words/XEVT (NWORDSP)"
        prop Visible :: 1
        prop JSName :: "tcpIc3NwordSp"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 65535 || $1 < 0) {self.error("Number of Systematic and parity Words range [0-65535]")} else {self.NWORDSP_SETUP = $1, self.IC3_VALUE = self.IC3_VALUE_update(), "ok"})
    }
    inst NWORDAP_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "  Apriori Write words/XEVT (NWORDAP) "
        prop Visible :: 1
        prop JSName :: "tcpIc4NwordAp"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 65535 || $1 < 0) {self.error("Number of Apriori Words/XEVT range [0-65535]")} else {self.NWORDAP_SETUP = $1, self.IC4_VALUE = self.IC4_VALUE_update(), "ok"})
    }
    inst NWORDEXT_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "  Extrinsic Read words/REVT (NWORDEXT) "
        prop Visible :: 1
        prop JSName :: "tcpIc4NwordExt"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 65535 || $1 < 0) {self.error("Number of Extrinsic Words range [0-65535]")} else {self.NWORDEXT_SETUP = $1, self.IC4_VALUE = self.IC4_VALUE_update(), "ok"})
    }
    inst NWORDHD_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "  Hard Decision words/REVT (NWORDHD) "
        prop Visible :: 1
        prop JSName :: "tcpIc5NwordHd"
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Standalone(SA)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 255 || $1 < 0) {self.error("Number of Hard Decision Words range [0-255]")} else {self.NWORDHD_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok"})
    }
    inst IC0_VALUE :: self.IC0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 0 (IC0)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "tcpIc0"
        prop Visible :: 1
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC0_VALUE = ($1 & 0xFFFFF70E), self.IC0_SETUP_update($1), "ok")
    }
    inst IC1_VALUE :: self.IC1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 1 (IC1)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "tcpIc1"
        prop Visible :: 1
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC1_VALUE = ($1 & 0x7F7FFFFF), self.IC1_SETUP_update($1), "ok")
    }
    inst IC2_VALUE :: self.IC2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 2 (IC2)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "tcpIc2"
        prop Visible :: 1
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC2_VALUE = ($1 & 0xFF1FF3F), self.IC2_SETUP_update($1), "ok")
    }
    inst IC3_VALUE :: self.IC3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 3 (IC3)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "tcpIc3"
        prop Visible :: 1
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC3_VALUE = $1, self.IC3_SETUP_update($1), "ok")
    }
    inst IC4_VALUE :: self.IC4_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 4 (IC4)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "tcpIc4"
        prop Visible :: 1
        prop Writable :: if (CSL.TCP_SUPPORT && self.MODE_SETUP == "Shared(SP)") {1} else {0}
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC4_VALUE = $1, self.IC4_SETUP_update($1), "ok")
    }
    inst IC5_VALUE :: self.IC5_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 5 (IC5)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "tcpIc5"
        prop Visible :: 1
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC5_VALUE = $1, self.IC5_SETUP_update($1), "ok")
    }
    inst IC6_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 6 (IC6)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
    }
    inst IC7_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 7 (IC7)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
    }
    inst IC8_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 8 (IC8)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
    }
    inst IC9_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 9 (IC9)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
    }
    inst IC10_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 10 (IC10)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
    }
    inst IC11_VALUE :: 0x00000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 11 (IC11)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
    }
}

type hTcp {
    prop IsContainedIn :: TCPFOLDER
    prop name :: "hTcp"
    prop Label :: "TCP Resource Manager"
    prop JSName :: "HTCP"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C6}"
    prop InstancePropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C5}"
    prop GlobalIcon :: 197
    prop InstanceIcon :: 198
    prop GlobalHelpTopic :: (1083)
    prop cGen :: 1
    global TCP_INITPARAM_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Parameters Setting"
        prop JSName :: "tcpEnableParams"
        prop Visible :: 1
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; tcpBaseParam) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.TCP_INITPARAM == TCP_PARAMNULL) {" You must create a new BaseParams object"} else {self.TCP_INITPARAM_ENABLE = $1, if ($1 == 0) {self.TCP_INITPARAM = TCP_PARAMNULL, self.TCP_PARAMCONFIGNAME = "NULL", self.TCP_SETPARAM_ENABLE = 0} , "ok"})
    }
    global TCP_INITPARAM :: TCP_PARAMNULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: tcpBaseParam
        prop Label :: " Pre-Initialize with"
        prop JSName :: "tcpBaseParamInit"
        prop Visible :: 1
        prop Writable :: if (CSL.TCP_SUPPORT) && (self.TCP_INITPARAM_ENABLE == 1) {1} else {0}
    }
    global TCP_PARAMCONFIGNAME :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Output TCP Params ConfigName (ex: tcpParam) "
        prop JSName :: "tcpParamConfigName"
        prop Visible :: 1
        prop Writable :: if (CSL.TCP_SUPPORT) && (self.TCP_INITPARAM_ENABLE == 1) {1} else {0}
        prop Set :: (if ($1 == "") {self.TCP_PARAMCONFIGNAME = "NULL", "ok"} else {self.TCP_PARAMCONFIGNAME = $1, "ok"})
    }
    global TCP_SETPARAM_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set TCP Params Values to the IC Config. Obj"
        prop JSName :: "tcpSetParamEnable"
        prop Visible :: 1
        prop Writable :: (CSL.TCP_SUPPORT && self.TCP_INITPARAM_ENABLE)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; tcpCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.TCP_INIT == TCP_NOTHING) {" You must create a configuration object"} else {self.TCP_SETPARAM_ENABLE = $1, if ($1 == 0 && self.TCP_INIT_ENABLE == 0) {self.TCP_INIT = TCP_NOTHING} , "ok"})
    }
    global TCP_INIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable TCP Pre-Initialization "
        prop JSName :: "tcpEnablePreInit"
        prop Visible :: 1
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; tcpCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.TCP_INIT == TCP_NOTHING) {" You must create a new configuration object"} else {self.TCP_INIT_ENABLE = $1, if ($1 == 0 && self.TCP_SETPARAM_ENABLE == 0) {self.TCP_INIT = TCP_NOTHING} , "ok"})
    }
    global TCP_INIT :: TCP_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: tcpCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "tcpPreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.TCP_SUPPORT) && ((self.TCP_INIT_ENABLE == 1) || (self.TCP_SETPARAM_ENABLE == 1)) {1} else {0}
    }
}

object TCP_NOTHING :: tcpCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param STANDARD_SETUP :: "3GPP"
    param MODE_SETUP :: "Standalone(SA)"
    param MAP_SETUP :: "MAP1(1st Iter.)"
    param RATE_SETUP :: "None"
    param OUTF_SETUP :: "Disable"
    param INTER_SETUP :: "Disable"
    param PROLSIZE_SETUP :: 0
    param NUMSUBBLK_SETUP :: 0
    param LASTNUMSUBBLK_SETUP :: 0
    param MAXIT_SETUP :: 0
    param SNR_SETUP :: 0
    param NWORDINTER_SETUP :: 0
    param NWORDSP_SETUP :: 0
    param NWORDAP_SETUP :: 0
    param NWORDEXT_SETUP :: 0
    param NWORDHD_SETUP :: 0
    param IC0_VALUE :: 0
    param IC1_VALUE :: 0
    param IC2_VALUE :: 0
    param IC3_VALUE :: 0
    param IC4_VALUE :: 0
    param IC5_VALUE :: 0
    param IC6_VALUE :: 0
    param IC7_VALUE :: 0
    param IC8_VALUE :: 0
    param IC9_VALUE :: 0
    param IC10_VALUE :: 0
    param IC11_VALUE :: 0
}

object TCP_PARAMNULL :: tcpBaseParam {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param STANDARD_SETUP :: "3GPP"
    param RATE_SETUP :: "None"
    param PROLSIZE_SETUP :: 0
    param MAXIT_SETUP :: 0
    param SNR_SETUP :: 0
    param INTER_SETUP :: "Disable"
    param OUTF_SETUP :: "Disable"
}

type TIMERFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL
    prop name :: "TIMER"
    prop Label :: "TIMER - Timer Device"
    prop NoGen :: 1
    prop GlobalHelpTopic :: (1060)
    prop GlobalPropertyPage :: "{33A68984-598D-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{33A68985-598D-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 161
    prop InstanceIcon :: 162
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type timerCfg {
    isa ObjectMgr
    prop Name :: "timerCfg"
    prop Label :: "TIMER Configuration Manager"
    prop JSName :: "TIMER"
    prop IsContainedIn :: TIMERFOLDER
    prop NoGen :: 1
    prop GlobalHelpTopic :: (1061)
    prop InstanceHelpTopic :: (1061)
    prop GlobalPropertyPage :: "{33A68982-598D-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{33A68983-598D-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 161
    prop InstanceIcon :: 162
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "TIMER_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_timer.h"} else {""}
    prop cStructQual :: "far"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; timerCfg) {$a = $a + 1}, if ($a == 2) {scan ($c; hTimer) {$c.TIMER_INIT_ENABLE = 0}} , "ok")
    prop CLKSRC_CTL :: (if (self.CLKSRC_SETUP == "(CPU clock)/4") {0x00000200} else {if (self.CLKSRC_SETUP == "(CPU clock)/8") {0x00000200} else {0x00000000}})
    prop CP_CTL :: (if (self.CP_SETUP == "Clock mode") {0x00000100} else {0x00000000})
    prop PWID_CTL :: (if (self.PWID_SETUP == "Two Clock cycles") {0x00000010} else {0x00000000})
    prop FUNC_CTL :: (if (self.FUNC_SETUP == "Timer Output") {0x00000001} else {0x00000000})
    prop DATOUT_CTL :: ((self.DATOUT_SETUP << 2))
    prop INVOUT_CTL :: (if (self.INVOUT_SETUP == "Inverted") {0x00000002} else {0x00000000})
    prop INVINP_CTL :: (if (self.INVINP_SETUP == "Inverted") {0x00000400} else {0x00000000})
    prop GO_HLD_CTL :: (if (self.GO_HLD_SETUP == "Hold") {0x00000000} else {if (self.GO_HLD_SETUP == "Restart (no-reset)") {0x00000080} else {0x000000c0}})
    prop PERIOD_PRD :: ((self.PERIOD_SETUP))
    prop COUNTER_CNT :: ((self.COUNTER_SETUP))
    prop CTL_VALUE_update :: (self.INVINP_CTL() | self.CLKSRC_CTL() | self.CP_CTL() | self.GO_HLD_CTL() | self.PWID_CTL() | self.DATOUT_CTL() | self.INVOUT_CTL() | self.FUNC_CTL())
    prop CTL_SETUP_update :: (self.INVINP_SETUP = if ($1 & 0x00000400) {"Inverted"} else {"Uninverted"}, if (CSL.C64_SUPPORT) {self.CLKSRC_SETUP = if ($1 & 0x00000200) {"(CPU clock)/8"} else {"External Source"}} else {self.CLKSRC_SETUP = if ($1 & 0x00000200) {"(CPU clock)/4"} else {"External Source"}}, self.CP_SETUP = if ($1 & 0x00000100) {"Clock mode"} else {"Pulse mode"}, self.GO_HLD_SETUP = ($a = ($1 & 0x000000c0), if ($a == 0x000000c0) {"Start with reset"} else {if ($a == 0x00000080) {"Restart (no-reset)"} else {"Hold"}}), self.PWID_SETUP = if ($1 & 0x00000010) {"Two clock cycles"} else {"One clock cycle"}, self.DATOUT_SETUP = (($1 & 0x00000004) >> 2), self.INVOUT_SETUP = if ($1 & 0x00000002) {"Inverted"} else {"Uninverted"}, self.FUNC_SETUP = if ($1 & 0x00000001) {"Timer Output"} else {"General-Purpose Output"})
    prop PRD_VALUE_update :: (self.PERIOD_PRD())
    prop PRD_SETUP_update :: (self.PERIOD_SETUP = $1)
    prop CNT_VALUE_update :: (self.COUNTER_CNT())
    prop CNT_SETUP_update :: (self.COUNTER_SETUP = $1)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst CLKSRC_SETUP :: "External Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External Source,(CPU clock)/4,(CPU clock)/8"
        prop Label :: "Input Clock Source (CLKSRC) "
        prop JSName :: "timerCtlClksrc"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Clock Control "
        prop Set :: (if (CSL.C64_SUPPORT) {if ($1 == "(CPU clock)/4") {self.error("Invalid Selection for C64x")} else {self.CLKSRC_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok"}} else {if ($1 == "(CPU clock)/8") {self.error("Invalid Selection, For C64x Only")} else {self.CLKSRC_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok"}})
    }
    inst CP_SETUP :: "Pulse mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Pulse mode,Clock mode"
        prop Label :: "Clock/Pulse Mode (CP) "
        prop JSName :: "timerCtlCp"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Clock Control "
        prop Set :: (self.CP_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok")
    }
    inst PWID_SETUP :: "One clock cycle" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "One Clock cycle,Two Clock cycles"
        prop Label :: "Pulse Width (PWID)"
        prop JSName :: "timerCtlPwid"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT && (if (self.CP_SETUP == "Pulse mode") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Clock Control "
        prop Set :: (self.PWID_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok")
    }
    inst FUNC_SETUP :: "General-Purpose Output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "General-Purpose Output,Timer Output"
        prop Label :: "Function of TOUT (FUNC)"
        prop JSName :: "timerCtlFunc"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Pin Control "
        prop Set :: (self.FUNC_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok")
    }
    inst DATOUT_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DATA output (TOUT pin)"
        prop Visible :: 1
        prop JSName :: "timerCtlDatout"
        prop Writable :: CSL.TIMER_SUPPORT && (if (self.FUNC_SETUP == "General-Purpose Output") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Pin Control "
        prop Set :: (if ($1 < 0 || $1 > 1) {self.error("Binary value required : 0 or 1")} else {self.DATOUT_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok"})
    }
    inst INVOUT_SETUP :: "Uninverted" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Uninverted,Inverted"
        prop Label :: "    TOUT Inverter Control (INVOUT)"
        prop JSName :: "timerCtlInvout"
        prop Visible :: 1
        prop Writable :: (if (self.FUNC_SETUP == "Timer Output") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Pin Control "
        prop Set :: (self.INVOUT_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok")
    }
    inst INVINP_SETUP :: "Uninverted" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Uninverted,Inverted"
        prop Label :: "    TINP Inverter Control (INVINP)"
        prop JSName :: "timerCtlInvinp"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT && (if (self.CLKSRC_SETUP == "External Source") {1} else {0})
        prop NoGen :: 1
        prop TabName :: "Pin Control "
        prop Set :: (self.INVINP_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok")
    }
    inst GO_HLD_SETUP :: "Hold" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Hold,Restart (no-reset),Start with reset"
        prop Label :: "Timer Operation"
        prop JSName :: "timerCtlGoHold"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Counter Control "
        prop Set :: (self.GO_HLD_SETUP = $1, self.CTL_VALUE = self.CTL_VALUE_update(), "ok")
    }
    inst PERIOD_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Label :: "Period Value "
        prop JSName :: "timerPrd"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Counter Control "
        prop Set :: (self.PERIOD_SETUP = $1, self.PRD_VALUE = self.PRD_VALUE_update(), "ok")
    }
    inst COUNTER_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Label :: "Counter value (optional)"
        prop JSName :: "timerCnt"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Counter Control "
        prop Set :: (self.COUNTER_SETUP = $1, self.CNT_VALUE = self.CNT_VALUE_update(), "ok")
    }
    inst CTL_VALUE :: self.CTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Control Register (CTL) "
        prop Format :: "0x%08X"
        prop JSName :: "timerCtlAdv"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x000000c0, if ($a == 0x00000040) {self.error("Fields GO='1'& HOLD='0' : Undefined Timer Operation - See Counter Control Page")} else {$b = $1 & 0xFFFFF000, if ($b != 0) {self.error("Bit field (bit[12..31]) is reserved")} else {$c = $1 & 0x00000020, if ($c != 0) {self.error("Bit field 5 is reserved")} else {self.CTL_VALUE = $1, self.CTL_SETUP_update($1), "ok"}}})
    }
    inst PRD_VALUE :: self.PRD_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Period Register (PRD) "
        prop Format :: "0x%08X"
        prop JSName :: "timerPrdAdv"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.PRD_VALUE = $1, self.PRD_SETUP_update($1), "ok")
    }
    inst CNT_VALUE :: self.CNT_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Counter Register (CNT) "
        prop Format :: "0x%08X"
        prop JSName :: "timerCntAdv"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.CNT_VALUE = $1, self.CNT_SETUP_update($1), "ok")
    }
}

type hTimer {
    isa ObjectMgr
    prop name :: "hTimer"
    prop Label :: "TIMER Resource Manager"
    prop JSName :: "HTIMER"
    prop IsContainedIn :: TIMERFOLDER
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{33A68980-598D-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{33A68981-598D-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 161
    prop InstanceIcon :: 162
    prop GlobalHelpTopic :: (1062)
    prop InstanceHelpTopic :: (1063)
    prop maxObjs :: 3
    prop localCanCreate :: (self.error("New Timer handle objects cannot be created"))
    prop localCanDelete :: (self.error("Timer handle objects cannot be deleted"))
    prop chipcall :: (scan ($i; hTimer) {if (CSL.CHIP_6400 && $i.DEVICE == "TIMER2") {$i.TIMER_HANDLE_ENABLE = 0, $i.TIMER_INIT_ENABLE = 0, $i.cOpenArg0 = "TIMER_None"} }, if (self.CHIPCHAIN != nil) {$e = self.CHIPCHAIN.chipcall()} , "ok")
    prop localInit :: (self.CHIPCHAIN = GBL.CHIPCHAIN, GBL.CHIPCHAIN = hTimer)
    prop cGen :: 1
    prop cHeaderName :: ($a = "", scan ($b; hTimer) {if ($b.TIMER_HANDLE_ENABLE == 1) {$a = "csl_timer.h"} }, $a)
    prop cStructQual :: "far"
    prop cOpenName :: "TIMER_open"
    prop cConfigName :: "TIMER_config"
    prop cHandle :: (self.cOpenGen)
    prop cHandleType :: "TIMER_Handle"
    prop cHandleName :: self.HandleName
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: hMcbsp { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst TIMER_HANDLE_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Timer Device"
        prop JSName :: "timerHandleEnable"
        prop Visible :: 1
        prop Writable :: if (CSL.TIMER_SUPPORT && ((self.DEVICE == "TIMER0" || self.DEVICE == "TIMER1"))) || (CSL.TIMER2_SUPPORT) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, if ($1 == 0) {self.TIMER_HANDLE_ENABLE = $1, self.TIMER_INIT_ENABLE = $1, self.TIMER_INIT = TIMER_NOTHING, if (self.DEVICE == "TIMER0") {HWI_INT14.client = "USER"} else {if (self.DEVICE == "TIMER1") {HWI_INT15.client = "USER"} }, self.cOpenArg0 = "TIMER_None", "ok"} else {if (self.DEVICE == "TIMER0" && (CLK.WHICHTIMER == "Timer 0" && CLK.USETIMER == 1)) {self.TIMER_HANDLE_ENABLE = 0, self.error("TIMER0 already used by the CLK module")} else {if (self.DEVICE == "TIMER1" && (CLK.WHICHTIMER == "Timer 1" && CLK.USETIMER == 1)) {self.TIMER_HANDLE_ENABLE = 0, self.error("TIMER1 already used by the CLK module")} else {if (self.DEVICE == "TIMER2" && (CLK.WHICHTIMER == "Timer 2" && CLK.USETIMER == 1)) {self.TIMER_HANDLE_ENABLE = 0, self.error("TIMER2 already used by the CLK module")} else {self.TIMER_HANDLE_ENABLE = $1, if (self.DEVICE == "TIMER0") {self.cOpenArg0 = "TIMER_DEV0", HWI_INT14.client = "CSL", "ok"} else {if (self.DEVICE == "TIMER1") {self.cOpenArg0 = "TIMER_DEV1", HWI_INT15.client = "CSL", "ok"} else {self.cOpenArg0 = "TIMER_DEV2", "ok"}}}}}})
    }
    inst HandleName :: self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Handle  "
        prop JSName :: "timerHandleName"
        prop Visible :: 1
        prop Writable :: if (self.TIMER_HANDLE_ENABLE == 1) {1} else {0}
    }
    inst DEVICE :: "TIMER0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "TIMER0,TIMER1,TIMER2"
        prop Label :: "         Device"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenGen :: = (CSL.TIMER_SUPPORT && self.TIMER_HANDLE_ENABLE == 1 && self.HandleName != "") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    inst cOpenArg0 :: (if (self.TIMER_HANDLE_ENABLE == 0) {"TIMER_None"} ) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    Arg0  "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "TIMER_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-initialize (Default) "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst TIMER_INIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "timerEnablePreInit"
        prop Visible :: 1
        prop Writable :: if CSL.TIMER_SUPPORT && (self.TIMER_HANDLE_ENABLE == 1) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; timerCfg) {$a = $a + 1}, if ($a == 1) {self.TIMER_INIT_ENABLE = 0, self.error("You must create a new configuration object")} else {self.TIMER_INIT_ENABLE = $1, if ($1 == 0) {self.TIMER_INIT = TIMER_NOTHING} , "ok"})
    }
    inst TIMER_INIT :: TIMER_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: timerCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "timerPreInit"
        prop Visible :: 1
        prop Writable :: if (self.TIMER_INIT_ENABLE == 1 && self.TIMER_HANDLE_ENABLE == 1) {1} else {0}
        prop NoGen :: 0
    }
    inst cConfigGen :: = ((self.TIMER_INIT_ENABLE == 1) && (self.TIMER_INIT != TIMER_NOTHING) && (self.TIMER_HANDLE_ENABLE == 1) && (self.HandleName != "")) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = self.cHandleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
    }
    inst cConfigArg1 :: = self.TIMER_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: timerCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
}

object Timer_Device0 :: hTimer {
    param iComment :: "Timer 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hTimer"
    param iDelMsg :: "This TIMER Handle object cannot be deleted"
    param TIMER_HANDLE_ENABLE :: 0
    param HandleName :: "hTimer0"
    param DEVICE :: "TIMER0"
    param cOpenArg0 :: "TIMER_None"
    param cOpenArg1 :: "TIMER_OPEN_RESET"
    param TIMER_INIT_ENABLE :: 0
    param TIMER_INIT :: TIMER_NOTHING
}

object Timer_Device1 :: hTimer {
    param iComment :: "Timer 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hTimer"
    param iDelMsg :: "This TIMER Handle object cannot be deleted"
    param TIMER_HANDLE_ENABLE :: 0
    param HandleName :: "hTimer1"
    param DEVICE :: "TIMER1"
    param cOpenArg0 :: "TIMER_None"
    param cOpenArg1 :: "TIMER_OPEN_RESET"
    param TIMER_INIT_ENABLE :: 0
    param TIMER_INIT :: TIMER_NOTHING
}

object Timer_Device2 :: hTimer {
    param iComment :: "Timer 2"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hTimer"
    param iDelMsg :: "This TIMER Handle object cannot be deleted"
    param TIMER_HANDLE_ENABLE :: 0
    param HandleName :: "hTimer2"
    param DEVICE :: "TIMER2"
    param cOpenArg0 :: "TIMER_None"
    param cOpenArg1 :: "TIMER_OPEN_RESET"
    param TIMER_INIT_ENABLE :: 0
    param TIMER_INIT :: TIMER_NOTHING
}

object TIMER_NOTHING :: timerCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param CLKSRC_SETUP :: "External Source"
    param CP_SETUP :: "Pulse mode"
    param PWID_SETUP :: "One clock cycle"
    param FUNC_SETUP :: "General-Purpose Output"
    param DATOUT_SETUP :: 0
    param INVOUT_SETUP :: "Uninverted"
    param INVINP_SETUP :: "Uninverted"
    param GO_HLD_SETUP :: "Hold"
    param PERIOD_SETUP :: 0
    param COUNTER_SETUP :: 0
    param CTL_VALUE :: 0
    param PRD_VALUE :: 0
    param CNT_VALUE :: 0
}

type VCPFOLDER {
    prop Label :: "Viterbi Decoder Coprocessor - VCP "
    prop GlobalIcon :: 195
    prop InstanceIcon :: 196
    prop GlobalHelpTopic :: 1090
    prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type vcpBaseParam {
    isa ObjectMgr
    prop name :: "vcpBaseParam"
    prop Label :: "VCP Parameters Manager"
    prop JSName :: "VCPBP"
    prop IsContainedIn :: VCPFOLDER
    prop GlobalIcon :: 195
    prop InstanceIcon :: 196
    prop GlobalHelpTopic :: 1091
    prop InstanceHelpTopic :: 1091
    prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C8}"
    prop InstancePropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop NoGen :: 1
    prop cGen :: CSL.VCP_SUPPORT
    prop cStruct :: CSL.VCP_SUPPORT
    prop cStructType :: "VCP_BaseParams"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_vcp.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "VCP_BaseParams"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; vcpBaseParam) {$a += 1}, if ($a == 2) {hVcp.VCP_INITPARAM_ENABLE = 0} , "ok")
    prop ParamConfigType :: if (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") {"VCP_Params "} else {""}
    prop ParamConfigName :: if (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") {hVcp.VCP_PARAMCONFIGNAME} else {""}
    prop ParamEnd :: if (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") {";\n"} else {""}
    prop cGenCEpilogue :: ("%1S%2S%3S\n\0,ParamConfigType,ParamConfigName,ParamEnd")
    prop GenParamStr :: if (hVcp.VCP_INITPARAM_ENABLE == 1) {"VCP_genParams(&%3s, &"} else {""}
    prop ParamConfigObj :: if (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") {hVcp.VCP_PARAMCONFIGNAME} else {""}
    prop ConfigEnd :: if (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") {");"} else {""}
    prop cGenFxnPreInst :: ("   %1S%2S%4S\n\0,GenParamStr,ParamConfigObj,cStructName,ConfigEnd")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst RATE_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate "
        prop Visible :: 1
        prop JSName :: "vcpBaseParamRate"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Base Params"
        prop Set :: (if ($1 == "1/2") {self.cRateGen = "VCP_RATE_1_2"} else {if ($1 == "1/3") {self.cRateGen = "VCP_RATE_1_3"} else {if ($1 == "1/4") {self.cRateGen = "VCP_RATE_1_4"} else {self.cRateGen = " 0"}}}, self.RATE_SETUP = $1, " For Information only, Not programmable directly - calculated via POLYx")
    }
    inst cRateGen :: = " 0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Rate"
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst CONSTRLEN_SETUP :: 5 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Constraint Length (K= 5,6,7,8 or 9)"
        prop Visible :: 1
        prop JSName :: "vcpBaseParamConstrLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (if ($1 < 5 || $1 > 9) {self.error(" Constraint Length K=5,6,7,8 or 9")} else {self.CONSTRLEN_SETUP = $1, " For Information only, Not programmable directly - calculated via POLYx"})
    }
    inst FRAMELEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (FL) "
        prop Visible :: 1
        prop JSName :: "vcpBaseParamFrameLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (if ($1 < 0 || $1 > 65535) {self.error("Frame Length range [0-65535]")} else {self.FRAMELEN_SETUP = $1, "ok"})
    }
    inst YAMTH_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Yamamoto Threshold (YAMT)"
        prop Visible :: 1
        prop JSName :: "vcpBaseParamYamth"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (if ($1 < 0 || $1 > 4095) {self.error("Yamamoto Threshold max value is 4095")} else {self.YAMTH_SETUP = $1, "ok"})
    }
    inst IMAXI_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " State Index set to IMAXS (IMAXI)"
        prop Visible :: 1
        prop JSName :: "vcpBaseParamIndexMaxIter"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (if ((self.CONSTRLEN_SETUP == 5 && $1 > 15)) {self.error("For K=5 ,allowed values are 0 to 15")} else {if ((self.CONSTRLEN_SETUP == 6 && $1 > 31)) {self.error("For K=6 ,allowed values are 0 to 31")} else {if ((self.CONSTRLEN_SETUP == 7 && $1 > 63)) {self.error("For K=7 ,allowed values are 0 to 63")} else {if ((self.CONSTRLEN_SETUP == 8 && $1 > 127)) {self.error("For K=8 ,allowed values are 0 to 127")} else {if ((self.CONSTRLEN_SETUP == 9 && $1 > 255)) {self.error("For K=9 ,allowed values are 0 to 255")} else {self.IMAXI_SETUP = $1, "ok"}}}}})
    }
    inst SDHD_SETUP :: "Hard" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Hard,Soft"
        prop Label :: " Ouput Hard Decision Type (SDHD) "
        prop Visible :: 1
        prop JSName :: "vcpBaseParamDecisionType"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Base Params"
        prop Set :: (if ($1 == "Soft") {self.cSdhdGen = " 1"} else {self.cSdhdGen = " 0"}, self.SDHD_SETUP = $1, "ok")
    }
    inst cSdhdGen :: = " 0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Ouput Hard Decision Type "
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst OUTF_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Ouput Parameters Read Flag (OUTF)"
        prop Visible :: 1
        prop JSName :: "vcpBaseParamOutFlag"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Base Params"
        prop Set :: (if ($1 == "Enable") {self.cOutfGen = " 1"} else {self.cOutfGen = " 0"}, self.OUTF_SETUP = $1, "ok")
    }
    inst cOutfGen :: = " 0" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Ouput Parameters Read Flag "
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
    }
}

type vcpCfg {
    isa ObjectMgr
    prop name :: "vcpCfg"
    prop Label :: "VCP Configuration Manager"
    prop JSName :: "VCP"
    prop IsContainedIn :: VCPFOLDER
    prop GlobalIcon :: 195
    prop InstanceIcon :: 196
    prop GlobalHelpTopic :: 1092
    prop InstanceHelpTopic :: 1092
    prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C8}"
    prop InstancePropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop NoGen :: 1
    prop cGen :: CSL.VCP_SUPPORT
    prop cStruct :: CSL.VCP_SUPPORT
    prop cStructType :: "VCP_ConfigIc"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_vcp.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "VCP_icConfig"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; vcpCfg) {$a += 1}, if ($a == 2) {hVcp.VCP_INIT_ENABLE = 0} , "ok")
    prop SetParamStr :: if (hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING) {"VCP_genIc(&"} else {""}
    prop ParamConfigObj :: if (hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING && hVcp.VCP_PARAMCONFIGNAME != "NULL") {hVcp.VCP_PARAMCONFIGNAME} else {""}
    prop IcConfigObj :: if (hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING && hVcp.VCP_PARAMCONFIGNAME != "NULL") {",&%4s"} else {""}
    prop ConfigEnd :: if (hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING && hVcp.VCP_PARAMCONFIGNAME != "NULL") {");"} else {""}
    prop cGenFxnPreInst :: ("   %1S%2S%3S%5S\n\0,SetParamStr,ParamConfigObj,IcConfigObj,cStructName,ConfigEnd")
    prop POLYG0_IC0 :: (self.POLYG0_SETUP)
    prop POLYG1_IC0 :: (self.POLYG1_SETUP << 8)
    prop POLYG2_IC0 :: (self.POLYG2_SETUP << 16)
    prop POLYG3_IC0 :: (self.POLYG3_SETUP << 24)
    prop FRAMELEN_IC2 :: (self.FRAMELEN_SETUP)
    prop RELLEN_IC2 :: (self.RELLEN_SETUP << 16)
    prop CVGLEN_IC3 :: (self.CVGLEN_SETUP)
    prop TRACEBACK_IC5 :: (if (self.TRACEBACK_SETUP == "not allowed") {0} else {if (self.TRACEBACK_SETUP == "tailed") {0x01000000} else {if (self.TRACEBACK_SETUP == "convergent") {0x02000000} else {0x03000000}}})
    prop YAMEN_IC1 :: (if (self.YAMEN_SETUP == "Disable") {0x00000000} else {0x10000000})
    prop YAMTH_IC1 :: (self.YAMTH_SETUP << 16)
    prop IMAXS_IC4 :: (self.IMAXS_SETUP)
    prop IMINS_IC4 :: (self.IMINS_SETUP << 16)
    prop IMAXI_IC5 :: (self.IMAXI_SETUP)
    prop SDHD_IC5 :: (if (self.SDHD_SETUP == "Hard") {0x00000000} else {0x80000000})
    prop SYMX_IC5 :: (((self.SYMX_SETUP - 1) << 16))
    prop SYMR_IC5 :: (((self.SYMR_SETUP - 1) << 20))
    prop OUTF_IC5 :: (if (self.OUTF_SETUP == "Disable") {0} else {0x40000000})
    prop IC0_VALUE_update :: (self.POLYG0_IC0() | self.POLYG1_IC0() | self.POLYG2_IC0() | self.POLYG3_IC0())
    prop IC0_SETUP_update :: (self.POLYG0_SETUP = ($1 & 0x000000FF), self.POLYG1_SETUP = ($1 & 0x0000FF00) >> 8, self.POLYG2_SETUP = ($1 & 0x00FF0000) >> 16, self.POLYG3_SETUP = ($1 & 0xFF000000) >> 24)
    prop IC1_VALUE_update :: (self.YAMTH_IC1() | self.YAMEN_IC1())
    prop IC1_SETUP_update :: (self.YAMTH_SETUP = ($1 & 0x0FFF0000), self.YAMEN_SETUP = ($a = ($1 & 0x10000000), if ($a == 0x10000000) {"Enable"} else {"Disable"}))
    prop IC2_VALUE_update :: (self.FRAMELEN_IC2() | self.RELLEN_IC2())
    prop IC2_SETUP_update :: (self.FRAMELEN_SETUP = ($1 & 0x0000FFFF), self.RELLEN_SETUP = ($1 & 0xFFFF0000) >> 16)
    prop IC3_VALUE_update :: (self.CVGLEN_IC3())
    prop IC3_SETUP_update :: (self.CVGLEN_SETUP = ($1 & 0x0000FFFF))
    prop IC4_VALUE_update :: (self.IMAXS_IC4() | self.IMINS_IC4())
    prop IC4_SETUP_update :: (self.IMAXS_SETUP = ($1 & 0x00000FFF), self.IMINS_SETUP = ($1 & 0x0FFF0000) >> 16)
    prop IC5_VALUE_update :: (self.IMAXI_IC5() | self.SYMX_IC5() | self.SYMR_IC5() | self.TRACEBACK_IC5() | self.OUTF_IC5() | self.SDHD_IC5())
    prop IC5_SETUP_update :: (self.IMAXI_SETUP = ($1 & 0x000000FF), self.SYMX_SETUP = (($1 & 0x000F0000) >> 16) + 1, self.SYMR_SETUP = (($1 & 0x00F00000) >> 20) + 1, self.TRACEBACK_SETUP = ($a = ($1 & 0x03000000), if ($a == 0x00000000) {"not allowed"} else {if ($a == 0x010000000) {"tailed"} else {if ($a == 0x020000000) {"convergent"} else {"mixed"}}}), self.OUTF_SETUP = ($a = ($1 & 0x40000000), if ($a == 0x400000000) {"Enable"} else {"Disable"}), self.SDHD_SETUP = ($a = ($1 & 0x80000000), if ($a == 0x800000000) {"Soft"} else {"Hard"}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((hVcp.VCP_INIT_ENABLE == 1) && (hVcp.VCP_INIT == self) && (hVcp.VCP_INIT != VCP_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hVcp.VCP_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: vcpCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst STANDARD_SETUP :: "3GPP" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3GPP,IS2000"
        prop Label :: "Viterbi Decoder Standard"
        prop Visible :: 1
        prop JSName :: "vcpDecoderStandard"
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Setting"
        prop Set :: (if ($1 == "IS2000") {self.cStandardGen = "VCP_STANDARD_IS2000"} else {self.cStandardGen = "VCP_STANDARD_3GPP"}, self.STANDARD_SETUP = $1, " For Information only, Not programmable")
    }
    inst cStandardGen :: = "VCP_STANDARD_3GPP" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Standard"
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst RATE_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate "
        prop Visible :: 1
        prop JSName :: "vcpRate"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Setting"
        prop Set :: (self.RATE_SETUP = $1, " For Information only, Not programmable directly - calculated via POLYx")
    }
    inst CONSTRLEN_SETUP :: 5 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Constraint Length (K= 5,6,7,8 or 9)"
        prop Visible :: 1
        prop JSName :: "vcpConstrLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Setting"
        prop Set :: (if ($1 < 5 || $1 > 9) {self.error(" Constraint Length K=5,6,7,8 or 9")} else {self.CONSTRLEN_SETUP = $1, " For Information only, Not programmable directly - calculated via POLYx"})
    }
    inst POLYG0_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G0 (POLY0) "
        prop Visible :: 1
        prop JSName :: "vcpIc0Poly0"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 255) {self.error(" G0 values allowed are [0-255]")} else {self.POLYG0_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok"})
    }
    inst POLYG1_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G1 (POLY1) "
        prop Visible :: 1
        prop JSName :: "vcpIc0Poly1"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 255) {self.error(" G1 values allowed are [0-255]")} else {self.POLYG1_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok"})
    }
    inst POLYG2_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G2 (POLY2) "
        prop Visible :: 1
        prop JSName :: "vcpIc0Poly2"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 255) {self.error(" G2 values allowed are [0-255]")} else {self.POLYG2_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok"})
    }
    inst POLYG3_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G3 (POLY3) "
        prop Visible :: 1
        prop JSName :: "vcpIc0Poly3"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 255) {self.error(" G3 values allowed are [0-255]")} else {self.POLYG3_SETUP = $1, self.IC0_VALUE = self.IC0_VALUE_update(), "ok"})
    }
    inst FRAMELEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (F) "
        prop Visible :: 1
        prop JSName :: "vcpIc2FrameLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 65535) {self.error("Frame Length range [0-65535]")} else {self.FRAMELEN_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst RELLEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Reliability Length (R)"
        prop Visible :: 1
        prop JSName :: "vcpIc2ReliaLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 127) {self.error("Reliability Length range [0-127]")} else {self.RELLEN_SETUP = $1, self.IC2_VALUE = self.IC2_VALUE_update(), "ok"})
    }
    inst CVGLEN_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Convergence Length (C) "
        prop Visible :: 1
        prop JSName :: "vcpIc3ConvLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 65535) {self.error("Convergence Length range [0-65535]")} else {self.CVGLEN_SETUP = $1, self.IC3_VALUE = self.IC3_VALUE_update(), "ok"})
    }
    inst TRACEBACK_SETUP :: = "not Allowed" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "not allowed,tailed,convergent,mixed"
        prop Label :: " TraceBack Mode (TB)"
        prop Visible :: 1
        prop JSName :: "vcpIc5TraceBack"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (self.TRACEBACK_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok")
    }
    inst YAMEN_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Yamamoto Algo. Enable (YAMEN) "
        prop Visible :: 1
        prop JSName :: "vcpIc1Yamen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (self.YAMEN_SETUP = $1, self.IC1_VALUE = self.IC1_VALUE_update(), "ok")
    }
    inst YAMTH_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Yamamoto Threshold (YAMT)"
        prop Visible :: 1
        prop JSName :: "vcpIc1Yamth"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 4095) {self.error("Yamamoto Threshold max value is 4095")} else {self.YAMTH_SETUP = $1, self.IC1_VALUE = self.IC1_VALUE_update(), "ok"})
    }
    inst IMAXS_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Max Initial State Metric (IMAXS)"
        prop Visible :: 1
        prop JSName :: "vcpIc2Imaxs"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 4095) {self.error("Max Initial State Metric value is 4095")} else {self.IMAXS_SETUP = $1, self.IC4_VALUE = self.IC4_VALUE_update(), "ok"})
    }
    inst IMINS_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Min Initial State Metric (IMINS)"
        prop Visible :: 1
        prop JSName :: "vcpIc2Imins"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ($1 < 0 || $1 > 4095) {self.error("Min Initial State Metric value is 4095")} else {self.IMINS_SETUP = $1, self.IC4_VALUE = self.IC4_VALUE_update(), "ok"})
    }
    inst IMAXI_SETUP :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " State Index set to IMAXS (IMAXI)"
        prop Visible :: 1
        prop JSName :: "vcpIc5IndexMaxIter"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (if ((self.CONSTRLEN_SETUP == 5 && $1 > 15)) {self.error("For K=5 ,allowed values are 0 to 15")} else {if ((self.CONSTRLEN_SETUP == 6 && $1 > 31)) {self.error("For K=6 ,allowed values are 0 to 31")} else {if ((self.CONSTRLEN_SETUP == 7 && $1 > 63)) {self.error("For K=7 ,allowed values are 0 to 63")} else {if ((self.CONSTRLEN_SETUP == 8 && $1 > 127)) {self.error("For K=8 ,allowed values are 0 to 127")} else {if ((self.CONSTRLEN_SETUP == 9 && $1 > 255)) {self.error("For K=9 ,allowed values are 0 to 255")} else {self.IMAXI_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok"}}}}})
    }
    inst SDHD_SETUP :: "Hard" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Hard,Soft"
        prop Label :: " Ouput Hard Decision Type (SDHD) "
        prop Visible :: 1
        prop JSName :: "vcpIc5DecisionType"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (self.SDHD_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok")
    }
    inst SYMX_SETUP :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Branch Metrics Buffer Length (SYMX + 1) "
        prop Visible :: 1
        prop JSName :: "vcpIc5BmBuffLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 16 || $1 < 1) {self.error("Buffer length range [1-16]")} else {self.SYMX_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok"})
    }
    inst SYMR_SETUP :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Decision Buffer Length (SYMR + 1) "
        prop Visible :: 1
        prop JSName :: "vcpIc5DecBuffLen"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (if ($1 > 16 || $1 < 1) {self.error("Buffer length range [1-16]")} else {self.SYMR_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok"})
    }
    inst OUTF_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Ouput Parameters Read Flag (OUTF)"
        prop Visible :: 1
        prop JSName :: "vcpIc5OutFlag"
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (self.OUTF_SETUP = $1, self.IC5_VALUE = self.IC5_VALUE_update(), "ok")
    }
    inst IC0_VALUE :: self.IC0_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 0 (IC0)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "vcpIc0"
        prop Visible :: 1
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC0_VALUE = $1, self.IC0_SETUP_update($1), "ok")
    }
    inst IC1_VALUE :: self.IC1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 1 (IC1)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "vcpIc1"
        prop Visible :: 1
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC1_VALUE = ($1 & 0x1FFF0000), self.IC1_SETUP_update($1), "ok")
    }
    inst IC2_VALUE :: self.IC2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 2 (IC2)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "vcpIc2"
        prop Visible :: 1
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC2_VALUE = $1, self.IC2_SETUP_update($1), "ok")
    }
    inst IC3_VALUE :: self.IC3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 3 (IC3)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "vcpIc3"
        prop Visible :: 1
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC3_VALUE = ($1 & 0x0000FFFF), self.IC3_SETUP_update($1), "ok")
    }
    inst IC4_VALUE :: self.IC4_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 4 (IC4)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "vcpIc4"
        prop Visible :: 1
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC4_VALUE = ($1 & 0x0FFF0FFF), self.IC4_SETUP_update($1), "ok")
    }
    inst IC5_VALUE :: self.IC5_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Input Configuration Reg 5 (IC5)"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop JSName :: "vcpIc5"
        prop Visible :: 1
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.IC5_VALUE = ($1 & 0xC3FF00FF), self.IC5_SETUP_update($1), "ok")
    }
}

type hVcp {
    prop IsContainedIn :: VCPFOLDER
    prop name :: "hVcp"
    prop Label :: "VCP Resource Manager"
    prop JSName :: "HVCP"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C6}"
    prop InstancePropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C5}"
    prop GlobalIcon :: 195
    prop InstanceIcon :: 196
    prop GlobalHelpTopic :: (1093)
    prop cGen :: 1
    global VCP_INITPARAM_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Parameters Setting"
        prop JSName :: "vcpEnableParams"
        prop Visible :: 1
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; vcpBaseParam) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.VCP_INITPARAM == VCP_PARAMNULL) {" You must create a new BaseParams object"} else {self.VCP_INITPARAM_ENABLE = $1, if ($1 == 0) {self.VCP_INITPARAM = VCP_PARAMNULL, self.VCP_PARAMCONFIGNAME = "NULL", self.VCP_SETPARAM_ENABLE = 0} , "ok"})
    }
    global VCP_INITPARAM :: VCP_PARAMNULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: vcpBaseParam
        prop Label :: " Pre-Initialize with"
        prop JSName :: "vcpBaseParamInit"
        prop Visible :: 1
        prop Writable :: if (CSL.VCP_SUPPORT) && (self.VCP_INITPARAM_ENABLE == 1) {1} else {0}
    }
    global VCP_PARAMCONFIGNAME :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Output VCP Params ConfigName (ex: vcpParam)"
        prop JSName :: "vcpParamConfigName"
        prop Visible :: 1
        prop Writable :: if (CSL.VCP_SUPPORT) && (self.VCP_INITPARAM_ENABLE == 1) {1} else {0}
        prop Set :: (if ($1 == "") {self.VCP_PARAMCONFIGNAME = "NULL", "ok"} else {self.VCP_PARAMCONFIGNAME = $1, "ok"})
    }
    global VCP_SETPARAM_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set VCP Params Values to the IC Config. Obj"
        prop JSName :: "vcpSetParamEnable"
        prop Visible :: 1
        prop Writable :: (CSL.VCP_SUPPORT && self.VCP_INITPARAM_ENABLE)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; vcpCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.VCP_INIT == VCP_NOTHING) {" You must create a configuration object"} else {self.VCP_SETPARAM_ENABLE = $1, if ($1 == 0 && self.VCP_INIT_ENABLE == 0) {self.VCP_INIT = VCP_NOTHING} , "ok"})
    }
    global VCP_INIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "vcpEnablePreInit"
        prop Visible :: 1
        prop Writable :: (CSL.VCP_SUPPORT)
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; vcpCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.VCP_INIT == VCP_NOTHING) {" You must create a new configuration object"} else {self.VCP_INIT_ENABLE = $1, if ($1 == 0 && self.VCP_SETPARAM_ENABLE == 0) {self.VCP_INIT = VCP_NOTHING} , "ok"})
    }
    global VCP_INIT :: VCP_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: vcpCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "vcpPreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.VCP_SUPPORT) && ((self.VCP_INIT_ENABLE == 1) || (self.VCP_SETPARAM_ENABLE == 1)) {1} else {0}
    }
}

object VCP_NOTHING :: vcpCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param STANDARD_SETUP :: "3GPP"
    param RATE_SETUP :: "None"
    param CONSTRLEN_SETUP :: 5
    param YAMEN_SETUP :: "Disable"
    param SDHD_SETUP :: "Hard"
    param SYMX_SETUP :: 1
    param SYMR_SETUP :: 1
    param OUTF_SETUP :: "Disable"
    param IC0_VALUE :: 0
    param IC1_VALUE :: 0
    param IC2_VALUE :: 0
    param IC3_VALUE :: 0
    param IC4_VALUE :: 0
    param IC5_VALUE :: 50331648
}

object VCP_PARAMNULL :: vcpBaseParam {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param RATE_SETUP :: "None"
    param CONSTRLEN_SETUP :: 5
    param SDHD_SETUP :: "Hard"
    param OUTF_SETUP :: "Disable"
}

type XBUSFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL
    prop name :: "XBUS"
    prop Label :: "XBUS - Expansion Bus"
    prop NoGen :: 1
    prop GlobalPropertyPage :: "{980E6524-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6525-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: 1070
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type xbusCfg {
    isa ObjectMgr
    prop Name :: "xbusCfg"
    prop Label :: "XBUS Configuration Manager"
    prop JSName :: "XBUS"
    prop IsContainedIn :: XBUSFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6522-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6523-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: 1071
    prop InstanceHelpTopic :: 1071
    prop cGen :: CSL.XBUS_SUPPORT
    prop cStruct :: CSL.XBUS_SUPPORT
    prop cStructType :: "XBUS_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_xbus.h"} else {""}
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "XBUS_config"
    prop localDelete :: (self.myDelete)
    prop myDelete :: ($a = 0, scan ($b; xbusCfg) {$a = $a + 1}, if ($a == 2) {hXbus.XBUS_INIT_ENABLE = 0} , "ok")
    prop XFCEN_GBLCTL :: (if (self.XFCEN_SETUP == "XFCLK Enable") {0x00004000} else {0x00000000})
    prop XFRAT_GBLCTL :: (if (self.XFRAT_SETUP == "1/8 CPU Clock Rate") {0x00000000} else {if (self.XFRAT_SETUP == "1/6 CPU Clock Rate") {0x00001000} else {if (self.XFRAT_SETUP == "1/4 CPU Clock Rate") {0x00002000} else {if (self.XFRAT_SETUP == "1/2 CPU Clock Rate") {0x00003000} }}})
    prop WRSETUP0_XCE0CTL :: ((self.WRSETUP0_SETUP << 28))
    prop WRSTRB0_XCE0CTL :: ((self.WRSTRB0_SETUP << 22))
    prop WRHLD0_XCE0CTL :: ((self.WRHLD0_SETUP << 20))
    prop RDSETUP0_XCE0CTL :: ((self.RDSETUP0_SETUP << 16))
    prop RDSTRB0_XCE0CTL :: ((self.RDSTRB0_SETUP << 8))
    prop RDHLD0_XCE0CTL :: (self.RDHLD0_SETUP)
    prop MTYPE0_XCE0CTL :: (if (self.MTYPE0_SETUP == "32-bit async.") {0x00000020} else {if (self.MTYPE0_SETUP == "32-bit FIFO") {0x00000050} })
    prop WRSETUP1_XCE1CTL :: ((self.WRSETUP1_SETUP << 28))
    prop WRSTRB1_XCE1CTL :: ((self.WRSTRB1_SETUP << 22))
    prop WRHLD1_XCE1CTL :: ((self.WRHLD1_SETUP << 20))
    prop RDSETUP1_XCE1CTL :: ((self.RDSETUP1_SETUP << 16))
    prop RDSTRB1_XCE1CTL :: ((self.RDSTRB1_SETUP << 8))
    prop RDHLD1_XCE1CTL :: (self.RDHLD1_SETUP)
    prop MTYPE1_XCE1CTL :: (if (self.MTYPE1_SETUP == "32-bit async.") {0x00000020} else {if (self.MTYPE1_SETUP == "32-bit FIFO") {0x00000050} })
    prop WRSETUP2_XCE2CTL :: ((self.WRSETUP2_SETUP << 28))
    prop WRSTRB2_XCE2CTL :: ((self.WRSTRB2_SETUP << 22))
    prop WRHLD2_XCE2CTL :: ((self.WRHLD2_SETUP << 20))
    prop RDSETUP2_XCE2CTL :: ((self.RDSETUP2_SETUP << 16))
    prop RDSTRB2_XCE2CTL :: ((self.RDSTRB2_SETUP << 8))
    prop RDHLD2_XCE2CTL :: (self.RDHLD2_SETUP)
    prop MTYPE2_XCE2CTL :: (if (self.MTYPE2_SETUP == "32-bit async.") {0x00000020} else {if (self.MTYPE2_SETUP == "32-bit FIFO") {0x00000050} })
    prop WRSETUP3_XCE3CTL :: ((self.WRSETUP3_SETUP << 28))
    prop WRSTRB3_XCE3CTL :: ((self.WRSTRB3_SETUP << 22))
    prop WRHLD3_XCE3CTL :: ((self.WRHLD3_SETUP << 20))
    prop RDSETUP3_XCE3CTL :: ((self.RDSETUP3_SETUP << 16))
    prop RDSTRB3_XCE3CTL :: ((self.RDSTRB3_SETUP << 8))
    prop RDHLD3_XCE3CTL :: (self.RDHLD3_SETUP)
    prop MTYPE3_XCE3CTL :: (if (self.MTYPE3_SETUP == "32-bit async.") {0x00000020} else {if (self.MTYPE3_SETUP == "32-bit FIFO") {0x00000050} })
    prop XFRCT_XBHC :: ((self.XFRCT_SETUP << 16))
    prop INTSRC_XBHC :: (if (self.INTSRC_SETUP == "DSPINT") {0x00000000} else {if (self.INTSRC_SETUP == "XFRCT Counter") {0x00000020} })
    prop START_XBHC :: (if (self.START_SETUP == "Abort Transfer") {0x00000000} else {if (self.START_SETUP == "Write: XBIMA-->XBEA") {0x00000008} else {if (self.START_SETUP == "Read: XBEA-->XBIMA") {0x00000010} }})
    prop DSPINT_XBHC :: (if (self.DSPINT_SETUP == "None") {0x00000000} else {if (self.DSPINT_SETUP == "Clear") {0x00000002} })
    prop XBIMA_XBIMA :: (self.XBIMA_SETUP)
    prop XBEA_XBEA :: (self.XBEA_SETUP)
    prop GBLCTL_VALUE_update :: (self.XFCEN_GBLCTL() | self.XFRAT_GBLCTL())
    prop GBLCTL_SETUP_update :: (self.XFCEN_SETUP = if ($1 & 0x00004000) {"XFCLK Enable"} else {"XFCLK High"}, self.XFRAT_SETUP = ($a = ($1 & 0x00003000), if ($a == 0x00003000) {"1/2 CPU Clock Rate"} else {if ($a == 0x00002000) {"1/4 CPU Clock Rate"} else {if ($a == 0x00001000) {"1/6 CPU Clock Rate"} else {"1/8 CPU Clock Rate"}}}))
    prop XCE0CTL_VALUE_update :: (self.MTYPE0_XCE0CTL() | self.RDHLD0_XCE0CTL() | self.RDSTRB0_XCE0CTL() | self.RDSETUP0_XCE0CTL() | self.WRHLD0_XCE0CTL() | self.WRSTRB0_XCE0CTL() | self.WRSETUP0_XCE0CTL())
    prop XCE0CTL_SETUP_update :: (self.MTYPE0_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000050) {"32-bit FIFO"} else {"32-bit async."}), self.RDHLD0_SETUP = ($1 & 0x00000003), self.RDSTRB0_SETUP = ($1 & 0x00003F00) >> 8, self.RDSETUP0_SETUP = ($1 & 0x000F0000) >> 16, self.WRHLD0_SETUP = ($1 & 0x00300000) >> 20, self.WRSTRB0_SETUP = ($1 & 0x0FC00000) >> 22, self.WRSETUP0_SETUP = (($1 & 0xF0000000) >> 28) & 0xF)
    prop XCE1CTL_VALUE_update :: (self.MTYPE1_XCE1CTL() | self.RDHLD1_XCE1CTL() | self.RDSTRB1_XCE1CTL() | self.RDSETUP1_XCE1CTL() | self.WRHLD1_XCE1CTL() | self.WRSTRB1_XCE1CTL() | self.WRSETUP1_XCE1CTL())
    prop XCE1CTL_SETUP_update :: (self.MTYPE1_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000050) {"32-bit FIFO"} else {"32-bit async."}), self.RDHLD1_SETUP = ($1 & 0x00000003), self.RDSTRB1_SETUP = ($1 & 0x00003F00) >> 8, self.RDSETUP1_SETUP = ($1 & 0x000F0000) >> 16, self.WRHLD1_SETUP = ($1 & 0x00300000) >> 20, self.WRSTRB1_SETUP = ($1 & 0x0FC00000) >> 22, self.WRSETUP1_SETUP = (($1 & 0xF0000000) >> 28) & 0xF)
    prop XCE2CTL_VALUE_update :: (self.MTYPE2_XCE2CTL() | self.RDHLD2_XCE2CTL() | self.RDSTRB2_XCE2CTL() | self.RDSETUP2_XCE2CTL() | self.WRHLD2_XCE2CTL() | self.WRSTRB2_XCE2CTL() | self.WRSETUP2_XCE2CTL())
    prop XCE2CTL_SETUP_update :: (self.MTYPE2_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000050) {"32-bit FIFO"} else {"32-bit async."}), self.RDHLD2_SETUP = ($1 & 0x00000003), self.RDSTRB2_SETUP = ($1 & 0x00003F00) >> 8, self.RDSETUP2_SETUP = ($1 & 0x000F0000) >> 16, self.WRHLD2_SETUP = ($1 & 0x00300000) >> 20, self.WRSTRB2_SETUP = ($1 & 0x0FC00000) >> 22, self.WRSETUP2_SETUP = (($1 & 0xF0000000) >> 28) & 0xF)
    prop XCE3CTL_VALUE_update :: (self.MTYPE3_XCE3CTL() | self.RDHLD3_XCE3CTL() | self.RDSTRB3_XCE3CTL() | self.RDSETUP3_XCE3CTL() | self.WRHLD3_XCE3CTL() | self.WRSTRB3_XCE3CTL() | self.WRSETUP3_XCE3CTL())
    prop XCE3CTL_SETUP_update :: (self.MTYPE3_SETUP = ($a = ($1 & 0x00000070), if ($a == 0x00000050) {"32-bit FIFO"} else {"32-bit async."}), self.RDHLD3_SETUP = ($1 & 0x00000003), self.RDSTRB3_SETUP = ($1 & 0x00003F00) >> 8, self.RDSETUP3_SETUP = ($1 & 0x000F0000) >> 16, self.WRHLD3_SETUP = ($1 & 0x00300000) >> 20, self.WRSTRB3_SETUP = ($1 & 0x0FC00000) >> 22, self.WRSETUP3_SETUP = (($1 & 0xF0000000) >> 28) & 0xF)
    prop XBHC_VALUE_update :: (self.XFRCT_XBHC() | self.INTSRC_XBHC() | self.START_XBHC() | self.DSPINT_XBHC())
    prop XBHC_SETUP_update :: (self.XFRCT_SETUP = (($1 & 0xFFFF0000) >> 16) & 0xFFFF, self.INTSRC_SETUP = if ($1 & 0x00000020) {"XFRCT Counter"} else {"DSPINT"}, self.START_SETUP = ($a = ($1 & 0x00000018), if ($a == 0x00000010) {"Read: XBEA-->XBIMA"} else {if ($a == 0x00000008) {"Write: XBIMA-->XBEA"} else {"Abort Trnasfer"}}), self.DSPINT_SETUP = if ($1 & 0x00000002) {"Clear"} else {"None"})
    prop XBIMA_VALUE_update :: (self.XBIMA_XBIMA())
    prop XBIMA_SETUP_update :: (self.XBIMA_SETUP = $1 & 0xFFFFFFFF)
    prop XBEA_VALUE_update :: (self.XBEA_XBEA())
    prop XBEA_SETUP_update :: (self.XBEA_SETUP = $1 & 0xFFFFFFFF)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cConfigGen :: = ((CSL.XBUS_SUPPORT == 1) && (hXbus.XBUS_INIT_ENABLE == 1) && (hXbus.XBUS_INIT == self) && (hXbus.XBUS_INIT != XBUS_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: = hXbus.XBUS_INIT { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop MemberType :: xbusCfg
        prop Label :: "Pre-initialize Config"
        prop Visible :: 0
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
    inst XFCEN_SETUP :: "XFCLK High" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "XFCLK High,XFCLK Enable"
        prop Label :: "FIFO Clock Enable(XFCEN)"
        prop JSName :: "xbusXbgcXfcen"
        prop Visible :: 1
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.XFCEN_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst XFRAT_SETUP :: "1/8 CPU Clock Rate" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1/8 CPU Clock Rate,1/6 CPU Clock Rate,1/4 CPU Clock Rate,1/2 CPU Clock Rate"
        prop Label :: "FIFO Clock Rate(XFRAT)"
        prop JSName :: "xbusXbgcXfrat"
        prop Visible :: 1
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (self.XFRAT_SETUP = $1, self.GBLCTL_VALUE = self.GBLCTL_VALUE_update(), "ok")
    }
    inst WRSETUP0_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce0ctlWrsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok"})
    }
    inst WRSTRB0_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce0ctlWrstrb0"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok"})
    }
    inst WRHLD0_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce0ctlWrhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok"})
    }
    inst RDSETUP0_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce0ctlRdsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok"})
    }
    inst RDSTRB0_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce0ctlRdstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok"})
    }
    inst RDHLD0_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce0ctlRdhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok"})
    }
    inst MTYPE0_SETUP :: "32-bit async." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
        prop JSName :: "xbusXce0ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
        prop Set :: (self.MTYPE0_SETUP = $1, self.XCE0CTL_VALUE = self.XCE0CTL_VALUE_update(), "ok")
    }
    inst WRSETUP1_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce1ctlWrsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok"})
    }
    inst WRSTRB1_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce1ctlWrstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok"})
    }
    inst WRHLD1_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce1ctlWrhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok"})
    }
    inst RDSETUP1_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce1ctlRdsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok"})
    }
    inst RDSTRB1_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce1ctlRdstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok"})
    }
    inst RDHLD1_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce1ctlRdhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok"})
    }
    inst MTYPE1_SETUP :: "32-bit async." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
        prop JSName :: "xbusXce1ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
        prop Set :: (self.MTYPE1_SETUP = $1, self.XCE1CTL_VALUE = self.XCE1CTL_VALUE_update(), "ok")
    }
    inst WRSETUP2_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce2ctlWrsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok"})
    }
    inst WRSTRB2_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce2ctlWrstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok"})
    }
    inst WRHLD2_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce2ctlWrhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok"})
    }
    inst RDSETUP2_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce2ctlRdsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok"})
    }
    inst RDSTRB2_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce2ctlRdstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok"})
    }
    inst RDHLD2_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce2ctlRdhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok"})
    }
    inst MTYPE2_SETUP :: "32-bit async." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
        prop JSName :: "xbusXce2ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
        prop Set :: (self.MTYPE2_SETUP = $1, self.XCE2CTL_VALUE = self.XCE2CTL_VALUE_update(), "ok")
    }
    inst WRSETUP3_SETUP :: 15 { 
        prop Label :: "Write Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce3ctlWrsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.WRSETUP3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok"})
    }
    inst WRSTRB3_SETUP :: 63 { 
        prop Label :: "Write Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce3ctlWrstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.WRSTRB3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok"})
    }
    inst WRHLD3_SETUP :: 3 { 
        prop Label :: "Write Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce3ctlWrhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.WRHLD3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok"})
    }
    inst RDSETUP3_SETUP :: 15 { 
        prop Label :: "Read Setup Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce3ctlRdsetup"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 15) {self.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")} else {self.RDSETUP3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok"})
    }
    inst RDSTRB3_SETUP :: 63 { 
        prop Label :: "Read Strobe Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce3ctlRdstrb"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (if ($1 < 1 || $1 > 63) {self.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")} else {self.RDSTRB3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok"})
    }
    inst RDHLD3_SETUP :: 3 { 
        prop Label :: "Read Hold Width "
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXce3ctlRdhld"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (if ($1 < 0 || $1 > 3) {self.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")} else {self.RDHLD3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok"})
    }
    inst MTYPE3_SETUP :: "32-bit async." { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
        prop JSName :: "xbusXce3ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
        prop Set :: (self.MTYPE3_SETUP = $1, self.XCE3CTL_VALUE = self.XCE3CTL_VALUE_update(), "ok")
    }
    inst XFRCT_SETUP :: 0 { 
        prop Label :: "Transfer Counter(XFRCT)"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "xbusXbhcXfrct"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XBUS HPI Control"
        prop Set :: (if ($1 > 65535) {self.error("Maximum transfer count: 65535 elements")} else {self.XFRCT_SETUP = $1, self.XBHC_VALUE = self.XBHC_VALUE_update(), "ok"})
    }
    inst INTSRC_SETUP :: "DSPINT" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DSPINT,XFRCT Counter"
        prop Label :: "Interrupt Source(INTSRC)"
        prop JSName :: "xbusXbhcIntsrc"
        prop Visible :: 1
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "XBUS HPI Control"
        prop Set :: (self.INTSRC_SETUP = $1, self.XBHC_VALUE = self.XBHC_VALUE_update(), "ok")
    }
    inst START_SETUP :: "Abort Transfer" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Abort Transfer,Write: XBIMA-->XBEA,Read: XBEA-->XBIMA"
        prop Label :: "Start Master Transaction(START)"
        prop JSName :: "xbusXbhcStart"
        prop Visible :: 1
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "XBUS HPI Control"
        prop Set :: (self.START_SETUP = $1, self.XBHC_VALUE = self.XBHC_VALUE_update(), "ok")
    }
    inst DSPINT_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Clear"
        prop Label :: "External Master to DSP Interrupt(DSPINT)"
        prop JSName :: "xbusXbhcDspint"
        prop Visible :: 1
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "XBUS HPI Control"
        prop Set :: (self.DSPINT_SETUP = $1, self.XBHC_VALUE = self.XBHC_VALUE_update(), "ok")
    }
    inst XBIMA_SETUP :: 0x00000000 { 
        prop Label :: "XBUS Internal Master Address(XBIMA)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x02
        prop Format :: "0x%08X"
        prop JSName :: "xbusXbima"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Int. Master/Ext. Addr."
        prop Set :: (self.XBIMA_SETUP = $1, self.XBIMA_VALUE = self.XBIMA_VALUE_update(), "ok")
    }
    inst XBEA_SETUP :: 0x00000000 { 
        prop Label :: "XBUS External Address(XBEA)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x02
        prop Format :: "0x%08X"
        prop JSName :: "xbusXbea"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Int. Master/Ext. Addr."
        prop Set :: (self.XBEA_SETUP = $1, self.XBEA_VALUE = self.XBEA_VALUE_update(), "ok")
    }
    inst GBLCTL_VALUE :: self.GBLCTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Control Register(XBGC)"
        prop Format :: "0x%08X"
        prop JSName :: "xbusXbgc"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0xFFFF0000, $b = $1 & 0x000007FF, $c = $1 & 0x00008000, $d = $1 & 0x00000800, if ($a != 0x00000000) {self.error("reserved space, bit[16..31]")} else {if ($b != 0x00000000) {self.error("reserved space, bit[0..10]")} else {if ($c != 0x00000000) {self.error("Read only for FMOD, bit[15]")} else {if ($d != 0x00000000) {self.error("Read only for XARB, bit[11]")} else {self.GBLCTL_VALUE = $1, self.GBLCTL_SETUP_update($1), "ok"}}}})
    }
    inst XCE0CTL_VALUE :: self.XCE0CTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE0 Space Control Register(XCE0CTL) "
        prop Format :: "0x%08X"
        prop JSName :: "xbusXcectl0"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, $b = $1 & 0x0000000C, $c = $1 & 0x00000080, $d = $1 & 0x0000C000, if (($a != 0x00000020) && ($a != 0x00000050)) {self.error("Undefined memory type for XCE spaces, bit[4..6]")} else {if ($b != 0x00000000) {self.error("reserved space, bit[2..3]")} else {if ($c != 0x00000000) {self.error("reserved space, bit[7]")} else {if ($d != 0x00000000) {self.error("reserved space, bit[14..15]")} else {if (((($1 & 0xF0000000) >> 28) & 0xF) == 0x00000000) {self.error("Write setup width, bit[28..31], requires minimum of 1 cycle")} else {if ((($1 & 0x0FC00000) >> 22) == 0x00000000) {self.error("Write strobe width, bit[22..27], requires minimum of 1 cycle")} else {if ((($1 & 0x000F0000) >> 16) == 0x00000000) {self.error("Read setup width, bit[16..19], requires minimum of 1 cycle")} else {if ((($1 & 0x00003F00) >> 8) == 0x00000000) {self.error("Read strobe width, bit[8..13], requires minimum of 1 cycle")} else {self.XCE0CTL_VALUE = $1, self.XCE0CTL_SETUP_update($1), "ok"}}}}}}}})
    }
    inst XCE1CTL_VALUE :: self.XCE1CTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE1 Space Control Register(XCE1CTL) "
        prop Format :: "0x%08X"
        prop JSName :: "xbusXcectl1"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, $b = $1 & 0x0000000C, $c = $1 & 0x00000080, $d = $1 & 0x0000C000, if (($a != 0x00000020) && ($a != 0x00000050)) {self.error("Undefined memory type for XCE spaces, bit[4..6]")} else {if ($b != 0x00000000) {self.error("reserved space, bit[2..3]")} else {if ($c != 0x00000000) {self.error("reserved space, bit[7]")} else {if ($d != 0x00000000) {self.error("reserved space, bit[14..15]")} else {if (((($1 & 0xF0000000) >> 28) & 0xF) == 0x00000000) {self.error("Write setup width, bit[28..31], requires minimum of 1 cycle")} else {if ((($1 & 0x0FC00000) >> 22) == 0x00000000) {self.error("Write strobe width, bit[22..27], requires minimum of 1 cycle")} else {if ((($1 & 0x000F0000) >> 16) == 0x00000000) {self.error("Read setup width, bit[16..19], requires minimum of 1 cycle")} else {if ((($1 & 0x00003F00) >> 8) == 0x00000000) {self.error("Read strobe width, bit[8..13], requires minimum of 1 cycle")} else {self.XCE1CTL_VALUE = $1, self.XCE1CTL_SETUP_update($1), "ok"}}}}}}}})
    }
    inst XCE2CTL_VALUE :: self.XCE2CTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE2 Space Control Register(XCE2CTL) "
        prop Format :: "0x%08X"
        prop JSName :: "xbusXcectl2"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, $b = $1 & 0x0000000C, $c = $1 & 0x00000080, $d = $1 & 0x0000C000, if (($a != 0x00000020) && ($a != 0x00000050)) {self.error("Undefined memory type for XCE spaces, bit[4..6]")} else {if ($b != 0x00000000) {self.error("reserved space, bit[2..3]")} else {if ($c != 0x00000000) {self.error("reserved space, bit[7]")} else {if ($d != 0x00000000) {self.error("reserved space, bit[14..15]")} else {if (((($1 & 0xF0000000) >> 28) & 0xF) == 0x00000000) {self.error("Write setup width, bit[28..31], requires minimum of 1 cycle")} else {if ((($1 & 0x0FC00000) >> 22) == 0x00000000) {self.error("Write strobe width, bit[22..27], requires minimum of 1 cycle")} else {if ((($1 & 0x000F0000) >> 16) == 0x00000000) {self.error("Read setup width, bit[16..19], requires minimum of 1 cycle")} else {if ((($1 & 0x00003F00) >> 8) == 0x00000000) {self.error("Read strobe width, bit[8..13], requires minimum of 1 cycle")} else {self.XCE2CTL_VALUE = $1, self.XCE2CTL_SETUP_update($1), "ok"}}}}}}}})
    }
    inst XCE3CTL_VALUE :: self.XCE3CTL_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE3 Space Control Register(XCE3CTL) "
        prop Format :: "0x%08X"
        prop JSName :: "xbusXcectl3"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x00000070, $b = $1 & 0x0000000C, $c = $1 & 0x00000080, $d = $1 & 0x0000C000, if (($a != 0x00000020) && ($a != 0x00000050)) {self.error("Undefined memory type for XCE spaces, bit[4..6]")} else {if ($b != 0x00000000) {self.error("reserved space, bit[2..3]")} else {if ($c != 0x00000000) {self.error("reserved space, bit[7]")} else {if ($d != 0x00000000) {self.error("reserved space, bit[14..15]")} else {if (((($1 & 0xF0000000) >> 28) & 0xF) == 0x00000000) {self.error("Write setup width, bit[28..31], requires minimum of 1 cycle")} else {if ((($1 & 0x0FC00000) >> 22) == 0x00000000) {self.error("Write strobe width, bit[22..27], requires minimum of 1 cycle")} else {if ((($1 & 0x000F0000) >> 16) == 0x00000000) {self.error("Read setup width, bit[16..19], requires minimum of 1 cycle")} else {if ((($1 & 0x00003F00) >> 8) == 0x00000000) {self.error("Read strobe width, bit[8..13], requires minimum of 1 cycle")} else {self.XCE3CTL_VALUE = $1, self.XCE3CTL_SETUP_update($1), "ok"}}}}}}}})
    }
    inst XBHC_VALUE :: self.XBHC_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XBUS HPI Control Register(XBHC)"
        prop Format :: "0x%08X"
        prop JSName :: "xbusXbhc"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ($a = $1 & 0x0000FFC0, $b = $1 & 0x00000004, $c = $1 & 0x00000001, $d = $1 & 0x00000018, if ($a != 0x00000000) {self.error("reserved space, bit[6..15]")} else {if ($b != 0x00000000) {self.error("reserved space, bit[2]")} else {if ($c != 0x00000000) {self.error("reserved space, bit[0]")} else {if ($d == 0x00000018) {self.error("Undefined value for START, bit[3..4]")} else {self.XBHC_VALUE = $1, self.XBHC_SETUP_update($1), "ok"}}}})
    }
    inst XBIMA_VALUE :: self.XBIMA_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XBUS Internal Master Address Register(XBIMA)"
        prop Format :: "0x%08X"
        prop JSName :: "xbusXbimaAdv"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XBIMA_VALUE = $1, self.XBIMA_SETUP_update($1), "ok")
    }
    inst XBEA_VALUE :: self.XBEA_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XBUS External Address Register(XBEA)"
        prop Format :: "0x%08X"
        prop JSName :: "xbusXbeaAdv"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (self.XBEA_VALUE = $1, self.XBEA_SETUP_update($1), "ok")
    }
}

type hXbus {
    prop IsContainedIn :: XBUSFOLDER
    prop name :: "hXbus"
    prop Label :: "XBUS Resource Manager"
    prop JSName :: "HXBUS"
    prop GlobalPropertyPage :: "{980E6520-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6521-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop NoGen :: 1
    prop cGen :: CSL.XBUS_SUPPORT
    prop GlobalHelpTopic :: 1072
    global XBUS_INIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-Initialization"
        prop JSName :: "xbusEnablePreInit"
        prop Visible :: 1
        prop Writable :: if (CSL.XBUS_SUPPORT == 1) {1} else {0}
        prop NoGen :: 0
        prop Set :: ($a = 0, scan ($b; xbusCfg) {$a = $a + 1}, if ($1 == 1 && $a == 1 && self.XBUS_INIT == XBUS_NOTHING) {" You must create a new configuration object"} else {self.XBUS_INIT_ENABLE = $1, "ok"})
    }
    global XBUS_INIT :: XBUS_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: xbusCfg
        prop Label :: " Pre-Initialize with"
        prop JSName :: "xbusPreInit"
        prop Visible :: 1
        prop Writable :: if ((CSL.XBUS_SUPPORT == 1) && (self.XBUS_INIT_ENABLE == 1)) {1} else {0}
    }
}

object XBUS_NOTHING :: xbusCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param XFCEN_SETUP :: "XFCLK High"
    param XFRAT_SETUP :: "1/8 CPU Clock Rate"
    param WRSETUP0_SETUP :: 15
    param WRSTRB0_SETUP :: 63
    param WRHLD0_SETUP :: 3
    param RDSETUP0_SETUP :: 15
    param RDSTRB0_SETUP :: 63
    param RDHLD0_SETUP :: 3
    param MTYPE0_SETUP :: "32-bit async."
    param WRSETUP1_SETUP :: 15
    param WRSTRB1_SETUP :: 63
    param WRHLD1_SETUP :: 3
    param RDSETUP1_SETUP :: 15
    param RDSTRB1_SETUP :: 63
    param RDHLD1_SETUP :: 3
    param MTYPE1_SETUP :: "32-bit async."
    param WRSETUP2_SETUP :: 15
    param WRSTRB2_SETUP :: 63
    param WRHLD2_SETUP :: 3
    param RDSETUP2_SETUP :: 15
    param RDSTRB2_SETUP :: 63
    param RDHLD2_SETUP :: 3
    param MTYPE2_SETUP :: "32-bit async."
    param WRSETUP3_SETUP :: 15
    param WRSTRB3_SETUP :: 63
    param WRHLD3_SETUP :: 3
    param RDSETUP3_SETUP :: 15
    param RDSTRB3_SETUP :: 63
    param RDHLD3_SETUP :: 3
    param MTYPE3_SETUP :: "32-bit async."
    param XFRCT_SETUP :: 0
    param INTSRC_SETUP :: "DSPINT"
    param START_SETUP :: "Abort Transfer"
    param DSPINT_SETUP :: "None"
    param XBIMA_SETUP :: 0
    param XBEA_SETUP :: 0
    param GBLCTL_VALUE :: 0
    param XCE0CTL_VALUE :: -49373
    param XCE1CTL_VALUE :: -49373
    param XCE2CTL_VALUE :: -49373
    param XCE3CTL_VALUE :: -49373
    param XBHC_VALUE :: 0
    param XBIMA_VALUE :: 0
    param XBEA_VALUE :: 0
}

object FLASH :: MEM {
    param iComment :: "FLASH"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 1677721600
    param len :: 2097152
    param iAllocHeap :: 0
    param iHeapSize :: 0
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object SDRAM :: MEM {
    param iComment :: "SDRAM"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: -2147483648
    param len :: 29360128
    param iAllocHeap :: 0
    param iHeapSize :: 0
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object MyEmifbConfig :: emifbCfg {
    param iComment :: "EMIFB"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param NOHOLD_SETUP :: "Enable Hold"
    param CLK4EN_SETUP :: "Enabled to clock"
    param CLK6EN_SETUP :: "Enabled to clock"
    param EK1EN_SETUP :: "Enabled to clock"
    param EK2EN_SETUP :: "Enabled to clock"
    param EK1HZ_SETUP :: "Clock during hold"
    param EK2HZ_SETUP :: "Clock during hold"
    param EK2RATE_SETUP :: "1x EMIF input clock"
    param BRMODE_SETUP :: "access/refresh pending or in progress"
    param MTYPE0_SETUP :: "16-bit async. interf."
    param RDSTRB0_SETUP :: 63
    param RDSETUP0_SETUP :: 15
    param RDHLD0_SETUP :: 3
    param WRSTRB0_SETUP :: 63
    param WRSETUP0_SETUP :: 15
    param WRHLD0_SETUP :: 3
    param TA0_SETUP :: 3
    param MTYPE1_SETUP :: "16-bit async. interf."
    param RDSTRB1_SETUP :: 63
    param RDSETUP1_SETUP :: 15
    param RDHLD1_SETUP :: 3
    param WRSTRB1_SETUP :: 63
    param WRSETUP1_SETUP :: 15
    param WRHLD1_SETUP :: 3
    param TA1_SETUP :: 3
    param MTYPE2_SETUP :: "16-bit async. interf."
    param RDSTRB2_SETUP :: 63
    param RDSETUP2_SETUP :: 15
    param RDHLD2_SETUP :: 3
    param WRSTRB2_SETUP :: 63
    param WRSETUP2_SETUP :: 15
    param WRHLD2_SETUP :: 3
    param TA2_SETUP :: 3
    param MTYPE3_SETUP :: "16-bit async. interf."
    param RDSTRB3_SETUP :: 63
    param RDSETUP3_SETUP :: 15
    param RDHLD3_SETUP :: 3
    param WRSTRB3_SETUP :: 63
    param WRSETUP3_SETUP :: 15
    param WRHLD3_SETUP :: 3
    param TA3_SETUP :: 3
    param SYNCRL0_SETUP :: "2 cycles"
    param SYNCWL0_SETUP :: "1 cycle"
    param CEEXT0_SETUP :: "Inactive"
    param RENEN0_SETUP :: "ADS Mode"
    param SNCCLK0_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL1_SETUP :: "2 cycles"
    param SYNCWL1_SETUP :: "0 cycle"
    param CEEXT1_SETUP :: "Inactive"
    param RENEN1_SETUP :: "ADS Mode"
    param SNCCLK1_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL2_SETUP :: "2 cycles"
    param SYNCWL2_SETUP :: "0 cycle"
    param CEEXT2_SETUP :: "Inactive"
    param RENEN2_SETUP :: "ADS Mode"
    param SNCCLK2_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL3_SETUP :: "2 cycles"
    param SYNCWL3_SETUP :: "0 cycle"
    param CEEXT3_SETUP :: "Inactive"
    param RENEN3_SETUP :: "ADS Mode"
    param SNCCLK3_SETUP :: "Sync. to ECLKOUT1"
    param TRC_SETUP :: 15
    param TRP_SETUP :: 8
    param TRCD_SETUP :: 4
    param INIT_SETUP :: "Initialize"
    param RFEN_SETUP :: "Enable"
    param SDCSZ_SETUP :: " 9 addresses"
    param SDRSZ_SETUP :: "11 addresses"
    param SDBSZ_SETUP :: "Two banks"
    param PERIOD_SETUP2 :: 1500
    param XRFR_SETUP :: 1
    param TCL_SETUP :: 3
    param TRAS_SETUP :: 8
    param TRRD_SETUP :: 3
    param TWR_SETUP :: 2
    param THZP_SETUP :: 3
    param RD2RD_SETUP :: 2
    param RD2DEAC_SETUP :: 4
    param RD2WR_SETUP :: 6
    param R2WDQM_SETUP :: 3
    param WR2WR_SETUP :: 2
    param WR2DEAC_SETUP :: 2
    param WR2RD_SETUP :: 2
    param GBLCTL_VALUE :: 73788
    param CECTL0_VALUE :: -237
    param CECTL1_VALUE :: -237
    param CECTL2_VALUE :: -237
    param CECTL3_VALUE :: -237
    param SDCTL_VALUE :: 55111680
    param SDTIM_VALUE :: 6145500
    param SDEXT_VALUE :: 1531711
    param CESEC0_VALUE :: 6
    param CESEC1_VALUE :: 2
    param CESEC2_VALUE :: 2
    param CESEC3_VALUE :: 2
}

object MyEmifaConfig :: emifaCfg {
    param iComment :: "EMIFA"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param NOHOLD_SETUP :: "Disable Hold"
    param CLK4EN_SETUP :: "Enabled to clock"
    param CLK6EN_SETUP :: "Enabled to clock"
    param EK1EN_SETUP :: "Enabled to clock"
    param EK2EN_SETUP :: "Enabled to clock"
    param EK1HZ_SETUP :: "Clock during hold"
    param EK2HZ_SETUP :: "Clock during hold"
    param EK2RATE_SETUP :: "1x EMIF input clock"
    param BRMODE_SETUP :: "access/refresh pending or in progress"
    param MTYPE0_SETUP :: "64-bit SDRAM"
    param RDSTRB0_SETUP :: 63
    param RDSETUP0_SETUP :: 15
    param RDHLD0_SETUP :: 3
    param WRSTRB0_SETUP :: 63
    param WRSETUP0_SETUP :: 15
    param WRHLD0_SETUP :: 3
    param TA0_SETUP :: 3
    param MTYPE1_SETUP :: "64-bit async. interf."
    param RDSTRB1_SETUP :: 63
    param RDSETUP1_SETUP :: 15
    param RDHLD1_SETUP :: 3
    param WRSTRB1_SETUP :: 63
    param WRSETUP1_SETUP :: 15
    param WRHLD1_SETUP :: 3
    param TA1_SETUP :: 3
    param MTYPE2_SETUP :: "32-bit async. interf."
    param RDSTRB2_SETUP :: 10
    param RDSETUP2_SETUP :: 2
    param RDHLD2_SETUP :: 2
    param WRSTRB2_SETUP :: 10
    param WRSETUP2_SETUP :: 2
    param WRHLD2_SETUP :: 2
    param TA2_SETUP :: 2
    param MTYPE3_SETUP :: "32-bit async. interf."
    param RDSTRB3_SETUP :: 10
    param RDSETUP3_SETUP :: 2
    param RDHLD3_SETUP :: 2
    param WRSTRB3_SETUP :: 10
    param WRSETUP3_SETUP :: 2
    param WRHLD3_SETUP :: 2
    param TA3_SETUP :: 2
    param SYNCRL0_SETUP :: "2 cycles"
    param SYNCWL0_SETUP :: "0 cycle"
    param CEEXT0_SETUP :: "Inactive"
    param RENEN0_SETUP :: "ADS Mode"
    param SNCCLK0_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL1_SETUP :: "2 cycles"
    param SYNCWL1_SETUP :: "0 cycle"
    param CEEXT1_SETUP :: "Inactive"
    param RENEN1_SETUP :: "ADS Mode"
    param SNCCLK1_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL2_SETUP :: "2 cycles"
    param SYNCWL2_SETUP :: "0 cycle"
    param CEEXT2_SETUP :: "Inactive"
    param RENEN2_SETUP :: "ADS Mode"
    param SNCCLK2_SETUP :: "Sync. to ECLKOUT1"
    param SYNCRL3_SETUP :: "2 cycles"
    param SYNCWL3_SETUP :: "0 cycle"
    param CEEXT3_SETUP :: "Inactive"
    param RENEN3_SETUP :: "ADS Mode"
    param SNCCLK3_SETUP :: "Sync. to ECLKOUT1"
    param TRC_SETUP :: 8
    param TRP_SETUP :: 2
    param TRCD_SETUP :: 2
    param INIT_SETUP :: "Initialize"
    param RFEN_SETUP :: "Enable"
    param SDCSZ_SETUP :: " 8 addresses"
    param SDRSZ_SETUP :: "11 addresses"
    param SDBSZ_SETUP :: "Four banks"
    param SLFRFR_SETUP :: "Disable"
    param PERIOD_SETUP2 :: 1875
    param XRFR_SETUP :: 1
    param TCL_SETUP :: 2
    param TRAS_SETUP :: 6
    param TRRD_SETUP :: 2
    param TWR_SETUP :: 2
    param THZP_SETUP :: 3
    param RD2RD_SETUP :: 1
    param RD2DEAC_SETUP :: 2
    param RD2WR_SETUP :: 1
    param R2WDQM_SETUP :: 3
    param WR2WR_SETUP :: 2
    param WR2DEAC_SETUP :: 2
    param WR2RD_SETUP :: 1
    param GBLCTL_VALUE :: 73916
    param CECTL0_VALUE :: -45
    param CECTL1_VALUE :: -61
    param CECTL2_VALUE :: 581077538
    param CECTL3_VALUE :: 581077538
    param SDCTL_VALUE :: 1193443328
    param SDTIM_VALUE :: 6145875
    param SDEXT_VALUE :: 460074
    param CESEC0_VALUE :: 2
    param CESEC1_VALUE :: 2
    param CESEC2_VALUE :: 2
    param CESEC3_VALUE :: 2
}

object edmaCfg_FingerVein :: edmaCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param FSYNC_SETUP :: "Enable"
    param TDS_SETUP :: "Disable"
    param TDD_SETUP :: "Enable"
    param DUM_SETUP :: "Increment"
    param SUM_SETUP :: "None"
    param PDTS_SETUP :: "Disable"
    param ESIZE_SETUP :: "32-bit"
    param PRI_SETUP :: "High"
    param TCINT_SETUP :: "Disable"
    param TCC_SETUP :: "Host to DSP Interrupt"
    param TCC_SETUP_NEW :: 0
    param TCCM_SETUP :: 0
    param ATCINT_SETUP :: "Disable"
    param ATCC_SETUP :: 0
    param SRCADDR :: 0
    param SRCADDR_FORMAT :: "Numeric"
    param SRCADDR_NUM :: -2147483648
    param SRCADDR_SYM :: "NULL"
    param SRCADDR_HEADER :: "NULL"
    param SRCADDR_HANDLE :: "NULL"
    param PDTD_SETUP :: "Enable"
    param DSTADDR :: 0
    param DSTADDR_FORMAT :: "Numeric"
    param DSTADDR_NUM :: -2147483648
    param DSTADDR_SYM :: "NULL"
    param DSTADDR_HEADER :: "NULL"
    param DSTADDR_HANDLE :: "NULL"
    param FRAMECNT :: 0
    param XFRCNT_FORMAT :: "Numeric"
    param FRAMECNT_NUM :: 339
    param ELMCNT :: 1
    param ELMCNT_NUM :: 90
    param ELMCNT_HEADER :: "NULL"
    param XFRIDX_FORMAT :: "Numeric"
    param FRAMEIDX :: 0
    param FRAMEIDX_NUM :: 0
    param ELMIDX :: 0
    param ELMIDX_NUM :: 0
    param ELMIDX_HEADER :: "NULL"
    param ECRLD :: 0
    param LINK_SETUP :: "Disable"
    param LINK_TBLHANDLE :: PARAMTBL_NOTHING
    param LINKADDR :: 0
    param OPTION_VALUE :: 547356677
    param SRCADDR_FORMAT_ADV :: "Numeric"
    param SRCADDR_NUM_VALUE :: -2147483648
    param SRCADDR_HEADER_VALUE :: "NULL"
    param XFRCNT_VALUE :: 1
    param XFRCNT_FORMAT_ADV :: "Numeric"
    param XFRCNT_NUM_VALUE :: 22216794
    param DSTADDR_FORMAT_ADV :: "Numeric"
    param DSTADDR_NUM_VALUE :: -2147483648
    param DSTADDR_SYM_VALUE :: "NULL"
    param DSTADDR_HEADER_VALUE :: "NULL"
    param XFRIDX_FORMAT_ADV :: "Numeric"
}

object edmaCfg_FingerPrint :: edmaCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param FSYNC_SETUP :: "Enable"
    param TDS_SETUP :: "Disable"
    param TDD_SETUP :: "Enable"
    param DUM_SETUP :: "Increment"
    param SUM_SETUP :: "None"
    param PDTS_SETUP :: "Disable"
    param ESIZE_SETUP :: "32-bit"
    param PRI_SETUP :: "High"
    param TCINT_SETUP :: "Disable"
    param TCC_SETUP :: "Host to DSP Interrupt"
    param TCC_SETUP_NEW :: 0
    param TCCM_SETUP :: 0
    param ATCINT_SETUP :: "Disable"
    param ATCC_SETUP :: 0
    param SRCADDR :: 0
    param SRCADDR_FORMAT :: "Numeric"
    param SRCADDR_NUM :: -2147483648
    param SRCADDR_SYM :: "NULL"
    param SRCADDR_HEADER :: "NULL"
    param SRCADDR_HANDLE :: "NULL"
    param PDTD_SETUP :: "Enable"
    param DSTADDR :: 0
    param DSTADDR_FORMAT :: "Numeric"
    param DSTADDR_NUM :: -2147483648
    param DSTADDR_SYM :: "NULL"
    param DSTADDR_HEADER :: "NULL"
    param DSTADDR_HANDLE :: "NULL"
    param FRAMECNT :: 0
    param XFRCNT_FORMAT :: "Numeric"
    param FRAMECNT_NUM :: 469
    param ELMCNT :: 1
    param ELMCNT_NUM :: 300
    param ELMCNT_HEADER :: "NULL"
    param XFRIDX_FORMAT :: "Numeric"
    param FRAMEIDX :: 0
    param FRAMEIDX_NUM :: 0
    param ELMIDX :: 0
    param ELMIDX_NUM :: 0
    param ELMIDX_HEADER :: "NULL"
    param ECRLD :: 0
    param LINK_SETUP :: "Disable"
    param LINK_TBLHANDLE :: PARAMTBL_NOTHING
    param LINKADDR :: 0
    param OPTION_VALUE :: 547356677
    param SRCADDR_FORMAT_ADV :: "Numeric"
    param SRCADDR_NUM_VALUE :: -2147483648
    param SRCADDR_HEADER_VALUE :: "NULL"
    param XFRCNT_VALUE :: 1
    param XFRCNT_FORMAT_ADV :: "Numeric"
    param XFRCNT_NUM_VALUE :: 30736684
    param DSTADDR_FORMAT_ADV :: "Numeric"
    param DSTADDR_NUM_VALUE :: -2147483648
    param DSTADDR_SYM_VALUE :: "NULL"
    param DSTADDR_HEADER_VALUE :: "NULL"
    param XFRIDX_FORMAT_ADV :: "Numeric"
}

object DATABUFFER :: MEM {
    param iComment :: "Data Buffer"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: -2118123520
    param len :: 3145728
    param iAllocHeap :: 0
    param iHeapSize :: 0
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object SEM_CAMERA :: SEM {
    param iComment :: "TSK_DIP"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object SEM_INPUT :: SEM {
    param iComment :: "TSK_GUI_INPUT"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object SEM_OK :: SEM {
    param iComment :: "Press the OK button"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object TSK_KEY :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_KeyTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iPRI :: 3
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 2
}

object TSK_GUI_INPUT :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_GUIInputTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iPRI :: 8
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 3
}

object SEM_CAPTURE :: SEM {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object TSK_SHOW_CAPTURE_IMAGE :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_ShowCaptureImageTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iPRI :: 2
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 4
}

object TSK_REGISTER :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_RegisterTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 4096
    param iPRI :: 7
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 5
}

object SEM_REGISTER :: SEM {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object TSK_RECOGNITION :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_RecognitionTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 4096
    param iPRI :: 6
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 6
}

object SEM_RECOGNITION :: SEM {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object flash_lock :: LCK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
}

object SEM_T9 :: SEM {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object TSK_SEND_MESSAGE :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_SendMessageTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iPRI :: 4
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 7
}

object SEM_SUB_MANAGER :: SEM {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object TSK_SUB_MANAGER :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_SubManagerTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 4096
    param iPRI :: 5
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 8
}

object SEM_PASSWORD :: SEM {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iCount :: 0
}

object TSK_PASSWORD :: TSK {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iFXN :: @_PassWordTask
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iPRI :: 9
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 9
}

